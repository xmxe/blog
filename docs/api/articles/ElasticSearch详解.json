{"title":"ElasticSearch详解","slug":"ElasticSearch详解","date":"2022-11-15T07:16:31.078Z","updated":"2023-03-23T01:40:01.843Z","comments":true,"path":"api/articles/ElasticSearch详解.json","excerpt":null,"covers":"https://picd.zhimg.com/v2-de9bcd56c1670f877189df89ded47289_1440w.jpg","content":"\r\n\r\n|                                                              | **[第1章 Elasticsearch概述](https://blog.csdn.net/u011863024/article/details/115721328#1_Elasticsearch_33)** |                                                              |\r\n| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\r\n| [01-开篇](https://blog.csdn.net/u011863024/article/details/115721328#01_35) | [02-技术选型](https://blog.csdn.net/u011863024/article/details/115721328#02_53) | [03-教学大纲](https://blog.csdn.net/u011863024/article/details/115721328#03_94) |\r\n|                                                              |                                                              |                                                              |\r\n|                                                              | **[第2章 Elasticsearch入门](https://blog.csdn.net/u011863024/article/details/115721328#2_Elasticsearch_104)** |                                                              |\r\n| [04-入门-环境准备](https://blog.csdn.net/u011863024/article/details/115721328#04_106) | [05-入门-RESTful & JSON](https://blog.csdn.net/u011863024/article/details/115721328#05RESTful__JSON_152) | [06-入门-Postman客户端工具](https://blog.csdn.net/u011863024/article/details/115721328#06Postman_163) |\r\n| [07-入门-倒排索引](https://blog.csdn.net/u011863024/article/details/115721328#07_172) | [08-入门-HTTP-索引-创建](https://blog.csdn.net/u011863024/article/details/115721328#08HTTP_195) | [09-入门-HTTP-索引-查询 & 删除](https://blog.csdn.net/u011863024/article/details/115721328#09HTTP___241) |\r\n| [10-入门-HTTP-文档-创建（Put & Post）](https://blog.csdn.net/u011863024/article/details/115721328#10HTTPPut__Post_316) | [11-入门-HTTP-查询-主键查询 & 全查询](https://blog.csdn.net/u011863024/article/details/115721328#11HTTP___392) | [12-入门-HTTP-全量修改 & 局部修改 & 删除](https://blog.csdn.net/u011863024/article/details/115721328#12HTTP_____485) |\r\n| [13-入门-HTTP-条件查询 & 分页查询 & 查询排序](https://blog.csdn.net/u011863024/article/details/115721328#13HTTP_____618) | [14-入门-HTTP-多条件查询 & 范围查询](https://blog.csdn.net/u011863024/article/details/115721328#14HTTP___1264) | [15-入门-HTTP-全文检索 & 完全匹配 & 高亮查询](https://blog.csdn.net/u011863024/article/details/115721328#15HTTP_____1522) |\r\n| [16-入门-HTTP-聚合查询](https://blog.csdn.net/u011863024/article/details/115721328#16HTTP_1810) | [17-入门-HTTP-映射关系](https://blog.csdn.net/u011863024/article/details/115721328#17HTTP_2049) | [18-入门-JavaAPI-环境准备](https://blog.csdn.net/u011863024/article/details/115721328#18JavaAPI_2369) |\r\n| [19-入门-JavaAPI-索引-创建](https://blog.csdn.net/u011863024/article/details/115721328#19JavaAPI_2441) | [20-入门-JavaAPI-索引-查询 & 删除](https://blog.csdn.net/u011863024/article/details/115721328#20JavaAPI___2486) | [21-入门-JavaAPI-文档-新增 & 修改](https://blog.csdn.net/u011863024/article/details/115721328#21JavaAPI___2569) |\r\n| [22-入门-JavaAPI-文档-查询 & 删除](https://blog.csdn.net/u011863024/article/details/115721328#22JavaAPI___2727) | [23-入门-JavaAPI-文档-批量新增 & 批量删除](https://blog.csdn.net/u011863024/article/details/115721328#23JavaAPI___2799) | [24-入门-JavaAPI-文档-高级查询-全量查询](https://blog.csdn.net/u011863024/article/details/115721328#24JavaAPI_2882) |\r\n| [25-入门-JavaAPI-文档-高级查询-分页查询 & 条件查询 & 查询排序](https://blog.csdn.net/u011863024/article/details/115721328#25JavaAPI_____2982) | [26-入门-JavaAPI-文档-高级查询-组合查询 & 范围查询](https://blog.csdn.net/u011863024/article/details/115721328#26JavaAPI___3173) | [27-入门-JavaAPI-文档-高级查询-模糊查询 & 高亮查询](https://blog.csdn.net/u011863024/article/details/115721328#27JavaAPI___3317) |\r\n| [28-入门-JavaAPI-文档-高级查询-最大值查询 & 分组查询](https://blog.csdn.net/u011863024/article/details/115721328#28JavaAPI___3477) |                                                              |                                                              |\r\n|                                                              |                                                              |                                                              |\r\n|                                                              | **[第3章 Elasticsearch环境](https://blog.csdn.net/u011863024/article/details/115721328#3_Elasticsearch_3587)** |                                                              |\r\n| [29-环境-简介](https://blog.csdn.net/u011863024/article/details/115721328#29_3589) | [30-环境-Windows集群部署](https://blog.csdn.net/u011863024/article/details/115721328#30Windows_3622) | [31-环境-Linux单节点部署](https://blog.csdn.net/u011863024/article/details/115721328#31Linux_3821) |\r\n| [32-环境-Linux集群部署](https://blog.csdn.net/u011863024/article/details/115721328#32Linux_3945) |                                                              |                                                              |\r\n|                                                              |                                                              |                                                              |\r\n|                                                              | **[第4章 Elasticsearch进阶](https://blog.csdn.net/u011863024/article/details/115721328#4_Elasticsearch_4073)** |                                                              |\r\n| [33-进阶-核心概念](https://blog.csdn.net/u011863024/article/details/115721328#33_4075) | [34-进阶-系统架构-简介](https://blog.csdn.net/u011863024/article/details/115721328#34_4156) | [35-进阶-单节点集群](https://blog.csdn.net/u011863024/article/details/115721328#35_4169) |\r\n| [36-进阶-故障转移](https://blog.csdn.net/u011863024/article/details/115721328#36_4209) | [37-进阶-水平扩容](https://blog.csdn.net/u011863024/article/details/115721328#37_4228) | [38-进阶-应对故障](https://blog.csdn.net/u011863024/article/details/115721328#38_4288) |\r\n| [39-进阶-路由计算 & 分片控制](https://blog.csdn.net/u011863024/article/details/115721328#39___4323) | [40-进阶-数据写流程](https://blog.csdn.net/u011863024/article/details/115721328#40_4352) | [41-进阶-数据读流程](https://blog.csdn.net/u011863024/article/details/115721328#41_4372) |\r\n| [42-进阶-更新流程 & 批量操作流程](https://blog.csdn.net/u011863024/article/details/115721328#42___4378) | [43-进阶-倒排索引](https://blog.csdn.net/u011863024/article/details/115721328#43_4428) | [44-进阶-文档搜索](https://blog.csdn.net/u011863024/article/details/115721328#44_4501) |\r\n| [45-进阶-文档刷新 & 文档刷写 & 文档合并](https://blog.csdn.net/u011863024/article/details/115721328#45_____4557) | [46-进阶-文档分析](https://blog.csdn.net/u011863024/article/details/115721328#46_4689) | [47-进阶-文档控制](https://blog.csdn.net/u011863024/article/details/115721328#47_5124) |\r\n| [48-进阶-文档展示-Kibana](https://blog.csdn.net/u011863024/article/details/115721328#48Kibana_5311) |                                                              |                                                              |\r\n|                                                              |                                                              |                                                              |\r\n|                                                              | **[第5章 Elasticsearch集成](https://blog.csdn.net/u011863024/article/details/115721328#5_Elasticsearch_5340)** |                                                              |\r\n| [49-框架集成-SpringData-整体介绍](https://blog.csdn.net/u011863024/article/details/115721328#49SpringData_5342) | [50-框架集成-SpringData-代码功能集成](https://blog.csdn.net/u011863024/article/details/115721328#50SpringData_5374) | [51-框架集成-SpringData-集成测试-索引操作](https://blog.csdn.net/u011863024/article/details/115721328#51SpringData_5598) |\r\n| [52-框架集成-SpringData-集成测试-文档操作](https://blog.csdn.net/u011863024/article/details/115721328#52SpringData_5639) | [53-框架集成-SpringData-集成测试-文档搜索](https://blog.csdn.net/u011863024/article/details/115721328#53SpringData_5749) | [54-框架集成-SparkStreaming-集成](https://blog.csdn.net/u011863024/article/details/115721328#54SparkStreaming_5800) |\r\n| [55-框架集成-Flink-集成](https://blog.csdn.net/u011863024/article/details/115721328#55Flink_5931) |                                                              |                                                              |\r\n|                                                              |                                                              |                                                              |\r\n|                                                              | **[第6章 Elasticsearch优化](https://blog.csdn.net/u011863024/article/details/115721328#6_Elasticsearch_6060)** |                                                              |\r\n| [56-优化-硬件选择](https://blog.csdn.net/u011863024/article/details/115721328#56_6062) | [57-优化-分片策略](https://blog.csdn.net/u011863024/article/details/115721328#57_6084) | [58-优化-路由选择](https://blog.csdn.net/u011863024/article/details/115721328#58_6119) |\r\n| [59-优化-写入速度优化](https://blog.csdn.net/u011863024/article/details/115721328#59_6140) | [60-优化-内存设置](https://blog.csdn.net/u011863024/article/details/115721328#60_6191) | [61-优化-重要配置](https://blog.csdn.net/u011863024/article/details/115721328#61_6214) |\r\n|                                                              |                                                              |                                                              |\r\n|                                                              | **[第7章 Elasticsearch面试题](https://blog.csdn.net/u011863024/article/details/115721328#7_Elasticsearch_6228)** |                                                              |\r\n| [62-面试题](https://blog.csdn.net/u011863024/article/details/115721328#62_6230) |                                                              |                                                              |\r\n\r\n# 第1章 [Elasticsearch](https://so.csdn.net/so/search?q=Elasticsearch&spm=1001.2101.3001.7020)概述\r\n\r\n## 01-开篇\r\n\r\n[教学视频](https://www.bilibili.com/video/BV1hh411D7sb)\r\n\r\n结构化数据\r\n\r\n![img](https://img-blog.csdnimg.cn/img_convert/a421a414ea8fb8e25c466add5b00d31f.png)\r\n\r\n非结构化数据\r\n\r\n![img](https://img-blog.csdnimg.cn/img_convert/109d3c62c1f36b4f352170488b516709.png)\r\n\r\n半结构化数据\r\n\r\n![img](https://img-blog.csdnimg.cn/img_convert/48742ba6bbdc47e0dae2754027f30a31.png)\r\n\r\n## 02-技术选型\r\n\r\n### Elasticsearch是什么\r\n\r\nThe Elastic Stack,包括Elasticsearch、Kibana、Beats和Logstash（也称为ELK Stack）。能够安全可靠地获取任何来源、任何格式的数据，然后实时地对数据进行搜索、分析和可视化。\r\n\r\nElaticsearch，简称为ES，ES是一个**开源的高扩展的分布式全文搜索引擎**，是整个ElasticStack技术栈的核心。\r\n\r\n它可以近乎实时的存储、检索数据；本身扩展性很好，可以扩展到上百台服务器，处理PB级别的数据。\r\n\r\n> elastic\r\n> 英 [ɪˈlæstɪk] 美 [ɪˈlæstɪk]\r\n> n. 橡皮圈(或带);松紧带\r\n> adj. 橡皮圈(或带)的;有弹性的;有弹力的;灵活的;可改变的;可伸缩的\r\n\r\n### 全文搜索引擎\r\n\r\nGoogle，百度类的网站搜索，它们都是根据网页中的关键字生成索引，我们在搜索的时候输入关键字，它们会将该关键字即索引匹配到的所有网页返回；还有常见的项目中应用日志的搜索等等。对于这些非结构化的数据文本，关系型数据库搜索不是能很好的支持。\r\n\r\n一般传统数据库，全文检索都实现的很鸡肋，因为一般也没人用数据库存文本字段。进行全文检索需要扫描整个表，如果数据量大的话即使对SQL的语法优化，也收效甚微。建立了索引，但是维护起来也很麻烦，对于insert和update操作都会重新构建索引。\r\n\r\n基于以上原因可以分析得出，在一些生产环境中，使用常规的搜索方式，性能是非常差的：\r\n\r\n- 搜索的数据对象是大量的非结构化的文本数据。\r\n- 文件记录量达到数十万或数百万个甚至更多。\r\n- 支持大量基于交互式文本的查询。\r\n- 需求非常灵活的全文搜索查询。\r\n- 对高度相关的搜索结果的有特殊需求，但是没有可用的关系数据库可以满足。\r\n- 对不同记录类型、非文本数据操作或安全事务处理的需求相对较少的情况。为了解决结构化数据搜索和非结构化数据搜索性能问题，我们就需要专业，健壮，强大的全文搜索引擎。\r\n\r\n**这里说到的全文搜索引擎指的是目前广泛应用的主流搜索引擎**。它的工作原理是计算机索引程序通过扫描文章中的每一个词，对每一个词建立一个索引，指明该词在文章中出现的次数和位置，当用户查询时，检索程序就根据事先建立的索引进行查找，并将查找的结果反馈给用户的检索方式。这个过程类似于通过字典中的检索字表查字的过程。\r\n\r\n### Elasticsearch应用案例\r\n\r\n- GitHub:2013年初，抛弃了Solr，采取Elasticsearch来做PB级的搜索。“GitHub使用Elasticsearch搜索20TB的数据，包括13亿文件和1300亿行代码”。\r\n- 维基百科：启动以Elasticsearch为基础的核心搜索架构\r\n- 百度：目前广泛使用Elasticsearch作为文本数据分析，采集百度所有服务器上的各类指标数据及用户自定义数据，通过对各种数据进行多维分析展示，辅助定位分析实例异常或业务层面异常。目前覆盖百度内部20多个业务线（包括云分析、网盟、预测、文库、直达号、钱包、风控等），单集群最大100台机器，200个ES节点，每天导入30TB+数据。\r\n- 新浪：使用Elasticsearch分析处理32亿条实时日志。\r\n- 阿里：使用Elasticsearch构建日志采集和分析体系。\r\n- Stack Overflow：解决Bug问题的网站，全英文，编程人员交流的网站。\r\n\r\n## 03-教学大纲\r\n\r\n- 第1章 Elasticsearch概述\r\n- 第2章 Elasticsearch入门\r\n- 第3章 Elasticsearch环境\r\n- 第4章 Elasticsearch进阶\r\n- 第5章 Elasticsearch集成\r\n- 第6章 Elasticsearch优化\r\n- 第7章 Elasticsearch面试题\r\n\r\n# 第2章 Elasticsearch入门\r\n\r\n## 04-入门-环境准备\r\n\r\n[官方网址](https://www.elastic.co/cn/)\r\n\r\n[官方文档](https://www.elastic.co/guide/index.html)\r\n\r\n[Elasticsearch 7.8.0下载页面](https://www.elastic.co/cn/downloads/past-releases/elasticsearch-7-8-0)\r\n\r\nWindows版的Elasticsearch压缩包，解压即安装完毕，解压后的Elasticsearch的目录结构如下 ：\r\n\r\n| 目录    | 含义           |\r\n| ------- | -------------- |\r\n| bin     | 可执行脚本目录 |\r\n| config  | 配置目录       |\r\n| jdk     | 内置 JDK 目录  |\r\n| lib     | 类库           |\r\n| logs    | 日志目录       |\r\n| modules | 模块目录       |\r\n| plugins | 插件目录       |\r\n\r\n解压后，进入bin文件目录，点击elasticsearch.bat文件启动ES服务。\r\n\r\n注意：9300端口为Elasticsearch集群间组件的通信端口，9200端口为浏览器访问的http协议[RESTful](https://so.csdn.net/so/search?q=RESTful&spm=1001.2101.3001.7020)端口。\r\n\r\n打开浏览器，输入地址：http://localhost:9200，测试返回结果，返回结果如下：\r\n\r\n```json\r\n{\r\n  \"name\" : \"DESKTOP-LNJQ0VF\",\r\n  \"cluster_name\" : \"elasticsearch\",\r\n  \"cluster_uuid\" : \"nCZqBhfdT1-pw8Yas4QU9w\",\r\n  \"version\" : {\r\n    \"number\" : \"7.8.0\",\r\n    \"build_flavor\" : \"default\",\r\n    \"build_type\" : \"zip\",\r\n    \"build_hash\" : \"757314695644ea9a1dc2fecd26d1a43856725e65\",\r\n    \"build_date\" : \"2020-06-14T19:35:50.234439Z\",\r\n    \"build_snapshot\" : false,\r\n    \"lucene_version\" : \"8.5.1\",\r\n    \"minimum_wire_compatibility_version\" : \"6.8.0\",\r\n    \"minimum_index_compatibility_version\" : \"6.0.0-beta1\"\r\n  },\r\n  \"tagline\" : \"You Know, for Search\"\r\n}\r\n\r\n```\r\n\r\n## 05-入门-RESTful & JSON\r\n\r\nREST指的是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是RESTful。Web应用程序最重要的REST原则是，客户端和服务器之间的交互在请求之间是无状态的。从客户端到服务器的每个请求都必须包含理解请求所必需的信息。如果服务器在请求之间的任何时间点重启，客户端不会得到通知。此外，无状态请求可以由任何可用服务器回答，这十分适合云计算之类的环境。客户端可以缓存数据以改进性能。\r\n\r\n在服务器端，应用程序状态和功能可以分为各种资源。资源是一个有趣的概念实体，它向客户端公开。资源的例子有：应用程序对象、数据库记录、算法等等。每个资源都使用URI(Universal Resource Identifier)得到一个唯一的地址。所有资源都共享统一的接口，以便在客户端和服务器之间传输状态。使用的是标准的HTTP方法，比如GET、PUT、POST和DELETE。\r\n\r\n在REST样式的Web服务中，每个资源都有一个地址。资源本身都是方法调用的目\r\n标，方法列表对所有资源都是一样的。这些方法都是标准方法，包括HTTP GET、POST、PUT、DELETE，还可能包括HEAD和OPTIONS。简单的理解就是，**如果想要访问互联网上的资源，就必须向资源所在的服务器发出请求，请求体中必须包含资源的网络路径，以及对资源进行的操作(增删改查)**。\r\n\r\nREST样式的Web服务若有返回结果，大多数以JSON字符串形式返回。\r\n\r\n## 06-入门-[Postman](https://so.csdn.net/so/search?q=Postman&spm=1001.2101.3001.7020)客户端工具\r\n\r\n如果直接通过浏览器向Elasticsearch服务器发请求，那么需要在发送的请求中包含\r\nHTTP标准的方法，而HTTP的大部分特性且仅支持GET和POST方法。所以为了能方便地进行客户端的访问，可以使用Postman软件Postman是一款强大的网页调试工具，提供功能强大的Web API和HTTP请求调试。\r\n\r\n软件功能强大，界面简洁明晰、操作方便快捷，设计得很人性化。Postman中文版能够发送任何类型的HTTP请求(GET,HEAD,POST,PUT…)，不仅能够表单提交，且可以附带任意类型请求体。\r\n\r\n[Postman下载页面](https://www.postman.com/downloads/)\r\n\r\n## 07-入门-倒排索引\r\n\r\n正排索引（传统）\r\n\r\n| id   | content              |\r\n| ---- | -------------------- |\r\n| 1001 | my name is zhang san |\r\n| 1002 | my name is li si     |\r\n\r\n倒排索引\r\n\r\n| keyword | id         |\r\n| ------- | ---------- |\r\n| name    | 1001, 1002 |\r\n| zhang   | 1001       |\r\n\r\nElasticsearch是**面向文档型数据库**，一条数据在这里就是一个文档。为了方便大家理解，我们将Elasticsearch里存储文档数据和关系型数据库MySQL存储数据的概念进行一个类比\r\n\r\n![img](https://img-blog.csdnimg.cn/img_convert/146a779da01f53e7f7a8d53132d3c7cf.png)\r\n\r\nES里的Index可以看做一个库，而Types相当于表，Documents则相当于表的行。这里Types的概念已经被逐渐弱化，Elasticsearch6.X中，一个index下已经只能包含一个type，Elasticsearch7.X中,Type的概念已经被删除了。\r\n\r\n## 08-入门-HTTP-索引-创建\r\n\r\n对比关系型数据库，创建索引就等同于创建数据库。\r\n\r\n在Postman中，向ES服务器发PUT请求：http://127.0.0.1:9200/shopping\r\n\r\n请求后，服务器返回响应：\r\n\r\n```json\r\n{\r\n    \"acknowledged\": true,//响应结果\r\n    \"shards_acknowledged\": true,//分片结果\r\n    \"index\": \"shopping\"//索引名称\r\n}\r\n\r\n```\r\n\r\n后台日志：\r\n\r\n```cmd\r\n[2021-04-08T13:57:06,954][INFO ][o.e.c.m.MetadataCreateIndexService] [DESKTOP-LNJQ0VF] [shopping] creating index, cause [api], templates [], shards [1]/[1], mappings []\r\n\r\n```\r\n\r\n如果重复发PUT请求：http://127.0.0.1:9200/shopping 添加索引，会返回错误信息:\r\n\r\n```json\r\n{\r\n    \"error\": {\r\n        \"root_cause\": [\r\n            {\r\n                \"type\": \"resource_already_exists_exception\",\r\n                \"reason\": \"index [shopping/J0WlEhh4R7aDrfIc3AkwWQ] already exists\",\r\n                \"index_uuid\": \"J0WlEhh4R7aDrfIc3AkwWQ\",\r\n                \"index\": \"shopping\"\r\n            }\r\n        ],\r\n        \"type\": \"resource_already_exists_exception\",\r\n        \"reason\": \"index [shopping/J0WlEhh4R7aDrfIc3AkwWQ] already exists\",\r\n        \"index_uuid\": \"J0WlEhh4R7aDrfIc3AkwWQ\",\r\n        \"index\": \"shopping\"\r\n    },\r\n    \"status\": 400\r\n}\r\n\r\n```\r\n\r\n## 09-入门-HTTP-索引-查询 & 删除\r\n\r\n### 查看所有索引\r\n\r\n在Postman中，向ES服务器发GET请求：http://127.0.0.1:9200/_cat/indices?v\r\n\r\n这里请求路径中的_cat表示查看的意思，indices表示索引，所以整体含义就是查看当前ES服务器中的所有索引，就好像MySQL中的show tables的感觉，服务器响应结果如下:\r\n\r\n```\r\nhealth status index    uuid                   pri rep docs.count docs.deleted store.size pri.store.size\r\nyellow open   shopping J0WlEhh4R7aDrfIc3AkwWQ   1   1          0            0       208b           208b\r\n\r\n```\r\n\r\n| 表头           | 含义                                                         |\r\n| -------------- | ------------------------------------------------------------ |\r\n| health         | 当前服务器健康状态： green(集群完整) yellow(单点正常、集群不完整) red(单点不正常) |\r\n| status         | 索引打开、关闭状态                                           |\r\n| index          | 索引名                                                       |\r\n| uuid           | 索引统一编号                                                 |\r\n| pri            | 主分片数量                                                   |\r\n| rep            | 副本数量                                                     |\r\n| docs.count     | 可用文档数量                                                 |\r\n| docs.deleted   | 文档删除状态（逻辑删除）                                     |\r\n| store.size     | 主分片和副分片整体占空间大小                                 |\r\n| pri.store.size | 主分片占空间大小                                             |\r\n\r\n### 查看单个索引\r\n\r\n在Postman中，向ES服务器发GET请求：http://127.0.0.1:9200/shopping\r\n\r\n返回结果如下：\r\n\r\n```json\r\n{\r\n    \"shopping\": {//索引名\r\n        \"aliases\": {},//别名\r\n        \"mappings\": {},//映射\r\n        \"settings\": {//设置\r\n            \"index\": {//设置 - 索引\r\n                \"creation_date\": \"1617861426847\",//设置 - 索引 - 创建时间\r\n                \"number_of_shards\": \"1\",//设置 - 索引 - 主分片数量\r\n                \"number_of_replicas\": \"1\",//设置 - 索引 - 主分片数量\r\n                \"uuid\": \"J0WlEhh4R7aDrfIc3AkwWQ\",//设置 - 索引 - 主分片数量\r\n                \"version\": {//设置 - 索引 - 主分片数量\r\n                    \"created\": \"7080099\"\r\n                },\r\n                \"provided_name\": \"shopping\"//设置 - 索引 - 主分片数量\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\n### 删除索引\r\n\r\n在Postman中，向ES服务器发DELETE请求：http://127.0.0.1:9200/shopping\r\n\r\n返回结果如下：\r\n\r\n```json\r\n{\r\n    \"acknowledged\": true\r\n}\r\n\r\n```\r\n\r\n再次查看所有索引，GET http://127.0.0.1:9200/_cat/indices?v，返回结果如下：\r\n\r\n```\r\nhealth status index uuid pri rep docs.count docs.deleted store.size pri.store.size\r\n\r\n```\r\n\r\n成功删除。\r\n\r\n## 10-入门-HTTP-文档-创建（Put & Post）\r\n\r\n假设索引已经创建好了，接下来我们来创建文档，并添加数据。这里的文档可以类比为关系型数据库中的表数据，添加的数据格式为JSON格式\r\n\r\n在Postman中，向ES服务器发POST请求：http://127.0.0.1:9200/shopping/_doc，请求体JSON内容为：\r\n\r\n```json\r\n{\r\n    \"title\":\"小米手机\",\r\n    \"category\":\"小米\",\r\n    \"images\":\"http://www.gulixueyuan.com/xm.jpg\",\r\n    \"price\":3999.00\r\n}\r\n\r\n```\r\n\r\n![img](https://img-blog.csdnimg.cn/img_convert/20d54cba223bd9d70ea356d3e40a8161.png)\r\n\r\n注意，此处发送请求的方式必须为POST，不能是PUT，否则会发生错误。\r\n\r\n返回结果：\r\n\r\n```json\r\n{\r\n    \"_index\": \"shopping\",//索引\r\n    \"_type\": \"_doc\",//类型-文档\r\n    \"_id\": \"ANQqsHgBaKNfVnMbhZYU\",//唯一标识，可以类比为 MySQL 中的主键，随机生成\r\n    \"_version\": 1,//版本\r\n    \"result\": \"created\",//结果，这里的 create 表示创建成功\r\n    \"_shards\": {//\r\n        \"total\": 2,//分片 - 总数\r\n        \"successful\": 1,//分片 - 总数\r\n        \"failed\": 0//分片 - 总数\r\n    },\r\n    \"_seq_no\": 0,\r\n    \"_primary_term\": 1\r\n}\r\n\r\n```\r\n\r\n上面的数据创建后，由于没有指定数据唯一性标识（ID），默认情况下，ES服务器会随机生成一个。\r\n\r\n如果想要自定义唯一性标识，需要在创建时指定： http://127.0.0.1:9200/shopping/_doc/1，请求体JSON内容为：\r\n\r\n```json\r\n{\r\n    \"title\":\"小米手机\",\r\n    \"category\":\"小米\",\r\n    \"images\":\"http://www.gulixueyuan.com/xm.jpg\",\r\n    \"price\":3999.00\r\n}\r\n\r\n```\r\n\r\n返回结果如下：\r\n\r\n```json\r\n{\r\n    \"_index\": \"shopping\",\r\n    \"_type\": \"_doc\",\r\n    \"_id\": \"1\",//<------------------自定义唯一性标识\r\n    \"_version\": 1,\r\n    \"result\": \"created\",\r\n    \"_shards\": {\r\n        \"total\": 2,\r\n        \"successful\": 1,\r\n        \"failed\": 0\r\n    },\r\n    \"_seq_no\": 1,\r\n    \"_primary_term\": 1\r\n}\r\n\r\n```\r\n\r\n**此处需要注意：如果增加数据时明确数据主键，那么请求方式也可以为PUT。**\r\n\r\n## 11-入门-HTTP-查询-[主键](https://so.csdn.net/so/search?q=主键&spm=1001.2101.3001.7020)查询 & 全查询\r\n\r\n查看文档时，需要指明文档的唯一性标识，类似于MySQL中数据的主键查询\r\n\r\n在Postman中，向ES服务器发GET请求：http://127.0.0.1:9200/shopping/_doc/1。\r\n\r\n返回结果如下：\r\n\r\n```json\r\n{\r\n    \"_index\": \"shopping\",\r\n    \"_type\": \"_doc\",\r\n    \"_id\": \"1\",\r\n    \"_version\": 1,\r\n    \"_seq_no\": 1,\r\n    \"_primary_term\": 1,\r\n    \"found\": true,\r\n    \"_source\": {\r\n        \"title\": \"小米手机\",\r\n        \"category\": \"小米\",\r\n        \"images\": \"http://www.gulixueyuan.com/xm.jpg\",\r\n        \"price\": 3999\r\n    }\r\n}\r\n\r\n```\r\n\r\n查找不存在的内容，向ES服务器发GET请求：http://127.0.0.1:9200/shopping/_doc/1001。\r\n\r\n返回结果如下：\r\n\r\n```json\r\n{\r\n    \"_index\": \"shopping\",\r\n    \"_type\": \"_doc\",\r\n    \"_id\": \"1001\",\r\n    \"found\": false\r\n}\r\n\r\n```\r\n\r\n查看索引下所有数据，向ES服务器发GET请求：http://127.0.0.1:9200/shopping/_search。\r\n\r\n返回结果如下：\r\n\r\n```json\r\n{\r\n    \"took\": 133,\r\n    \"timed_out\": false,\r\n    \"_shards\": {\r\n        \"total\": 1,\r\n        \"successful\": 1,\r\n        \"skipped\": 0,\r\n        \"failed\": 0\r\n    },\r\n    \"hits\": {\r\n        \"total\": {\r\n            \"value\": 2,\r\n            \"relation\": \"eq\"\r\n        },\r\n        \"max_score\": 1,\r\n        \"hits\": [\r\n            {\r\n                \"_index\": \"shopping\",\r\n                \"_type\": \"_doc\",\r\n                \"_id\": \"ANQqsHgBaKNfVnMbhZYU\",\r\n                \"_score\": 1,\r\n                \"_source\": {\r\n                    \"title\": \"小米手机\",\r\n                    \"category\": \"小米\",\r\n                    \"images\": \"http://www.gulixueyuan.com/xm.jpg\",\r\n                    \"price\": 3999\r\n                }\r\n            },\r\n            {\r\n                \"_index\": \"shopping\",\r\n                \"_type\": \"_doc\",\r\n                \"_id\": \"1\",\r\n                \"_score\": 1,\r\n                \"_source\": {\r\n                    \"title\": \"小米手机\",\r\n                    \"category\": \"小米\",\r\n                    \"images\": \"http://www.gulixueyuan.com/xm.jpg\",\r\n                    \"price\": 3999\r\n                }\r\n            }\r\n        ]\r\n    }\r\n}\r\n\r\n```\r\n\r\n## 12-入门-HTTP-全量修改 & 局部修改 & 删除\r\n\r\n### 全量修改\r\n\r\n和新增文档一样，输入相同的URL地址请求，如果请求体变化，会将原有的数据内容覆盖\r\n\r\n在Postman中，向ES服务器发POST请求：http://127.0.0.1:9200/shopping/_doc/1\r\n\r\n请求体JSON内容为:\r\n\r\n```json\r\n{\r\n    \"title\":\"华为手机\",\r\n    \"category\":\"华为\",\r\n    \"images\":\"http://www.gulixueyuan.com/hw.jpg\",\r\n    \"price\":1999.00\r\n}\r\n\r\n```\r\n\r\n修改成功后，服务器响应结果：\r\n\r\n```json\r\n{\r\n    \"_index\": \"shopping\",\r\n    \"_type\": \"_doc\",\r\n    \"_id\": \"1\",\r\n    \"_version\": 2,\r\n    \"result\": \"updated\",//<-----------updated 表示数据被更新\r\n    \"_shards\": {\r\n        \"total\": 2,\r\n        \"successful\": 1,\r\n        \"failed\": 0\r\n    },\r\n    \"_seq_no\": 2,\r\n    \"_primary_term\": 1\r\n}\r\n\r\n```\r\n\r\n### 局部修改\r\n\r\n修改数据时，也可以只修改某一给条数据的局部信息\r\n\r\n在Postman中，向ES服务器发POST请求：http://127.0.0.1:9200/shopping/_update/1。\r\n\r\n请求体JSON内容为:\r\n\r\n```json\r\n{\r\n\t\"doc\": {\r\n\t\t\"title\":\"小米手机\",\r\n\t\t\"category\":\"小米\"\r\n\t}\r\n}\r\n\r\n```\r\n\r\n返回结果如下：\r\n\r\n```json\r\n{\r\n    \"_index\": \"shopping\",\r\n    \"_type\": \"_doc\",\r\n    \"_id\": \"1\",\r\n    \"_version\": 3,\r\n    \"result\": \"updated\",//<-----------updated 表示数据被更新\r\n    \"_shards\": {\r\n        \"total\": 2,\r\n        \"successful\": 1,\r\n        \"failed\": 0\r\n    },\r\n    \"_seq_no\": 3,\r\n    \"_primary_term\": 1\r\n}\r\n\r\n```\r\n\r\n在Postman中，向ES服务器发GET请求：http://127.0.0.1:9200/shopping/_doc/1，查看修改内容：\r\n\r\n```json\r\n{\r\n    \"_index\": \"shopping\",\r\n    \"_type\": \"_doc\",\r\n    \"_id\": \"1\",\r\n    \"_version\": 3,\r\n    \"_seq_no\": 3,\r\n    \"_primary_term\": 1,\r\n    \"found\": true,\r\n    \"_source\": {\r\n        \"title\": \"小米手机\",\r\n        \"category\": \"小米\",\r\n        \"images\": \"http://www.gulixueyuan.com/hw.jpg\",\r\n        \"price\": 1999\r\n    }\r\n}\r\n\r\n```\r\n\r\n### 删除\r\n\r\n删除一个文档不会立即从磁盘上移除，它只是被标记成已删除（逻辑删除）。\r\n\r\n在Postman中，向ES服务器发DELETE请求：http://127.0.0.1:9200/shopping/_doc/1\r\n\r\n返回结果：\r\n\r\n```json\r\n{\r\n    \"_index\": \"shopping\",\r\n    \"_type\": \"_doc\",\r\n    \"_id\": \"1\",\r\n    \"_version\": 4,\r\n    \"result\": \"deleted\",//<---删除成功\r\n    \"_shards\": {\r\n        \"total\": 2,\r\n        \"successful\": 1,\r\n        \"failed\": 0\r\n    },\r\n    \"_seq_no\": 4,\r\n    \"_primary_term\": 1\r\n}\r\n\r\n```\r\n\r\n在Postman中，向ES服务器发GET请求：http://127.0.0.1:9200/shopping/_doc/1，查看是否删除成功：\r\n\r\n```json\r\n{\r\n    \"_index\": \"shopping\",\r\n    \"_type\": \"_doc\",\r\n    \"_id\": \"1\",\r\n    \"found\": false\r\n}\r\n\r\n```\r\n\r\n## 13-入门-HTTP-条件查询 & 分页查询 & 查询排序\r\n\r\n### 条件查询\r\n\r\n假设有以下文档内容，（在Postman中，向ES服务器发GET请求：http://127.0.0.1:9200/shopping/_search）：\r\n\r\n```json\r\n{\r\n    \"took\": 5,\r\n    \"timed_out\": false,\r\n    \"_shards\": {\r\n        \"total\": 1,\r\n        \"successful\": 1,\r\n        \"skipped\": 0,\r\n        \"failed\": 0\r\n    },\r\n    \"hits\": {\r\n        \"total\": {\r\n            \"value\": 6,\r\n            \"relation\": \"eq\"\r\n        },\r\n        \"max_score\": 1,\r\n        \"hits\": [\r\n            {\r\n                \"_index\": \"shopping\",\r\n                \"_type\": \"_doc\",\r\n                \"_id\": \"ANQqsHgBaKNfVnMbhZYU\",\r\n                \"_score\": 1,\r\n                \"_source\": {\r\n                    \"title\": \"小米手机\",\r\n                    \"category\": \"小米\",\r\n                    \"images\": \"http://www.gulixueyuan.com/xm.jpg\",\r\n                    \"price\": 3999\r\n                }\r\n            },\r\n            {\r\n                \"_index\": \"shopping\",\r\n                \"_type\": \"_doc\",\r\n                \"_id\": \"A9R5sHgBaKNfVnMb25Ya\",\r\n                \"_score\": 1,\r\n                \"_source\": {\r\n                    \"title\": \"小米手机\",\r\n                    \"category\": \"小米\",\r\n                    \"images\": \"http://www.gulixueyuan.com/xm.jpg\",\r\n                    \"price\": 1999\r\n                }\r\n            },\r\n            {\r\n                \"_index\": \"shopping\",\r\n                \"_type\": \"_doc\",\r\n                \"_id\": \"BNR5sHgBaKNfVnMb7pal\",\r\n                \"_score\": 1,\r\n                \"_source\": {\r\n                    \"title\": \"小米手机\",\r\n                    \"category\": \"小米\",\r\n                    \"images\": \"http://www.gulixueyuan.com/xm.jpg\",\r\n                    \"price\": 1999\r\n                }\r\n            },\r\n            {\r\n                \"_index\": \"shopping\",\r\n                \"_type\": \"_doc\",\r\n                \"_id\": \"BtR6sHgBaKNfVnMbX5Y5\",\r\n                \"_score\": 1,\r\n                \"_source\": {\r\n                    \"title\": \"华为手机\",\r\n                    \"category\": \"华为\",\r\n                    \"images\": \"http://www.gulixueyuan.com/xm.jpg\",\r\n                    \"price\": 1999\r\n                }\r\n            },\r\n            {\r\n                \"_index\": \"shopping\",\r\n                \"_type\": \"_doc\",\r\n                \"_id\": \"B9R6sHgBaKNfVnMbZpZ6\",\r\n                \"_score\": 1,\r\n                \"_source\": {\r\n                    \"title\": \"华为手机\",\r\n                    \"category\": \"华为\",\r\n                    \"images\": \"http://www.gulixueyuan.com/xm.jpg\",\r\n                    \"price\": 1999\r\n                }\r\n            },\r\n            {\r\n                \"_index\": \"shopping\",\r\n                \"_type\": \"_doc\",\r\n                \"_id\": \"CdR7sHgBaKNfVnMbsJb9\",\r\n                \"_score\": 1,\r\n                \"_source\": {\r\n                    \"title\": \"华为手机\",\r\n                    \"category\": \"华为\",\r\n                    \"images\": \"http://www.gulixueyuan.com/xm.jpg\",\r\n                    \"price\": 1999\r\n                }\r\n            }\r\n        ]\r\n    }\r\n}\r\n\r\n```\r\n\r\n#### URL带参查询\r\n\r\n**查找category为小米的文档**，在Postman中，向ES服务器发GET请求：http://127.0.0.1:9200/shopping/_search?q=category:小米，返回结果如下：\r\n\r\n```json\r\n{\r\n    \"took\": 94,\r\n    \"timed_out\": false,\r\n    \"_shards\": {\r\n        \"total\": 1,\r\n        \"successful\": 1,\r\n        \"skipped\": 0,\r\n        \"failed\": 0\r\n    },\r\n    \"hits\": {\r\n        \"total\": {\r\n            \"value\": 3,\r\n            \"relation\": \"eq\"\r\n        },\r\n        \"max_score\": 1.3862942,\r\n        \"hits\": [\r\n            {\r\n                \"_index\": \"shopping\",\r\n                \"_type\": \"_doc\",\r\n                \"_id\": \"ANQqsHgBaKNfVnMbhZYU\",\r\n                \"_score\": 1.3862942,\r\n                \"_source\": {\r\n                    \"title\": \"小米手机\",\r\n                    \"category\": \"小米\",\r\n                    \"images\": \"http://www.gulixueyuan.com/xm.jpg\",\r\n                    \"price\": 3999\r\n                }\r\n            },\r\n            {\r\n                \"_index\": \"shopping\",\r\n                \"_type\": \"_doc\",\r\n                \"_id\": \"A9R5sHgBaKNfVnMb25Ya\",\r\n                \"_score\": 1.3862942,\r\n                \"_source\": {\r\n                    \"title\": \"小米手机\",\r\n                    \"category\": \"小米\",\r\n                    \"images\": \"http://www.gulixueyuan.com/xm.jpg\",\r\n                    \"price\": 1999\r\n                }\r\n            },\r\n            {\r\n                \"_index\": \"shopping\",\r\n                \"_type\": \"_doc\",\r\n                \"_id\": \"BNR5sHgBaKNfVnMb7pal\",\r\n                \"_score\": 1.3862942,\r\n                \"_source\": {\r\n                    \"title\": \"小米手机\",\r\n                    \"category\": \"小米\",\r\n                    \"images\": \"http://www.gulixueyuan.com/xm.jpg\",\r\n                    \"price\": 1999\r\n                }\r\n            }\r\n        ]\r\n    }\r\n}\r\n```\r\n\r\n上述为URL带参数形式查询，这很容易让不善者心怀恶意，或者参数值出现中文会出现乱码情况。为了避免这些情况，我们可用使用带JSON请求体请求进行查询。\r\n\r\n#### 请求体带参查询\r\n\r\n接下带JSON请求体，还是**查找category为小米的文档**，在Postman中，向ES服务器发GET请求：http://127.0.0.1:9200/shopping/_search，附带JSON体如下：\r\n\r\n```json\r\n{\r\n\t\"query\":{\r\n\t\t\"match\":{\r\n\t\t\t\"category\":\"小米\"\r\n\t\t}\r\n\t}\r\n}\r\n\r\n```\r\n\r\n返回结果如下：\r\n\r\n```json\r\n{\r\n    \"took\": 3,\r\n    \"timed_out\": false,\r\n    \"_shards\": {\r\n        \"total\": 1,\r\n        \"successful\": 1,\r\n        \"skipped\": 0,\r\n        \"failed\": 0\r\n    },\r\n    \"hits\": {\r\n        \"total\": {\r\n            \"value\": 3,\r\n            \"relation\": \"eq\"\r\n        },\r\n        \"max_score\": 1.3862942,\r\n        \"hits\": [\r\n            {\r\n                \"_index\": \"shopping\",\r\n                \"_type\": \"_doc\",\r\n                \"_id\": \"ANQqsHgBaKNfVnMbhZYU\",\r\n                \"_score\": 1.3862942,\r\n                \"_source\": {\r\n                    \"title\": \"小米手机\",\r\n                    \"category\": \"小米\",\r\n                    \"images\": \"http://www.gulixueyuan.com/xm.jpg\",\r\n                    \"price\": 3999\r\n                }\r\n            },\r\n            {\r\n                \"_index\": \"shopping\",\r\n                \"_type\": \"_doc\",\r\n                \"_id\": \"A9R5sHgBaKNfVnMb25Ya\",\r\n                \"_score\": 1.3862942,\r\n                \"_source\": {\r\n                    \"title\": \"小米手机\",\r\n                    \"category\": \"小米\",\r\n                    \"images\": \"http://www.gulixueyuan.com/xm.jpg\",\r\n                    \"price\": 1999\r\n                }\r\n            },\r\n            {\r\n                \"_index\": \"shopping\",\r\n                \"_type\": \"_doc\",\r\n                \"_id\": \"BNR5sHgBaKNfVnMb7pal\",\r\n                \"_score\": 1.3862942,\r\n                \"_source\": {\r\n                    \"title\": \"小米手机\",\r\n                    \"category\": \"小米\",\r\n                    \"images\": \"http://www.gulixueyuan.com/xm.jpg\",\r\n                    \"price\": 1999\r\n                }\r\n            }\r\n        ]\r\n    }\r\n}\r\n\r\n```\r\n\r\n#### 带请求体方式的查找所有内容\r\n\r\n**查找所有文档内容**，也可以这样，在Postman中，向ES服务器发GET请求：http://127.0.0.1:9200/shopping/_search，附带JSON体如下：\r\n\r\n```json\r\n{\r\n\t\"query\":{\r\n\t\t\"match_all\":{}\r\n\t}\r\n}\r\n\r\n```\r\n\r\n则返回所有文档内容：\r\n\r\n```json\r\n{\r\n    \"took\": 2,\r\n    \"timed_out\": false,\r\n    \"_shards\": {\r\n        \"total\": 1,\r\n        \"successful\": 1,\r\n        \"skipped\": 0,\r\n        \"failed\": 0\r\n    },\r\n    \"hits\": {\r\n        \"total\": {\r\n            \"value\": 6,\r\n            \"relation\": \"eq\"\r\n        },\r\n        \"max_score\": 1,\r\n        \"hits\": [\r\n            {\r\n                \"_index\": \"shopping\",\r\n                \"_type\": \"_doc\",\r\n                \"_id\": \"ANQqsHgBaKNfVnMbhZYU\",\r\n                \"_score\": 1,\r\n                \"_source\": {\r\n                    \"title\": \"小米手机\",\r\n                    \"category\": \"小米\",\r\n                    \"images\": \"http://www.gulixueyuan.com/xm.jpg\",\r\n                    \"price\": 3999\r\n                }\r\n            },\r\n            {\r\n                \"_index\": \"shopping\",\r\n                \"_type\": \"_doc\",\r\n                \"_id\": \"A9R5sHgBaKNfVnMb25Ya\",\r\n                \"_score\": 1,\r\n                \"_source\": {\r\n                    \"title\": \"小米手机\",\r\n                    \"category\": \"小米\",\r\n                    \"images\": \"http://www.gulixueyuan.com/xm.jpg\",\r\n                    \"price\": 1999\r\n                }\r\n            },\r\n            {\r\n                \"_index\": \"shopping\",\r\n                \"_type\": \"_doc\",\r\n                \"_id\": \"BNR5sHgBaKNfVnMb7pal\",\r\n                \"_score\": 1,\r\n                \"_source\": {\r\n                    \"title\": \"小米手机\",\r\n                    \"category\": \"小米\",\r\n                    \"images\": \"http://www.gulixueyuan.com/xm.jpg\",\r\n                    \"price\": 1999\r\n                }\r\n            },\r\n            {\r\n                \"_index\": \"shopping\",\r\n                \"_type\": \"_doc\",\r\n                \"_id\": \"BtR6sHgBaKNfVnMbX5Y5\",\r\n                \"_score\": 1,\r\n                \"_source\": {\r\n                    \"title\": \"华为手机\",\r\n                    \"category\": \"华为\",\r\n                    \"images\": \"http://www.gulixueyuan.com/xm.jpg\",\r\n                    \"price\": 1999\r\n                }\r\n            },\r\n            {\r\n                \"_index\": \"shopping\",\r\n                \"_type\": \"_doc\",\r\n                \"_id\": \"B9R6sHgBaKNfVnMbZpZ6\",\r\n                \"_score\": 1,\r\n                \"_source\": {\r\n                    \"title\": \"华为手机\",\r\n                    \"category\": \"华为\",\r\n                    \"images\": \"http://www.gulixueyuan.com/xm.jpg\",\r\n                    \"price\": 1999\r\n                }\r\n            },\r\n            {\r\n                \"_index\": \"shopping\",\r\n                \"_type\": \"_doc\",\r\n                \"_id\": \"CdR7sHgBaKNfVnMbsJb9\",\r\n                \"_score\": 1,\r\n                \"_source\": {\r\n                    \"title\": \"华为手机\",\r\n                    \"category\": \"华为\",\r\n                    \"images\": \"http://www.gulixueyuan.com/xm.jpg\",\r\n                    \"price\": 1999\r\n                }\r\n            }\r\n        ]\r\n    }\r\n}\r\n\r\n```\r\n\r\n#### 查询指定字段\r\n\r\n**如果你想查询指定字段**，在Postman中，向ES服务器发GET请求：http://127.0.0.1:9200/shopping/_search，附带JSON体如下：\r\n\r\n```json\r\n{\r\n\t\"query\":{\r\n\t\t\"match_all\":{}\r\n\t},\r\n\t\"_source\":[\"title\"]\r\n}\r\n\r\n```\r\n\r\n返回结果如下：\r\n\r\n```json\r\n{\r\n    \"took\": 5,\r\n    \"timed_out\": false,\r\n    \"_shards\": {\r\n        \"total\": 1,\r\n        \"successful\": 1,\r\n        \"skipped\": 0,\r\n        \"failed\": 0\r\n    },\r\n    \"hits\": {\r\n        \"total\": {\r\n            \"value\": 6,\r\n            \"relation\": \"eq\"\r\n        },\r\n        \"max_score\": 1,\r\n        \"hits\": [\r\n            {\r\n                \"_index\": \"shopping\",\r\n                \"_type\": \"_doc\",\r\n                \"_id\": \"ANQqsHgBaKNfVnMbhZYU\",\r\n                \"_score\": 1,\r\n                \"_source\": {\r\n                    \"title\": \"小米手机\"\r\n                }\r\n            },\r\n            {\r\n                \"_index\": \"shopping\",\r\n                \"_type\": \"_doc\",\r\n                \"_id\": \"A9R5sHgBaKNfVnMb25Ya\",\r\n                \"_score\": 1,\r\n                \"_source\": {\r\n                    \"title\": \"小米手机\"\r\n                }\r\n            },\r\n            {\r\n                \"_index\": \"shopping\",\r\n                \"_type\": \"_doc\",\r\n                \"_id\": \"BNR5sHgBaKNfVnMb7pal\",\r\n                \"_score\": 1,\r\n                \"_source\": {\r\n                    \"title\": \"小米手机\"\r\n                }\r\n            },\r\n            {\r\n                \"_index\": \"shopping\",\r\n                \"_type\": \"_doc\",\r\n                \"_id\": \"BtR6sHgBaKNfVnMbX5Y5\",\r\n                \"_score\": 1,\r\n                \"_source\": {\r\n                    \"title\": \"华为手机\"\r\n                }\r\n            },\r\n            {\r\n                \"_index\": \"shopping\",\r\n                \"_type\": \"_doc\",\r\n                \"_id\": \"B9R6sHgBaKNfVnMbZpZ6\",\r\n                \"_score\": 1,\r\n                \"_source\": {\r\n                    \"title\": \"华为手机\"\r\n                }\r\n            },\r\n            {\r\n                \"_index\": \"shopping\",\r\n                \"_type\": \"_doc\",\r\n                \"_id\": \"CdR7sHgBaKNfVnMbsJb9\",\r\n                \"_score\": 1,\r\n                \"_source\": {\r\n                    \"title\": \"华为手机\"\r\n                }\r\n            }\r\n        ]\r\n    }\r\n}\r\n\r\n```\r\n\r\n### 分页查询\r\n\r\n在Postman中，向ES服务器发GET请求：http://127.0.0.1:9200/shopping/_search，附带JSON体如下：\r\n\r\n```json\r\n{\r\n\t\"query\":{\r\n\t\t\"match_all\":{}\r\n\t},\r\n\t\"from\":0,\r\n\t\"size\":2\r\n}\r\n\r\n```\r\n\r\n返回结果如下：\r\n\r\n```java\r\n{\r\n    \"took\": 1,\r\n    \"timed_out\": false,\r\n    \"_shards\": {\r\n        \"total\": 1,\r\n        \"successful\": 1,\r\n        \"skipped\": 0,\r\n        \"failed\": 0\r\n    },\r\n    \"hits\": {\r\n        \"total\": {\r\n            \"value\": 6,\r\n            \"relation\": \"eq\"\r\n        },\r\n        \"max_score\": 1,\r\n        \"hits\": [\r\n            {\r\n                \"_index\": \"shopping\",\r\n                \"_type\": \"_doc\",\r\n                \"_id\": \"ANQqsHgBaKNfVnMbhZYU\",\r\n                \"_score\": 1,\r\n                \"_source\": {\r\n                    \"title\": \"小米手机\",\r\n                    \"category\": \"小米\",\r\n                    \"images\": \"http://www.gulixueyuan.com/xm.jpg\",\r\n                    \"price\": 3999\r\n                }\r\n            },\r\n            {\r\n                \"_index\": \"shopping\",\r\n                \"_type\": \"_doc\",\r\n                \"_id\": \"A9R5sHgBaKNfVnMb25Ya\",\r\n                \"_score\": 1,\r\n                \"_source\": {\r\n                    \"title\": \"小米手机\",\r\n                    \"category\": \"小米\",\r\n                    \"images\": \"http://www.gulixueyuan.com/xm.jpg\",\r\n                    \"price\": 1999\r\n                }\r\n            }\r\n        ]\r\n    }\r\n}\r\n```\r\n\r\n### 查询排序\r\n\r\n如果你想通过排序查出价格最高的手机，在Postman中，向ES服务器发GET请求：http://127.0.0.1:9200/shopping/_search，附带JSON体如下：\r\n\r\n```json\r\n{\r\n\t\"query\":{\r\n\t\t\"match_all\":{}\r\n\t},\r\n\t\"sort\":{\r\n\t\t\"price\":{\r\n\t\t\t\"order\":\"desc\"\r\n\t\t}\r\n\t}\r\n}\r\n\r\n```\r\n\r\n返回结果如下：\r\n\r\n```json\r\n{\r\n    \"took\": 96,\r\n    \"timed_out\": false,\r\n    \"_shards\": {\r\n        \"total\": 1,\r\n        \"successful\": 1,\r\n        \"skipped\": 0,\r\n        \"failed\": 0\r\n    },\r\n    \"hits\": {\r\n        \"total\": {\r\n            \"value\": 6,\r\n            \"relation\": \"eq\"\r\n        },\r\n        \"max_score\": null,\r\n        \"hits\": [\r\n            {\r\n                \"_index\": \"shopping\",\r\n                \"_type\": \"_doc\",\r\n                \"_id\": \"ANQqsHgBaKNfVnMbhZYU\",\r\n                \"_score\": null,\r\n                \"_source\": {\r\n                    \"title\": \"小米手机\",\r\n                    \"category\": \"小米\",\r\n                    \"images\": \"http://www.gulixueyuan.com/xm.jpg\",\r\n                    \"price\": 3999\r\n                },\r\n                \"sort\": [\r\n                    3999\r\n                ]\r\n            },\r\n            {\r\n                \"_index\": \"shopping\",\r\n                \"_type\": \"_doc\",\r\n                \"_id\": \"A9R5sHgBaKNfVnMb25Ya\",\r\n                \"_score\": null,\r\n                \"_source\": {\r\n                    \"title\": \"小米手机\",\r\n                    \"category\": \"小米\",\r\n                    \"images\": \"http://www.gulixueyuan.com/xm.jpg\",\r\n                    \"price\": 1999\r\n                },\r\n                \"sort\": [\r\n                    1999\r\n                ]\r\n            },\r\n            {\r\n                \"_index\": \"shopping\",\r\n                \"_type\": \"_doc\",\r\n                \"_id\": \"BNR5sHgBaKNfVnMb7pal\",\r\n                \"_score\": null,\r\n                \"_source\": {\r\n                    \"title\": \"小米手机\",\r\n                    \"category\": \"小米\",\r\n                    \"images\": \"http://www.gulixueyuan.com/xm.jpg\",\r\n                    \"price\": 1999\r\n                },\r\n                \"sort\": [\r\n                    1999\r\n                ]\r\n            },\r\n            {\r\n                \"_index\": \"shopping\",\r\n                \"_type\": \"_doc\",\r\n                \"_id\": \"BtR6sHgBaKNfVnMbX5Y5\",\r\n                \"_score\": null,\r\n                \"_source\": {\r\n                    \"title\": \"华为手机\",\r\n                    \"category\": \"华为\",\r\n                    \"images\": \"http://www.gulixueyuan.com/xm.jpg\",\r\n                    \"price\": 1999\r\n                },\r\n                \"sort\": [\r\n                    1999\r\n                ]\r\n            },\r\n            {\r\n                \"_index\": \"shopping\",\r\n                \"_type\": \"_doc\",\r\n                \"_id\": \"B9R6sHgBaKNfVnMbZpZ6\",\r\n                \"_score\": null,\r\n                \"_source\": {\r\n                    \"title\": \"华为手机\",\r\n                    \"category\": \"华为\",\r\n                    \"images\": \"http://www.gulixueyuan.com/xm.jpg\",\r\n                    \"price\": 1999\r\n                },\r\n                \"sort\": [\r\n                    1999\r\n                ]\r\n            },\r\n            {\r\n                \"_index\": \"shopping\",\r\n                \"_type\": \"_doc\",\r\n                \"_id\": \"CdR7sHgBaKNfVnMbsJb9\",\r\n                \"_score\": null,\r\n                \"_source\": {\r\n                    \"title\": \"华为手机\",\r\n                    \"category\": \"华为\",\r\n                    \"images\": \"http://www.gulixueyuan.com/xm.jpg\",\r\n                    \"price\": 1999\r\n                },\r\n                \"sort\": [\r\n                    1999\r\n                ]\r\n            }\r\n        ]\r\n    }\r\n}\r\n\r\n```\r\n\r\n## 14-入门-HTTP-多条件查询 & 范围查询\r\n\r\n### 多条件查询\r\n\r\n假设想找出小米牌子，价格为3999元的。（must相当于数据库的&&）\r\n\r\n在Postman中，向ES服务器发GET请求：http://127.0.0.1:9200/shopping/_search，附带JSON体如下：\r\n\r\n```json\r\n{\r\n\t\"query\":{\r\n\t\t\"bool\":{\r\n\t\t\t\"must\":[{\r\n\t\t\t\t\"match\":{\r\n\t\t\t\t\t\"category\":\"小米\"\r\n\t\t\t\t}\r\n\t\t\t},{\r\n\t\t\t\t\"match\":{\r\n\t\t\t\t\t\"price\":3999.00\r\n\t\t\t\t}\r\n\t\t\t}]\r\n\t\t}\r\n\t}\r\n}\r\n\r\n```\r\n\r\n返回结果如下：\r\n\r\n```json\r\n{\r\n    \"took\": 134,\r\n    \"timed_out\": false,\r\n    \"_shards\": {\r\n        \"total\": 1,\r\n        \"successful\": 1,\r\n        \"skipped\": 0,\r\n        \"failed\": 0\r\n    },\r\n    \"hits\": {\r\n        \"total\": {\r\n            \"value\": 1,\r\n            \"relation\": \"eq\"\r\n        },\r\n        \"max_score\": 2.3862944,\r\n        \"hits\": [\r\n            {\r\n                \"_index\": \"shopping\",\r\n                \"_type\": \"_doc\",\r\n                \"_id\": \"ANQqsHgBaKNfVnMbhZYU\",\r\n                \"_score\": 2.3862944,\r\n                \"_source\": {\r\n                    \"title\": \"小米手机\",\r\n                    \"category\": \"小米\",\r\n                    \"images\": \"http://www.gulixueyuan.com/xm.jpg\",\r\n                    \"price\": 3999\r\n                }\r\n            }\r\n        ]\r\n    }\r\n}\r\n\r\n```\r\n\r\n假设想找出小米和华为的牌子。（should相当于数据库的||）\r\n\r\n在Postman中，向ES服务器发GET请求：http://127.0.0.1:9200/shopping/_search，附带JSON体如下：\r\n\r\n```json\r\n{\r\n\t\"query\":{\r\n\t\t\"bool\":{\r\n\t\t\t\"should\":[{\r\n\t\t\t\t\"match\":{\r\n\t\t\t\t\t\"category\":\"小米\"\r\n\t\t\t\t}\r\n\t\t\t},{\r\n\t\t\t\t\"match\":{\r\n\t\t\t\t\t\"category\":\"华为\"\r\n\t\t\t\t}\r\n\t\t\t}]\r\n\t\t},\r\n        \"filter\":{\r\n            \"range\":{\r\n                \"price\":{\r\n                    \"gt\":2000\r\n                }\r\n            }\r\n        }\r\n\t}\r\n}\r\n\r\n```\r\n\r\n返回结果如下：\r\n\r\n```json\r\n{\r\n    \"took\": 8,\r\n    \"timed_out\": false,\r\n    \"_shards\": {\r\n        \"total\": 1,\r\n        \"successful\": 1,\r\n        \"skipped\": 0,\r\n        \"failed\": 0\r\n    },\r\n    \"hits\": {\r\n        \"total\": {\r\n            \"value\": 6,\r\n            \"relation\": \"eq\"\r\n        },\r\n        \"max_score\": 1.3862942,\r\n        \"hits\": [\r\n            {\r\n                \"_index\": \"shopping\",\r\n                \"_type\": \"_doc\",\r\n                \"_id\": \"ANQqsHgBaKNfVnMbhZYU\",\r\n                \"_score\": 1.3862942,\r\n                \"_source\": {\r\n                    \"title\": \"小米手机\",\r\n                    \"category\": \"小米\",\r\n                    \"images\": \"http://www.gulixueyuan.com/xm.jpg\",\r\n                    \"price\": 3999\r\n                }\r\n            },\r\n            {\r\n                \"_index\": \"shopping\",\r\n                \"_type\": \"_doc\",\r\n                \"_id\": \"A9R5sHgBaKNfVnMb25Ya\",\r\n                \"_score\": 1.3862942,\r\n                \"_source\": {\r\n                    \"title\": \"小米手机\",\r\n                    \"category\": \"小米\",\r\n                    \"images\": \"http://www.gulixueyuan.com/xm.jpg\",\r\n                    \"price\": 1999\r\n                }\r\n            },\r\n            {\r\n                \"_index\": \"shopping\",\r\n                \"_type\": \"_doc\",\r\n                \"_id\": \"BNR5sHgBaKNfVnMb7pal\",\r\n                \"_score\": 1.3862942,\r\n                \"_source\": {\r\n                    \"title\": \"小米手机\",\r\n                    \"category\": \"小米\",\r\n                    \"images\": \"http://www.gulixueyuan.com/xm.jpg\",\r\n                    \"price\": 1999\r\n                }\r\n            },\r\n            {\r\n                \"_index\": \"shopping\",\r\n                \"_type\": \"_doc\",\r\n                \"_id\": \"BtR6sHgBaKNfVnMbX5Y5\",\r\n                \"_score\": 1.3862942,\r\n                \"_source\": {\r\n                    \"title\": \"华为手机\",\r\n                    \"category\": \"华为\",\r\n                    \"images\": \"http://www.gulixueyuan.com/xm.jpg\",\r\n                    \"price\": 1999\r\n                }\r\n            },\r\n            {\r\n                \"_index\": \"shopping\",\r\n                \"_type\": \"_doc\",\r\n                \"_id\": \"B9R6sHgBaKNfVnMbZpZ6\",\r\n                \"_score\": 1.3862942,\r\n                \"_source\": {\r\n                    \"title\": \"华为手机\",\r\n                    \"category\": \"华为\",\r\n                    \"images\": \"http://www.gulixueyuan.com/xm.jpg\",\r\n                    \"price\": 1999\r\n                }\r\n            },\r\n            {\r\n                \"_index\": \"shopping\",\r\n                \"_type\": \"_doc\",\r\n                \"_id\": \"CdR7sHgBaKNfVnMbsJb9\",\r\n                \"_score\": 1.3862942,\r\n                \"_source\": {\r\n                    \"title\": \"华为手机\",\r\n                    \"category\": \"华为\",\r\n                    \"images\": \"http://www.gulixueyuan.com/xm.jpg\",\r\n                    \"price\": 1999\r\n                }\r\n            }\r\n        ]\r\n    }\r\n}\r\n\r\n```\r\n\r\n### 范围查询\r\n\r\n假设想找出小米和华为的牌子，价格大于2000元的手机。\r\n\r\n在Postman中，向ES服务器发GET请求：http://127.0.0.1:9200/shopping/_search，附带JSON体如下：\r\n\r\n```json\r\n{\r\n\t\"query\":{\r\n\t\t\"bool\":{\r\n\t\t\t\"should\":[{\r\n\t\t\t\t\"match\":{\r\n\t\t\t\t\t\"category\":\"小米\"\r\n\t\t\t\t}\r\n\t\t\t},{\r\n\t\t\t\t\"match\":{\r\n\t\t\t\t\t\"category\":\"华为\"\r\n\t\t\t\t}\r\n\t\t\t}],\r\n            \"filter\":{\r\n            \t\"range\":{\r\n                \t\"price\":{\r\n                    \t\"gt\":2000\r\n                \t}\r\n\t            }\r\n    \t    }\r\n\t\t}\r\n\t}\r\n}\r\n\r\n```\r\n\r\n返回结果如下：\r\n\r\n```json\r\n{\r\n    \"took\": 72,\r\n    \"timed_out\": false,\r\n    \"_shards\": {\r\n        \"total\": 1,\r\n        \"successful\": 1,\r\n        \"skipped\": 0,\r\n        \"failed\": 0\r\n    },\r\n    \"hits\": {\r\n        \"total\": {\r\n            \"value\": 1,\r\n            \"relation\": \"eq\"\r\n        },\r\n        \"max_score\": 1.3862942,\r\n        \"hits\": [\r\n            {\r\n                \"_index\": \"shopping\",\r\n                \"_type\": \"_doc\",\r\n                \"_id\": \"ANQqsHgBaKNfVnMbhZYU\",\r\n                \"_score\": 1.3862942,\r\n                \"_source\": {\r\n                    \"title\": \"小米手机\",\r\n                    \"category\": \"小米\",\r\n                    \"images\": \"http://www.gulixueyuan.com/xm.jpg\",\r\n                    \"price\": 3999\r\n                }\r\n            }\r\n        ]\r\n    }\r\n}\r\n\r\n```\r\n\r\n## 15-入门-HTTP-全文检索 & 完全匹配 & 高亮查询\r\n\r\n### 全文检索\r\n\r\n这功能像搜索引擎那样，如品牌输入“小华”，返回结果带回品牌有“小米”和华为的。\r\n\r\n在Postman中，向ES服务器发GET请求：http://127.0.0.1:9200/shopping/_search，附带JSON体如下：\r\n\r\n```json\r\n{\r\n\t\"query\":{\r\n\t\t\"match\":{\r\n\t\t\t\"category\" : \"小华\"\r\n\t\t}\r\n\t}\r\n}\r\n\r\n```\r\n\r\n返回结果如下：\r\n\r\n```json\r\n{\r\n    \"took\": 7,\r\n    \"timed_out\": false,\r\n    \"_shards\": {\r\n        \"total\": 1,\r\n        \"successful\": 1,\r\n        \"skipped\": 0,\r\n        \"failed\": 0\r\n    },\r\n    \"hits\": {\r\n        \"total\": {\r\n            \"value\": 6,\r\n            \"relation\": \"eq\"\r\n        },\r\n        \"max_score\": 0.6931471,\r\n        \"hits\": [\r\n            {\r\n                \"_index\": \"shopping\",\r\n                \"_type\": \"_doc\",\r\n                \"_id\": \"ANQqsHgBaKNfVnMbhZYU\",\r\n                \"_score\": 0.6931471,\r\n                \"_source\": {\r\n                    \"title\": \"小米手机\",\r\n                    \"category\": \"小米\",\r\n                    \"images\": \"http://www.gulixueyuan.com/xm.jpg\",\r\n                    \"price\": 3999\r\n                }\r\n            },\r\n            {\r\n                \"_index\": \"shopping\",\r\n                \"_type\": \"_doc\",\r\n                \"_id\": \"A9R5sHgBaKNfVnMb25Ya\",\r\n                \"_score\": 0.6931471,\r\n                \"_source\": {\r\n                    \"title\": \"小米手机\",\r\n                    \"category\": \"小米\",\r\n                    \"images\": \"http://www.gulixueyuan.com/xm.jpg\",\r\n                    \"price\": 1999\r\n                }\r\n            },\r\n            {\r\n                \"_index\": \"shopping\",\r\n                \"_type\": \"_doc\",\r\n                \"_id\": \"BNR5sHgBaKNfVnMb7pal\",\r\n                \"_score\": 0.6931471,\r\n                \"_source\": {\r\n                    \"title\": \"小米手机\",\r\n                    \"category\": \"小米\",\r\n                    \"images\": \"http://www.gulixueyuan.com/xm.jpg\",\r\n                    \"price\": 1999\r\n                }\r\n            },\r\n            {\r\n                \"_index\": \"shopping\",\r\n                \"_type\": \"_doc\",\r\n                \"_id\": \"BtR6sHgBaKNfVnMbX5Y5\",\r\n                \"_score\": 0.6931471,\r\n                \"_source\": {\r\n                    \"title\": \"华为手机\",\r\n                    \"category\": \"华为\",\r\n                    \"images\": \"http://www.gulixueyuan.com/xm.jpg\",\r\n                    \"price\": 1999\r\n                }\r\n            },\r\n            {\r\n                \"_index\": \"shopping\",\r\n                \"_type\": \"_doc\",\r\n                \"_id\": \"B9R6sHgBaKNfVnMbZpZ6\",\r\n                \"_score\": 0.6931471,\r\n                \"_source\": {\r\n                    \"title\": \"华为手机\",\r\n                    \"category\": \"华为\",\r\n                    \"images\": \"http://www.gulixueyuan.com/xm.jpg\",\r\n                    \"price\": 1999\r\n                }\r\n            },\r\n            {\r\n                \"_index\": \"shopping\",\r\n                \"_type\": \"_doc\",\r\n                \"_id\": \"CdR7sHgBaKNfVnMbsJb9\",\r\n                \"_score\": 0.6931471,\r\n                \"_source\": {\r\n                    \"title\": \"华为手机\",\r\n                    \"category\": \"华为\",\r\n                    \"images\": \"http://www.gulixueyuan.com/xm.jpg\",\r\n                    \"price\": 1999\r\n                }\r\n            }\r\n        ]\r\n    }\r\n}\r\n\r\n```\r\n\r\n### 完全匹配\r\n\r\n在Postman中，向ES服务器发GET请求：http://127.0.0.1:9200/shopping/_search，附带JSON体如下：\r\n\r\n```json\r\n{\r\n\t\"query\":{\r\n\t\t\"match_phrase\":{\r\n\t\t\t\"category\" : \"为\"\r\n\t\t}\r\n\t}\r\n}\r\n\r\n```\r\n\r\n返回结果如下：\r\n\r\n```json\r\n{\r\n    \"took\": 2,\r\n    \"timed_out\": false,\r\n    \"_shards\": {\r\n        \"total\": 1,\r\n        \"successful\": 1,\r\n        \"skipped\": 0,\r\n        \"failed\": 0\r\n    },\r\n    \"hits\": {\r\n        \"total\": {\r\n            \"value\": 3,\r\n            \"relation\": \"eq\"\r\n        },\r\n        \"max_score\": 0.6931471,\r\n        \"hits\": [\r\n            {\r\n                \"_index\": \"shopping\",\r\n                \"_type\": \"_doc\",\r\n                \"_id\": \"BtR6sHgBaKNfVnMbX5Y5\",\r\n                \"_score\": 0.6931471,\r\n                \"_source\": {\r\n                    \"title\": \"华为手机\",\r\n                    \"category\": \"华为\",\r\n                    \"images\": \"http://www.gulixueyuan.com/xm.jpg\",\r\n                    \"price\": 1999\r\n                }\r\n            },\r\n            {\r\n                \"_index\": \"shopping\",\r\n                \"_type\": \"_doc\",\r\n                \"_id\": \"B9R6sHgBaKNfVnMbZpZ6\",\r\n                \"_score\": 0.6931471,\r\n                \"_source\": {\r\n                    \"title\": \"华为手机\",\r\n                    \"category\": \"华为\",\r\n                    \"images\": \"http://www.gulixueyuan.com/xm.jpg\",\r\n                    \"price\": 1999\r\n                }\r\n            },\r\n            {\r\n                \"_index\": \"shopping\",\r\n                \"_type\": \"_doc\",\r\n                \"_id\": \"CdR7sHgBaKNfVnMbsJb9\",\r\n                \"_score\": 0.6931471,\r\n                \"_source\": {\r\n                    \"title\": \"华为手机\",\r\n                    \"category\": \"华为\",\r\n                    \"images\": \"http://www.gulixueyuan.com/xm.jpg\",\r\n                    \"price\": 1999\r\n                }\r\n            }\r\n        ]\r\n    }\r\n}\r\n\r\n```\r\n\r\n### 高亮查询\r\n\r\n在Postman中，向ES服务器发GET请求：http://127.0.0.1:9200/shopping/_search，附带JSON体如下：\r\n\r\n```json\r\n{\r\n\t\"query\":{\r\n\t\t\"match_phrase\":{\r\n\t\t\t\"category\" : \"为\"\r\n\t\t}\r\n\t},\r\n    \"highlight\":{\r\n        \"fields\":{\r\n            \"category\":{}//<----高亮这字段\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\n返回结果如下：\r\n\r\n```json\r\n{\r\n    \"took\": 100,\r\n    \"timed_out\": false,\r\n    \"_shards\": {\r\n        \"total\": 1,\r\n        \"successful\": 1,\r\n        \"skipped\": 0,\r\n        \"failed\": 0\r\n    },\r\n    \"hits\": {\r\n        \"total\": {\r\n            \"value\": 3,\r\n            \"relation\": \"eq\"\r\n        },\r\n        \"max_score\": 0.6931471,\r\n        \"hits\": [\r\n            {\r\n                \"_index\": \"shopping\",\r\n                \"_type\": \"_doc\",\r\n                \"_id\": \"BtR6sHgBaKNfVnMbX5Y5\",\r\n                \"_score\": 0.6931471,\r\n                \"_source\": {\r\n                    \"title\": \"华为手机\",\r\n                    \"category\": \"华为\",\r\n                    \"images\": \"http://www.gulixueyuan.com/xm.jpg\",\r\n                    \"price\": 1999\r\n                },\r\n                \"highlight\": {\r\n                    \"category\": [\r\n                        \"华<em>为</em>\"//<------高亮一个为字。\r\n                    ]\r\n                }\r\n            },\r\n            {\r\n                \"_index\": \"shopping\",\r\n                \"_type\": \"_doc\",\r\n                \"_id\": \"B9R6sHgBaKNfVnMbZpZ6\",\r\n                \"_score\": 0.6931471,\r\n                \"_source\": {\r\n                    \"title\": \"华为手机\",\r\n                    \"category\": \"华为\",\r\n                    \"images\": \"http://www.gulixueyuan.com/xm.jpg\",\r\n                    \"price\": 1999\r\n                },\r\n                \"highlight\": {\r\n                    \"category\": [\r\n                        \"华<em>为</em>\"\r\n                    ]\r\n                }\r\n            },\r\n            {\r\n                \"_index\": \"shopping\",\r\n                \"_type\": \"_doc\",\r\n                \"_id\": \"CdR7sHgBaKNfVnMbsJb9\",\r\n                \"_score\": 0.6931471,\r\n                \"_source\": {\r\n                    \"title\": \"华为手机\",\r\n                    \"category\": \"华为\",\r\n                    \"images\": \"http://www.gulixueyuan.com/xm.jpg\",\r\n                    \"price\": 1999\r\n                },\r\n                \"highlight\": {\r\n                    \"category\": [\r\n                        \"华<em>为</em>\"\r\n                    ]\r\n                }\r\n            }\r\n        ]\r\n    }\r\n}\r\n\r\n```\r\n\r\n## 16-入门-HTTP-聚合查询\r\n\r\n聚合允许使用者对es文档进行统计分析，类似与关系型数据库中的groupby，当然还有很多其他的聚合，例如取最大值max、平均值avg等等。\r\n\r\n接下来按price字段进行分组：\r\n\r\n在Postman中，向ES服务器发GET请求：http://127.0.0.1:9200/shopping/_search，附带JSON体如下：\r\n\r\n```json\r\n{\r\n\t\"aggs\":{//聚合操作\r\n\t\t\"price_group\":{//名称，随意起名\r\n\t\t\t\"terms\":{//分组\r\n\t\t\t\t\"field\":\"price\"//分组字段\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n```\r\n\r\n返回结果如下：\r\n\r\n```json\r\n{\r\n    \"took\": 63,\r\n    \"timed_out\": false,\r\n    \"_shards\": {\r\n        \"total\": 1,\r\n        \"successful\": 1,\r\n        \"skipped\": 0,\r\n        \"failed\": 0\r\n    },\r\n    \"hits\": {\r\n        \"total\": {\r\n            \"value\": 6,\r\n            \"relation\": \"eq\"\r\n        },\r\n        \"max_score\": 1,\r\n        \"hits\": [\r\n            {\r\n                \"_index\": \"shopping\",\r\n                \"_type\": \"_doc\",\r\n                \"_id\": \"ANQqsHgBaKNfVnMbhZYU\",\r\n                \"_score\": 1,\r\n                \"_source\": {\r\n                    \"title\": \"小米手机\",\r\n                    \"category\": \"小米\",\r\n                    \"images\": \"http://www.gulixueyuan.com/xm.jpg\",\r\n                    \"price\": 3999\r\n                }\r\n            },\r\n            {\r\n                \"_index\": \"shopping\",\r\n                \"_type\": \"_doc\",\r\n                \"_id\": \"A9R5sHgBaKNfVnMb25Ya\",\r\n                \"_score\": 1,\r\n                \"_source\": {\r\n                    \"title\": \"小米手机\",\r\n                    \"category\": \"小米\",\r\n                    \"images\": \"http://www.gulixueyuan.com/xm.jpg\",\r\n                    \"price\": 1999\r\n                }\r\n            },\r\n            {\r\n                \"_index\": \"shopping\",\r\n                \"_type\": \"_doc\",\r\n                \"_id\": \"BNR5sHgBaKNfVnMb7pal\",\r\n                \"_score\": 1,\r\n                \"_source\": {\r\n                    \"title\": \"小米手机\",\r\n                    \"category\": \"小米\",\r\n                    \"images\": \"http://www.gulixueyuan.com/xm.jpg\",\r\n                    \"price\": 1999\r\n                }\r\n            },\r\n            {\r\n                \"_index\": \"shopping\",\r\n                \"_type\": \"_doc\",\r\n                \"_id\": \"BtR6sHgBaKNfVnMbX5Y5\",\r\n                \"_score\": 1,\r\n                \"_source\": {\r\n                    \"title\": \"华为手机\",\r\n                    \"category\": \"华为\",\r\n                    \"images\": \"http://www.gulixueyuan.com/xm.jpg\",\r\n                    \"price\": 1999\r\n                }\r\n            },\r\n            {\r\n                \"_index\": \"shopping\",\r\n                \"_type\": \"_doc\",\r\n                \"_id\": \"B9R6sHgBaKNfVnMbZpZ6\",\r\n                \"_score\": 1,\r\n                \"_source\": {\r\n                    \"title\": \"华为手机\",\r\n                    \"category\": \"华为\",\r\n                    \"images\": \"http://www.gulixueyuan.com/xm.jpg\",\r\n                    \"price\": 1999\r\n                }\r\n            },\r\n            {\r\n                \"_index\": \"shopping\",\r\n                \"_type\": \"_doc\",\r\n                \"_id\": \"CdR7sHgBaKNfVnMbsJb9\",\r\n                \"_score\": 1,\r\n                \"_source\": {\r\n                    \"title\": \"华为手机\",\r\n                    \"category\": \"华为\",\r\n                    \"images\": \"http://www.gulixueyuan.com/xm.jpg\",\r\n                    \"price\": 1999\r\n                }\r\n            }\r\n        ]\r\n    },\r\n    \"aggregations\": {\r\n        \"price_group\": {\r\n            \"doc_count_error_upper_bound\": 0,\r\n            \"sum_other_doc_count\": 0,\r\n            \"buckets\": [\r\n                {\r\n                    \"key\": 1999,\r\n                    \"doc_count\": 5\r\n                },\r\n                {\r\n                    \"key\": 3999,\r\n                    \"doc_count\": 1\r\n                }\r\n            ]\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\n上面返回结果会附带原始数据的。若不想要不附带原始数据的结果，在Postman中，向ES服务器发GET请求：http://127.0.0.1:9200/shopping/_search 附带JSON体如下：\r\n\r\n```json\r\n{\r\n\t\"aggs\":{\r\n\t\t\"price_group\":{\r\n\t\t\t\"terms\":{\r\n\t\t\t\t\"field\":\"price\"\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n    \"size\":0\r\n}\r\n\r\n```\r\n\r\n返回结果如下：\r\n\r\n```json\r\n{\r\n    \"took\": 60,\r\n    \"timed_out\": false,\r\n    \"_shards\": {\r\n        \"total\": 1,\r\n        \"successful\": 1,\r\n        \"skipped\": 0,\r\n        \"failed\": 0\r\n    },\r\n    \"hits\": {\r\n        \"total\": {\r\n            \"value\": 6,\r\n            \"relation\": \"eq\"\r\n        },\r\n        \"max_score\": null,\r\n        \"hits\": []\r\n    },\r\n    \"aggregations\": {\r\n        \"price_group\": {\r\n            \"doc_count_error_upper_bound\": 0,\r\n            \"sum_other_doc_count\": 0,\r\n            \"buckets\": [\r\n                {\r\n                    \"key\": 1999,\r\n                    \"doc_count\": 5\r\n                },\r\n                {\r\n                    \"key\": 3999,\r\n                    \"doc_count\": 1\r\n                }\r\n            ]\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\n若想对所有手机价格求**平均值**。\r\n\r\n在Postman中，向ES服务器发GET请求：http://127.0.0.1:9200/shopping/_search，附带JSON体如下：\r\n\r\n```json\r\n{\r\n\t\"aggs\":{\r\n\t\t\"price_avg\":{//名称，随意起名\r\n\t\t\t\"avg\":{//求平均\r\n\t\t\t\t\"field\":\"price\"\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n    \"size\":0\r\n}\r\n\r\n```\r\n\r\n返回结果如下：\r\n\r\n```json\r\n{\r\n    \"took\": 14,\r\n    \"timed_out\": false,\r\n    \"_shards\": {\r\n        \"total\": 1,\r\n        \"successful\": 1,\r\n        \"skipped\": 0,\r\n        \"failed\": 0\r\n    },\r\n    \"hits\": {\r\n        \"total\": {\r\n            \"value\": 6,\r\n            \"relation\": \"eq\"\r\n        },\r\n        \"max_score\": null,\r\n        \"hits\": []\r\n    },\r\n    \"aggregations\": {\r\n        \"price_avg\": {\r\n            \"value\": 2332.3333333333335\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\n## 17-入门-HTTP-映射关系\r\n\r\n有了索引库，等于有了数据库中的database。\r\n\r\n接下来就需要建索引库(index)中的映射了，类似于数据库(database)中的表结构(table)。\r\n\r\n创建数据库表需要设置字段名称，类型，长度，约束等；索引库也一样，需要知道这个类型下有哪些字段，每个字段有哪些约束信息，这就叫做映射(mapping)。\r\n\r\n先创建一个索引：\r\n\r\n```json\r\n# PUT http://127.0.0.1:9200/user\r\n\r\n```\r\n\r\n返回结果：\r\n\r\n```json\r\n{\r\n    \"acknowledged\": true,\r\n    \"shards_acknowledged\": true,\r\n    \"index\": \"user\"\r\n}\r\n\r\n```\r\n\r\n**创建映射**\r\n\r\n```json\r\n# PUT http://127.0.0.1:9200/user/_mapping\r\n\r\n{\r\n    \"properties\": {\r\n        \"name\":{\r\n        \t\"type\": \"text\",\r\n        \t\"index\": true\r\n        },\r\n        \"sex\":{\r\n        \t\"type\": \"keyword\",\r\n        \t\"index\": true\r\n        },\r\n        \"tel\":{\r\n        \t\"type\": \"keyword\",\r\n        \t\"index\": false\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\n返回结果如下：\r\n\r\n```json\r\n{\r\n    \"acknowledged\": true\r\n}\r\n\r\n```\r\n\r\n**查询映射**\r\n\r\n```json\r\n#GET http://127.0.0.1:9200/user/_mapping\r\n\r\n```\r\n\r\n返回结果如下：\r\n\r\n```json\r\n{\r\n    \"user\": {\r\n        \"mappings\": {\r\n            \"properties\": {\r\n                \"name\": {\r\n                    \"type\": \"text\"\r\n                },\r\n                \"sex\": {\r\n                    \"type\": \"keyword\"\r\n                },\r\n                \"tel\": {\r\n                    \"type\": \"keyword\",\r\n                    \"index\": false\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\n增加数据\r\n\r\n```json\r\n#PUT http://127.0.0.1:9200/user/_create/1001\r\n{\r\n\t\"name\":\"小米\",\r\n\t\"sex\":\"男的\",\r\n\t\"tel\":\"1111\"\r\n}\r\n\r\n```\r\n\r\n返回结果如下：\r\n\r\n```json\r\n{\r\n    \"_index\": \"user\",\r\n    \"_type\": \"_doc\",\r\n    \"_id\": \"1001\",\r\n    \"_version\": 1,\r\n    \"result\": \"created\",\r\n    \"_shards\": {\r\n        \"total\": 2,\r\n        \"successful\": 1,\r\n        \"failed\": 0\r\n    },\r\n    \"_seq_no\": 0,\r\n    \"_primary_term\": 1\r\n}\r\n\r\n```\r\n\r\n查找name含有”小“数据：\r\n\r\n```json\r\n#GET http://127.0.0.1:9200/user/_search\r\n{\r\n\t\"query\":{\r\n\t\t\"match\":{\r\n\t\t\t\"name\":\"小\"\r\n\t\t}\r\n\t}\r\n}\r\n\r\n```\r\n\r\n返回结果如下：\r\n\r\n```json\r\n{\r\n    \"took\": 495,\r\n    \"timed_out\": false,\r\n    \"_shards\": {\r\n        \"total\": 1,\r\n        \"successful\": 1,\r\n        \"skipped\": 0,\r\n        \"failed\": 0\r\n    },\r\n    \"hits\": {\r\n        \"total\": {\r\n            \"value\": 1,\r\n            \"relation\": \"eq\"\r\n        },\r\n        \"max_score\": 0.2876821,\r\n        \"hits\": [\r\n            {\r\n                \"_index\": \"user\",\r\n                \"_type\": \"_doc\",\r\n                \"_id\": \"1001\",\r\n                \"_score\": 0.2876821,\r\n                \"_source\": {\r\n                    \"name\": \"小米\",\r\n                    \"sex\": \"男的\",\r\n                    \"tel\": \"1111\"\r\n                }\r\n            }\r\n        ]\r\n    }\r\n}\r\n\r\n```\r\n\r\n查找sex含有”男“数据：\r\n\r\n```json\r\n#GET http://127.0.0.1:9200/user/_search\r\n{\r\n\t\"query\":{\r\n\t\t\"match\":{\r\n\t\t\t\"sex\":\"男\"\r\n\t\t}\r\n\t}\r\n}\r\n\r\n```\r\n\r\n返回结果如下：\r\n\r\n```json\r\n{\r\n    \"took\": 1,\r\n    \"timed_out\": false,\r\n    \"_shards\": {\r\n        \"total\": 1,\r\n        \"successful\": 1,\r\n        \"skipped\": 0,\r\n        \"failed\": 0\r\n    },\r\n    \"hits\": {\r\n        \"total\": {\r\n            \"value\": 0,\r\n            \"relation\": \"eq\"\r\n        },\r\n        \"max_score\": null,\r\n        \"hits\": []\r\n    }\r\n}\r\n\r\n```\r\n\r\n找不想要的结果，只因创建映射时\"sex\"的类型为\"keyword\"。\r\n\r\n\"sex\"只能完全为”男的“，才能得出原数据。\r\n\r\n```json\r\n#GET http://127.0.0.1:9200/user/_search\r\n{\r\n\t\"query\":{\r\n\t\t\"match\":{\r\n\t\t\t\"sex\":\"男的\"\r\n\t\t}\r\n\t}\r\n}\r\n\r\n```\r\n\r\n返回结果如下：\r\n\r\n```json\r\n{\r\n    \"took\": 2,\r\n    \"timed_out\": false,\r\n    \"_shards\": {\r\n        \"total\": 1,\r\n        \"successful\": 1,\r\n        \"skipped\": 0,\r\n        \"failed\": 0\r\n    },\r\n    \"hits\": {\r\n        \"total\": {\r\n            \"value\": 1,\r\n            \"relation\": \"eq\"\r\n        },\r\n        \"max_score\": 0.2876821,\r\n        \"hits\": [\r\n            {\r\n                \"_index\": \"user\",\r\n                \"_type\": \"_doc\",\r\n                \"_id\": \"1001\",\r\n                \"_score\": 0.2876821,\r\n                \"_source\": {\r\n                    \"name\": \"小米\",\r\n                    \"sex\": \"男的\",\r\n                    \"tel\": \"1111\"\r\n                }\r\n            }\r\n        ]\r\n    }\r\n}\r\n\r\n```\r\n\r\n查询电话\r\n\r\n```json\r\n# GET http://127.0.0.1:9200/user/_search\r\n{\r\n\t\"query\":{\r\n\t\t\"match\":{\r\n\t\t\t\"tel\":\"11\"\r\n\t\t}\r\n\t}\r\n}\r\n\r\n```\r\n\r\n返回结果如下：\r\n\r\n```json\r\n{\r\n    \"error\": {\r\n        \"root_cause\": [\r\n            {\r\n                \"type\": \"query_shard_exception\",\r\n                \"reason\": \"failed to create query: Cannot search on field [tel] since it is not indexed.\",\r\n                \"index_uuid\": \"ivLnMfQKROS7Skb2MTFOew\",\r\n                \"index\": \"user\"\r\n            }\r\n        ],\r\n        \"type\": \"search_phase_execution_exception\",\r\n        \"reason\": \"all shards failed\",\r\n        \"phase\": \"query\",\r\n        \"grouped\": true,\r\n        \"failed_shards\": [\r\n            {\r\n                \"shard\": 0,\r\n                \"index\": \"user\",\r\n                \"node\": \"4P7dIRfXSbezE5JTiuylew\",\r\n                \"reason\": {\r\n                    \"type\": \"query_shard_exception\",\r\n                    \"reason\": \"failed to create query: Cannot search on field [tel] since it is not indexed.\",\r\n                    \"index_uuid\": \"ivLnMfQKROS7Skb2MTFOew\",\r\n                    \"index\": \"user\",\r\n                    \"caused_by\": {\r\n                        \"type\": \"illegal_argument_exception\",\r\n                        \"reason\": \"Cannot search on field [tel] since it is not indexed.\"\r\n                    }\r\n                }\r\n            }\r\n        ]\r\n    },\r\n    \"status\": 400\r\n}\r\n\r\n```\r\n\r\n报错只因创建映射时\"tel\"的\"index\"为false。\r\n\r\n## 18-入门-JavaAPI-环境准备\r\n\r\n新建Maven工程。\r\n\r\n添加依赖：\r\n\r\n```xml\r\n<dependencies>\r\n    <dependency>\r\n        <groupId>org.elasticsearch</groupId>\r\n        <artifactId>elasticsearch</artifactId>\r\n        <version>7.8.0</version>\r\n    </dependency>\r\n    <!-- elasticsearch的客户端-->\r\n    <dependency>\r\n        <groupId>org.elasticsearch.client</groupId>\r\n        <artifactId>elasticsearch-rest-high-level-client</artifactId>\r\n        <version>7.8.0</version>\r\n    </dependency>\r\n    <!-- elasticsearch依赖2.x的log4j-->\r\n    <dependency>\r\n        <groupId>org.apache.logging.log4j</groupId>\r\n        <artifactId>log4j-api</artifactId>\r\n        <version>2.8.2</version>\r\n    </dependency>\r\n    <dependency>\r\n        <groupId>org.apache.logging.log4j</groupId>\r\n        <artifactId>log4j-core</artifactId>\r\n        <version>2.8.2</version>\r\n    </dependency>\r\n    <dependency>\r\n        <groupId>com.fasterxml.jackson.core</groupId>\r\n        <artifactId>jackson-databind</artifactId>\r\n        <version>2.9.9</version>\r\n    </dependency>\r\n    <!-- junit单元测试 -->\r\n    <dependency>\r\n        <groupId>junit</groupId>\r\n        <artifactId>junit</artifactId>\r\n        <version>4.12</version>\r\n    </dependency>\r\n</dependencies>\r\n\r\n```\r\n\r\nHelloElasticsearch\r\n\r\n```java\r\nimport java.io.IOException;\r\n\r\nimport org.apache.http.HttpHost;\r\nimport org.elasticsearch.client.RestClient;\r\nimport org.elasticsearch.client.RestHighLevelClient;\r\n\r\npublic class HelloElasticsearch {\r\n\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\t// 创建客户端对象\r\n\t\tRestHighLevelClient client = new RestHighLevelClient(\r\n\t\t\t\tRestClient.builder(new HttpHost(\"localhost\", 9200, \"http\")));\r\n//\t\t...\r\n\t\tSystem.out.println(client);\r\n\r\n\t\t// 关闭客户端连接\r\n\t\tclient.close();\r\n\t}\r\n}\r\n\r\n```\r\n\r\n## 19-入门-JavaAPI-索引-创建\r\n\r\n```java\r\nimport org.apache.http.HttpHost;\r\nimport org.elasticsearch.action.admin.indices.create.CreateIndexRequest;\r\nimport org.elasticsearch.action.admin.indices.create.CreateIndexResponse;\r\nimport org.elasticsearch.client.RequestOptions;\r\nimport org.elasticsearch.client.RestClient;\r\nimport org.elasticsearch.client.RestHighLevelClient;\r\n\r\nimport java.io.IOException;\r\n\r\npublic class CreateIndex {\r\n\r\n    public static void main(String[] args) throws IOException {\r\n        // 创建客户端对象\r\n        RestHighLevelClient client = new RestHighLevelClient(\r\n                RestClient.builder(new HttpHost(\"localhost\", 9200, \"http\")));\r\n\r\n        // 创建索引 - 请求对象\r\n        CreateIndexRequest request = new CreateIndexRequest(\"user2\");\r\n        // 发送请求，获取响应\r\n        CreateIndexResponse response = client.indices().create(request,\r\n                RequestOptions.DEFAULT);\r\n        boolean acknowledged = response.isAcknowledged();\r\n        // 响应状态\r\n        System.out.println(\"操作状态 = \" + acknowledged);\r\n\r\n        // 关闭客户端连接\r\n        client.close();\r\n    }\r\n\r\n}\r\n\r\n```\r\n\r\n后台打印：\r\n\r\n```\\\r\n四月 09, 2021 2:12:08 下午 org.elasticsearch.client.RestClient logResponse\r\n警告: request [PUT http://localhost:9200/user2?master_timeout=30s&include_type_name=true&timeout=30s] returned 1 warnings: [299 Elasticsearch-7.8.0-757314695644ea9a1dc2fecd26d1a43856725e65 \"[types removal] Using include_type_name in create index requests is deprecated. The parameter will be removed in the next major version.\"]\r\n操作状态 = true\r\n\r\nProcess finished with exit code 0\r\n\r\n```\r\n\r\n## 20-入门-JavaAPI-索引-查询 & 删除\r\n\r\n### 查询\r\n\r\n```java\r\nimport org.apache.http.HttpHost;\r\n\r\nimport org.elasticsearch.client.RequestOptions;\r\nimport org.elasticsearch.client.RestClient;\r\nimport org.elasticsearch.client.RestHighLevelClient;\r\nimport org.elasticsearch.client.indices.GetIndexRequest;\r\nimport org.elasticsearch.client.indices.GetIndexResponse;\r\n\r\nimport java.io.IOException;\r\n\r\npublic class SearchIndex {\r\n    public static void main(String[] args) throws IOException {\r\n        // 创建客户端对象\r\n        RestHighLevelClient client = new RestHighLevelClient(\r\n                RestClient.builder(new HttpHost(\"localhost\", 9200, \"http\")));\r\n\r\n        // 查询索引 - 请求对象\r\n        GetIndexRequest request = new GetIndexRequest(\"user2\");\r\n        // 发送请求，获取响应\r\n        GetIndexResponse response = client.indices().get(request,\r\n                RequestOptions.DEFAULT);\r\n        \r\n        System.out.println(\"aliases:\"+response.getAliases());\r\n        System.out.println(\"mappings:\"+response.getMappings());\r\n        System.out.println(\"settings:\"+response.getSettings());\r\n\r\n        client.close();\r\n    }\r\n}\r\n\r\n```\r\n\r\n后台打印：\r\n\r\n```\r\naliases:{user2=[]}\r\nmappings:{user2=org.elasticsearch.cluster.metadata.MappingMetadata@ad700514}\r\nsettings:{user2={\"index.creation_date\":\"1617948726976\",\"index.number_of_replicas\":\"1\",\"index.number_of_shards\":\"1\",\"index.provided_name\":\"user2\",\"index.uuid\":\"UGZ1ntcySnK6hWyP2qoVpQ\",\"index.version.created\":\"7080099\"}}\r\n\r\nProcess finished with exit code 0\r\n\r\n```\r\n\r\n### 删除\r\n\r\n```java\r\nimport org.apache.http.HttpHost;\r\nimport org.elasticsearch.action.admin.indices.delete.DeleteIndexRequest;\r\nimport org.elasticsearch.action.support.master.AcknowledgedResponse;\r\nimport org.elasticsearch.client.RequestOptions;\r\nimport org.elasticsearch.client.RestClient;\r\nimport org.elasticsearch.client.RestHighLevelClient;\r\n\r\nimport java.io.IOException;\r\n\r\npublic class DeleteIndex {\r\n    public static void main(String[] args) throws IOException {\r\n        RestHighLevelClient client = new RestHighLevelClient(\r\n                RestClient.builder(new HttpHost(\"localhost\", 9200, \"http\")));\r\n        // 删除索引 - 请求对象\r\n        DeleteIndexRequest request = new DeleteIndexRequest(\"user2\");\r\n        // 发送请求，获取响应\r\n        AcknowledgedResponse response = client.indices().delete(request,RequestOptions.DEFAULT);\r\n        // 操作结果\r\n        System.out.println(\"操作结果 ： \" + response.isAcknowledged());\r\n        client.close();\r\n    }\r\n}\r\n\r\n```\r\n\r\n后台打印：\r\n\r\n```\r\n操作结果：true\r\n\r\nProcess finished with exit code 0\r\n\r\n```\r\n\r\n## 21-入门-JavaAPI-文档-新增 & 修改\r\n\r\n### 重构\r\n\r\n上文由于频繁使用以下连接Elasticsearch和关闭它的代码，于是**个人**对它进行重构。\r\n\r\n```java\r\npublic class SomeClass {\r\n    public static void main(String[] args) throws IOException {\r\n        RestHighLevelClient client = new RestHighLevelClient(\r\n                RestClient.builder(new HttpHost(\"localhost\", 9200, \"http\")));\r\n\t\t\r\n        ...\r\n        \r\n        client.close();\r\n    }\r\n}\r\n\r\n```\r\n\r\n重构后的代码：\r\n\r\n```java\r\nimport org.elasticsearch.client.RestHighLevelClient;\r\n\r\npublic interface ElasticsearchTask {\r\n\r\n    void doSomething(RestHighLevelClient client) throws Exception;\r\n\r\n}\r\n\r\npublic class ConnectElasticsearch{\r\n\r\n    public static void connect(ElasticsearchTask task){\r\n        // 创建客户端对象\r\n        RestHighLevelClient client = new RestHighLevelClient(\r\n                RestClient.builder(new HttpHost(\"localhost\", 9200, \"http\")));\r\n        try {\r\n            task.doSomething(client);\r\n            // 关闭客户端连接\r\n            client.close();\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\n接下来，如果想让Elasticsearch完成一些操作，就编写一个lambda式即可。\r\n\r\n```java\r\npublic class SomeClass {\r\n\r\n    public static void main(String[] args) {\r\n        ConnectElasticsearch.connect(client -> {\r\n\t\t\t//do something\r\n        });\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n### 新增\r\n\r\n```java\r\nimport com.fasterxml.jackson.databind.ObjectMapper;\r\nimport com.lun.elasticsearch.hello.ConnectElasticsearch;\r\nimport com.lun.elasticsearch.model.User;\r\nimport org.elasticsearch.action.index.IndexRequest;\r\nimport org.elasticsearch.action.index.IndexResponse;\r\nimport org.elasticsearch.client.RequestOptions;\r\nimport org.elasticsearch.common.xcontent.XContentType;\r\n\r\npublic class InsertDoc {\r\n\r\n    public static void main(String[] args) {\r\n        ConnectElasticsearch.connect(client -> {\r\n            // 新增文档 - 请求对象\r\n            IndexRequest request = new IndexRequest();\r\n            // 设置索引及唯一性标识\r\n            request.index(\"user\").id(\"1001\");\r\n\r\n            // 创建数据对象\r\n            User user = new User();\r\n            user.setName(\"zhangsan\");\r\n            user.setAge(30);\r\n            user.setSex(\"男\");\r\n\r\n            ObjectMapper objectMapper = new ObjectMapper();\r\n            String productJson = objectMapper.writeValueAsString(user);\r\n            // 添加文档数据，数据格式为 JSON 格式\r\n            request.source(productJson, XContentType.JSON);\r\n            // 客户端发送请求，获取响应对象\r\n            IndexResponse response = client.index(request, RequestOptions.DEFAULT);\r\n            3.打印结果信息\r\n            System.out.println(\"_index:\" + response.getIndex());\r\n            System.out.println(\"_id:\" + response.getId());\r\n            System.out.println(\"_result:\" + response.getResult());\r\n        });\r\n    }\r\n}\r\n\r\n```\r\n\r\n后台打印：\r\n\r\n```\r\n_index:user\r\n_id:1001\r\n_result:UPDATED\r\n\r\nProcess finished with exit code 0\r\n\r\n```\r\n\r\n### 修改\r\n\r\n```java\r\nimport com.lun.elasticsearch.hello.ConnectElasticsearch;\r\nimport org.elasticsearch.action.update.UpdateRequest;\r\nimport org.elasticsearch.action.update.UpdateResponse;\r\nimport org.elasticsearch.client.RequestOptions;\r\nimport org.elasticsearch.common.xcontent.XContentType;\r\n\r\npublic class UpdateDoc {\r\n\r\n    public static void main(String[] args) {\r\n        ConnectElasticsearch.connect(client -> {\r\n            // 修改文档 - 请求对象\r\n            UpdateRequest request = new UpdateRequest();\r\n            // 配置修改参数\r\n            request.index(\"user\").id(\"1001\");\r\n            // 设置请求体，对数据进行修改\r\n            request.doc(XContentType.JSON, \"sex\", \"女\");\r\n            // 客户端发送请求，获取响应对象\r\n            UpdateResponse response = client.update(request, RequestOptions.DEFAULT);\r\n            System.out.println(\"_index:\" + response.getIndex());\r\n            System.out.println(\"_id:\" + response.getId());\r\n            System.out.println(\"_result:\" + response.getResult());\r\n        });\r\n    }\r\n\r\n}\r\n\r\n```\r\n\r\n后台打印：\r\n\r\n```\r\n_index:user\r\n_id:1001\r\n_result:UPDATED\r\n\r\nProcess finished with exit code 0\r\n\r\n```\r\n\r\n## 22-入门-JavaAPI-文档-查询 & 删除\r\n\r\n### 查询\r\n\r\n```java\r\nimport com.lun.elasticsearch.hello.ConnectElasticsearch;\r\nimport org.elasticsearch.action.get.GetRequest;\r\nimport org.elasticsearch.action.get.GetResponse;\r\nimport org.elasticsearch.client.RequestOptions;\r\n\r\npublic class GetDoc {\r\n\r\n    public static void main(String[] args) {\r\n        ConnectElasticsearch.connect(client -> {\r\n            //1.创建请求对象\r\n            GetRequest request = new GetRequest().index(\"user\").id(\"1001\");\r\n            //2.客户端发送请求，获取响应对象\r\n            GetResponse response = client.get(request, RequestOptions.DEFAULT);\r\n            3.打印结果信息\r\n            System.out.println(\"_index:\" + response.getIndex());\r\n            System.out.println(\"_type:\" + response.getType());\r\n            System.out.println(\"_id:\" + response.getId());\r\n            System.out.println(\"source:\" + response.getSourceAsString());\r\n        });\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n后台打印：\r\n\r\n```\r\n_index:user\r\n_type:_doc\r\n_id:1001\r\nsource:{\"name\":\"zhangsan\",\"age\":30,\"sex\":\"男\"}\r\n\r\nProcess finished with exit code 0\r\n\r\n```\r\n\r\n### 删除\r\n\r\n```java\r\nimport com.lun.elasticsearch.hello.ConnectElasticsearch;\r\nimport org.elasticsearch.action.delete.DeleteRequest;\r\nimport org.elasticsearch.action.delete.DeleteResponse;\r\nimport org.elasticsearch.client.RequestOptions;\r\n\r\npublic class DeleteDoc {\r\n    public static void main(String[] args) {\r\n        ConnectElasticsearch.connect(client -> {\r\n            //创建请求对象\r\n            DeleteRequest request = new DeleteRequest().index(\"user\").id(\"1001\");\r\n            //客户端发送请求，获取响应对象\r\n            DeleteResponse response = client.delete(request, RequestOptions.DEFAULT);\r\n            //打印信息\r\n            System.out.println(response.toString());\r\n        });\r\n    }\r\n}\r\n\r\n```\r\n\r\n后台打印：\r\n\r\n```\r\nDeleteResponse[index=user,type=_doc,id=1001,version=16,result=deleted,shards=ShardInfo{total=2, successful=1, failures=[]}]\r\n\r\nProcess finished with exit code 0\r\n\r\n```\r\n\r\n## 23-入门-JavaAPI-文档-批量新增 & 批量删除\r\n\r\n### 批量新增\r\n\r\n```java\r\nimport com.lun.elasticsearch.hello.ConnectElasticsearch;\r\nimport org.elasticsearch.action.bulk.BulkRequest;\r\nimport org.elasticsearch.action.bulk.BulkResponse;\r\nimport org.elasticsearch.action.index.IndexRequest;\r\nimport org.elasticsearch.client.RequestOptions;\r\nimport org.elasticsearch.common.xcontent.XContentType;\r\n\r\npublic class BatchInsertDoc {\r\n\r\n    public static void main(String[] args) {\r\n        ConnectElasticsearch.connect(client -> {\r\n            //创建批量新增请求对象\r\n            BulkRequest request = new BulkRequest();\r\n            request.add(new\r\n                    IndexRequest().index(\"user\").id(\"1001\").source(XContentType.JSON, \"name\",\r\n                    \"zhangsan\"));\r\n            request.add(new\r\n                    IndexRequest().index(\"user\").id(\"1002\").source(XContentType.JSON, \"name\",\r\n                            \"lisi\"));\r\n            request.add(new\r\n                    IndexRequest().index(\"user\").id(\"1003\").source(XContentType.JSON, \"name\",\r\n                    \"wangwu\"));\r\n            //客户端发送请求，获取响应对象\r\n            BulkResponse responses = client.bulk(request, RequestOptions.DEFAULT);\r\n            //打印结果信息\r\n            System.out.println(\"took:\" + responses.getTook());\r\n            System.out.println(\"items:\" + responses.getItems());\r\n        });\r\n    }\r\n}\r\n\r\n```\r\n\r\n后台打印\r\n\r\n```\r\ntook:294ms\r\nitems:[Lorg.elasticsearch.action.bulk.BulkItemResponse;@2beee7ff\r\n\r\nProcess finished with exit code 0\r\n\r\n```\r\n\r\n### 批量删除\r\n\r\n```java\r\nimport com.lun.elasticsearch.hello.ConnectElasticsearch;\r\nimport org.elasticsearch.action.bulk.BulkRequest;\r\nimport org.elasticsearch.action.bulk.BulkResponse;\r\nimport org.elasticsearch.action.delete.DeleteRequest;\r\nimport org.elasticsearch.client.RequestOptions;\r\n\r\npublic class BatchDeleteDoc {\r\n    public static void main(String[] args) {\r\n        ConnectElasticsearch.connect(client -> {\r\n            //创建批量删除请求对象\r\n            BulkRequest request = new BulkRequest();\r\n            request.add(new DeleteRequest().index(\"user\").id(\"1001\"));\r\n            request.add(new DeleteRequest().index(\"user\").id(\"1002\"));\r\n            request.add(new DeleteRequest().index(\"user\").id(\"1003\"));\r\n            //客户端发送请求，获取响应对象\r\n            BulkResponse responses = client.bulk(request, RequestOptions.DEFAULT);\r\n            //打印结果信息\r\n            System.out.println(\"took:\" + responses.getTook());\r\n            System.out.println(\"items:\" + responses.getItems());\r\n        });\r\n    }\r\n}\r\n\r\n```\r\n\r\n后台打印\r\n\r\n```\r\ntook:108ms\r\nitems:[Lorg.elasticsearch.action.bulk.BulkItemResponse;@7b02881e\r\n\r\nProcess finished with exit code 0\r\n\r\n\r\n```\r\n\r\n## 24-入门-JavaAPI-文档-高级查询-全量查询\r\n\r\n先批量增加数据\r\n\r\n```java\r\npublic class BatchInsertDoc {\r\n\r\n    public static void main(String[] args) {\r\n        ConnectElasticsearch.connect(client -> {\r\n            //创建批量新增请求对象\r\n            BulkRequest request = new BulkRequest();\r\n            request.add(new IndexRequest().index(\"user\").id(\"1001\").source(XContentType.JSON, \"name\", \"zhangsan\", \"age\", \"10\", \"sex\",\"女\"));\r\n            request.add(new IndexRequest().index(\"user\").id(\"1002\").source(XContentType.JSON, \"name\", \"lisi\", \"age\", \"30\", \"sex\",\"女\"));\r\n            request.add(new IndexRequest().index(\"user\").id(\"1003\").source(XContentType.JSON, \"name\", \"wangwu1\", \"age\", \"40\", \"sex\",\"男\"));\r\n            request.add(new IndexRequest().index(\"user\").id(\"1004\").source(XContentType.JSON, \"name\", \"wangwu2\", \"age\", \"20\", \"sex\",\"女\"));\r\n            request.add(new IndexRequest().index(\"user\").id(\"1005\").source(XContentType.JSON, \"name\", \"wangwu3\", \"age\", \"50\", \"sex\",\"男\"));\r\n            request.add(new IndexRequest().index(\"user\").id(\"1006\").source(XContentType.JSON, \"name\", \"wangwu4\", \"age\", \"20\", \"sex\",\"男\"));\r\n            //客户端发送请求，获取响应对象\r\n            BulkResponse responses = client.bulk(request, RequestOptions.DEFAULT);\r\n            //打印结果信息\r\n            System.out.println(\"took:\" + responses.getTook());\r\n            System.out.println(\"items:\" + responses.getItems());\r\n        });\r\n    }\r\n}\r\n\r\n```\r\n\r\n后台打印\r\n\r\n```\r\ntook:168ms\r\nitems:[Lorg.elasticsearch.action.bulk.BulkItemResponse;@2beee7ff\r\n\r\nProcess finished with exit code 0\r\n\r\n```\r\n\r\n**查询所有索引数据**\r\n\r\n```java\r\nimport com.lun.elasticsearch.hello.ConnectElasticsearch;\r\nimport org.elasticsearch.action.search.SearchRequest;\r\nimport org.elasticsearch.action.search.SearchResponse;\r\nimport org.elasticsearch.client.RequestOptions;\r\nimport org.elasticsearch.index.query.QueryBuilders;\r\nimport org.elasticsearch.search.SearchHit;\r\nimport org.elasticsearch.search.SearchHits;\r\nimport org.elasticsearch.search.builder.SearchSourceBuilder;\r\n\r\npublic class QueryDoc {\r\n\r\n    public static void main(String[] args) {\r\n        ConnectElasticsearch.connect(client -> {\r\n            // 创建搜索请求对象\r\n            SearchRequest request = new SearchRequest();\r\n            request.indices(\"user\");\r\n            // 构建查询的请求体\r\n            SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();\r\n            // 查询所有数据\r\n            sourceBuilder.query(QueryBuilders.matchAllQuery());\r\n            request.source(sourceBuilder);\r\n            SearchResponse response = client.search(request, RequestOptions.DEFAULT);\r\n            // 查询匹配\r\n            SearchHits hits = response.getHits();\r\n            System.out.println(\"took:\" + response.getTook());\r\n            System.out.println(\"timeout:\" + response.isTimedOut());\r\n            System.out.println(\"total:\" + hits.getTotalHits());\r\n            System.out.println(\"MaxScore:\" + hits.getMaxScore());\r\n            System.out.println(\"hits========>>\");\r\n            for (SearchHit hit : hits) {\r\n            //输出每条查询的结果信息\r\n                System.out.println(hit.getSourceAsString());\r\n            }\r\n            System.out.println(\"<<========\");\r\n        });\r\n    }\r\n\r\n}\r\n\r\n```\r\n\r\n后台打印\r\n\r\n```\r\ntook:2ms\r\ntimeout:false\r\ntotal:6 hits\r\nMaxScore:1.0\r\nhits========>>\r\n{\"name\":\"zhangsan\",\"age\":\"10\",\"sex\":\"女\"}\r\n{\"name\":\"lisi\",\"age\":\"30\",\"sex\":\"女\"}\r\n{\"name\":\"wangwu1\",\"age\":\"40\",\"sex\":\"男\"}\r\n{\"name\":\"wangwu2\",\"age\":\"20\",\"sex\":\"女\"}\r\n{\"name\":\"wangwu3\",\"age\":\"50\",\"sex\":\"男\"}\r\n{\"name\":\"wangwu4\",\"age\":\"20\",\"sex\":\"男\"}\r\n<<========\r\n\r\nProcess finished with exit code 0\r\n\r\n```\r\n\r\n## 25-入门-JavaAPI-文档-高级查询-分页查询 & 条件查询 & 查询排序\r\n\r\n### 条件查询\r\n\r\n```java\r\nimport com.lun.elasticsearch.hello.ConnectElasticsearch;\r\nimport com.lun.elasticsearch.hello.ElasticsearchTask;\r\nimport org.elasticsearch.action.search.SearchRequest;\r\nimport org.elasticsearch.action.search.SearchResponse;\r\nimport org.elasticsearch.client.RequestOptions;\r\nimport org.elasticsearch.index.query.QueryBuilders;\r\nimport org.elasticsearch.search.SearchHit;\r\nimport org.elasticsearch.search.SearchHits;\r\nimport org.elasticsearch.search.builder.SearchSourceBuilder;\r\nimport org.elasticsearch.search.sort.SortOrder;\r\n\r\npublic class QueryDoc {\r\n    \r\n\tpublic static final ElasticsearchTask SEARCH_BY_CONDITION = client -> {\r\n        // 创建搜索请求对象\r\n        SearchRequest request = new SearchRequest();\r\n        request.indices(\"user\");\r\n        // 构建查询的请求体\r\n        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();\r\n        sourceBuilder.query(QueryBuilders.termQuery(\"age\", \"30\"));\r\n        request.source(sourceBuilder);\r\n        SearchResponse response = client.search(request, RequestOptions.DEFAULT);\r\n        // 查询匹配\r\n        SearchHits hits = response.getHits();\r\n        System.out.println(\"took:\" + response.getTook());\r\n        System.out.println(\"timeout:\" + response.isTimedOut());\r\n        System.out.println(\"total:\" + hits.getTotalHits());\r\n        System.out.println(\"MaxScore:\" + hits.getMaxScore());\r\n        System.out.println(\"hits========>>\");\r\n        for (SearchHit hit : hits) {\r\n            //输出每条查询的结果信息\r\n            System.out.println(hit.getSourceAsString());\r\n        }\r\n        System.out.println(\"<<========\");\r\n    };\r\n    \r\n    public static void main(String[] args) {\r\n        ConnectElasticsearch.connect(SEARCH_BY_CONDITION);\r\n    }\r\n}\r\n\r\n```\r\n\r\n后台打印\r\n\r\n```\r\ntook:1ms\r\ntimeout:false\r\ntotal:1 hits\r\nMaxScore:1.0\r\nhits========>>\r\n{\"name\":\"lisi\",\"age\":\"30\",\"sex\":\"女\"}\r\n<<========\r\n\r\n```\r\n\r\n### 分页查询\r\n\r\n```java\r\nimport com.lun.elasticsearch.hello.ConnectElasticsearch;\r\nimport com.lun.elasticsearch.hello.ElasticsearchTask;\r\nimport org.elasticsearch.action.search.SearchRequest;\r\nimport org.elasticsearch.action.search.SearchResponse;\r\nimport org.elasticsearch.client.RequestOptions;\r\nimport org.elasticsearch.index.query.QueryBuilders;\r\nimport org.elasticsearch.search.SearchHit;\r\nimport org.elasticsearch.search.SearchHits;\r\nimport org.elasticsearch.search.builder.SearchSourceBuilder;\r\nimport org.elasticsearch.search.sort.SortOrder;\r\n\r\npublic class QueryDoc {\r\n    \r\n\tpublic static final ElasticsearchTask SEARCH_BY_PAGING = client -> {\r\n        // 创建搜索请求对象\r\n        SearchRequest request = new SearchRequest();\r\n        request.indices(\"user\");\r\n        // 构建查询的请求体\r\n        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();\r\n        sourceBuilder.query(QueryBuilders.matchAllQuery());\r\n        // 分页查询\r\n        // 当前页其实索引(第一条数据的顺序号)， from\r\n        sourceBuilder.from(0);\r\n\r\n        // 每页显示多少条 size\r\n        sourceBuilder.size(2);\r\n        request.source(sourceBuilder);\r\n        SearchResponse response = client.search(request, RequestOptions.DEFAULT);\r\n        // 查询匹配\r\n        SearchHits hits = response.getHits();\r\n        System.out.println(\"took:\" + response.getTook());\r\n        System.out.println(\"timeout:\" + response.isTimedOut());\r\n        System.out.println(\"total:\" + hits.getTotalHits());\r\n        System.out.println(\"MaxScore:\" + hits.getMaxScore());\r\n        System.out.println(\"hits========>>\");\r\n        for (SearchHit hit : hits) {\r\n            //输出每条查询的结果信息\r\n            System.out.println(hit.getSourceAsString());\r\n        }\r\n        System.out.println(\"<<========\");\r\n    };\r\n    \r\n    public static void main(String[] args) {\r\n        ConnectElasticsearch.connect(SEARCH_BY_CONDITION);\r\n    }\r\n\r\n}\r\n\r\n```\r\n\r\n后台打印\r\n\r\n```\r\ntook:1ms\r\ntimeout:false\r\ntotal:6 hits\r\nMaxScore:1.0\r\nhits========>>\r\n{\"name\":\"zhangsan\",\"age\":\"10\",\"sex\":\"女\"}\r\n{\"name\":\"lisi\",\"age\":\"30\",\"sex\":\"女\"}\r\n<<========\r\n\r\n```\r\n\r\n### 查询排序\r\n\r\n```java\r\nimport com.lun.elasticsearch.hello.ConnectElasticsearch;\r\nimport com.lun.elasticsearch.hello.ElasticsearchTask;\r\nimport org.elasticsearch.action.search.SearchRequest;\r\nimport org.elasticsearch.action.search.SearchResponse;\r\nimport org.elasticsearch.client.RequestOptions;\r\nimport org.elasticsearch.index.query.QueryBuilders;\r\nimport org.elasticsearch.search.SearchHit;\r\nimport org.elasticsearch.search.SearchHits;\r\nimport org.elasticsearch.search.builder.SearchSourceBuilder;\r\nimport org.elasticsearch.search.sort.SortOrder;\r\n\r\npublic class QueryDoc {\r\n    \r\n\tpublic static final ElasticsearchTask SEARCH_WITH_ORDER = client -> {\r\n        // 创建搜索请求对象\r\n        SearchRequest request = new SearchRequest();\r\n        request.indices(\"user\");\r\n\r\n        // 构建查询的请求体\r\n        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();\r\n        sourceBuilder.query(QueryBuilders.matchAllQuery());\r\n        // 排序\r\n        sourceBuilder.sort(\"age\", SortOrder.ASC);\r\n        request.source(sourceBuilder);\r\n        SearchResponse response = client.search(request, RequestOptions.DEFAULT);\r\n        // 查询匹配\r\n        SearchHits hits = response.getHits();\r\n        System.out.println(\"took:\" + response.getTook());\r\n        System.out.println(\"timeout:\" + response.isTimedOut());\r\n        System.out.println(\"total:\" + hits.getTotalHits());\r\n        System.out.println(\"MaxScore:\" + hits.getMaxScore());\r\n        System.out.println(\"hits========>>\");\r\n        for (SearchHit hit : hits) {\r\n        //输出每条查询的结果信息\r\n            System.out.println(hit.getSourceAsString());\r\n        }\r\n        System.out.println(\"<<========\");\r\n    };\r\n\r\n    public static void main(String[] args) {\r\n        ConnectElasticsearch.connect(SEARCH_WITH_ORDER);\r\n    }\r\n\r\n}\r\n\r\n\r\n```\r\n\r\n后台打印\r\n\r\n```\r\ntook:1ms\r\ntimeout:false\r\ntotal:6 hits\r\nMaxScore:NaN\r\nhits========>>\r\n{\"name\":\"zhangsan\",\"age\":\"10\",\"sex\":\"女\"}\r\n{\"name\":\"wangwu2\",\"age\":\"20\",\"sex\":\"女\"}\r\n{\"name\":\"wangwu4\",\"age\":\"20\",\"sex\":\"男\"}\r\n{\"name\":\"lisi\",\"age\":\"30\",\"sex\":\"女\"}\r\n{\"name\":\"wangwu1\",\"age\":\"40\",\"sex\":\"男\"}\r\n{\"name\":\"wangwu3\",\"age\":\"50\",\"sex\":\"男\"}\r\n<<========\r\n\r\n```\r\n\r\n## 26-入门-JavaAPI-文档-高级查询-组合查询 & 范围查询\r\n\r\n### 组合查询\r\n\r\n```java\r\nimport com.lun.elasticsearch.hello.ConnectElasticsearch;\r\nimport com.lun.elasticsearch.hello.ElasticsearchTask;\r\nimport org.elasticsearch.action.search.SearchRequest;\r\nimport org.elasticsearch.action.search.SearchResponse;\r\nimport org.elasticsearch.client.RequestOptions;\r\nimport org.elasticsearch.index.query.BoolQueryBuilder;\r\nimport org.elasticsearch.index.query.QueryBuilders;\r\nimport org.elasticsearch.search.SearchHit;\r\nimport org.elasticsearch.search.SearchHits;\r\nimport org.elasticsearch.search.builder.SearchSourceBuilder;\r\nimport org.elasticsearch.search.sort.SortOrder;\r\n\r\npublic class QueryDoc {\r\n    \r\n\tpublic static final ElasticsearchTask SEARCH_BY_BOOL_CONDITION = client -> {\r\n        // 创建搜索请求对象\r\n        SearchRequest request = new SearchRequest();\r\n        request.indices(\"user\");\r\n        // 构建查询的请求体\r\n        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();\r\n        BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery();\r\n        // 必须包含\r\n        boolQueryBuilder.must(QueryBuilders.matchQuery(\"age\", \"30\"));\r\n        // 一定不含\r\n        boolQueryBuilder.mustNot(QueryBuilders.matchQuery(\"name\", \"zhangsan\"));\r\n        // 可能包含\r\n        boolQueryBuilder.should(QueryBuilders.matchQuery(\"sex\", \"男\"));\r\n        sourceBuilder.query(boolQueryBuilder);\r\n        request.source(sourceBuilder);\r\n        SearchResponse response = client.search(request, RequestOptions.DEFAULT);\r\n        // 查询匹配\r\n        SearchHits hits = response.getHits();\r\n        System.out.println(\"took:\" + response.getTook());\r\n        System.out.println(\"timeout:\" + response.isTimedOut());\r\n        System.out.println(\"total:\" + hits.getTotalHits());\r\n        System.out.println(\"MaxScore:\" + hits.getMaxScore());\r\n        System.out.println(\"hits========>>\");\r\n        for (SearchHit hit : hits) {\r\n            //输出每条查询的结果信息\r\n            System.out.println(hit.getSourceAsString());\r\n        }\r\n        System.out.println(\"<<========\");\r\n\r\n    };\r\n\r\n    public static void main(String[] args) {\r\n        ConnectElasticsearch.connect(SEARCH_BY_BOOL_CONDITION);\r\n    }\r\n}\r\n\r\n```\r\n\r\n后台打印\r\n\r\n```\r\ntook:28ms\r\ntimeout:false\r\ntotal:1 hits\r\nMaxScore:1.0\r\nhits========>>\r\n{\"name\":\"lisi\",\"age\":\"30\",\"sex\":\"女\"}\r\n<<========\r\n\r\nProcess finished with exit code 0\r\n\r\n```\r\n\r\n### 范围查询\r\n\r\n```java\r\nimport com.lun.elasticsearch.hello.ConnectElasticsearch;\r\nimport com.lun.elasticsearch.hello.ElasticsearchTask;\r\nimport org.elasticsearch.action.search.SearchRequest;\r\nimport org.elasticsearch.action.search.SearchResponse;\r\nimport org.elasticsearch.client.RequestOptions;\r\nimport org.elasticsearch.index.query.BoolQueryBuilder;\r\nimport org.elasticsearch.index.query.QueryBuilders;\r\nimport org.elasticsearch.index.query.RangeQueryBuilder;\r\nimport org.elasticsearch.search.SearchHit;\r\nimport org.elasticsearch.search.SearchHits;\r\nimport org.elasticsearch.search.builder.SearchSourceBuilder;\r\nimport org.elasticsearch.search.sort.SortOrder;\r\n\r\npublic class QueryDoc {\r\n    \r\n\tpublic static final ElasticsearchTask SEARCH_BY_RANGE = client -> {\r\n        // 创建搜索请求对象\r\n        SearchRequest request = new SearchRequest();\r\n        request.indices(\"user\");\r\n        // 构建查询的请求体\r\n        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();\r\n        RangeQueryBuilder rangeQuery = QueryBuilders.rangeQuery(\"age\");\r\n        // 大于等于\r\n        //rangeQuery.gte(\"30\");\r\n        // 小于等于\r\n        rangeQuery.lte(\"40\");\r\n        sourceBuilder.query(rangeQuery);\r\n        request.source(sourceBuilder);\r\n        SearchResponse response = client.search(request, RequestOptions.DEFAULT);\r\n        // 查询匹配\r\n        SearchHits hits = response.getHits();\r\n        System.out.println(\"took:\" + response.getTook());\r\n        System.out.println(\"timeout:\" + response.isTimedOut());\r\n        System.out.println(\"total:\" + hits.getTotalHits());\r\n        System.out.println(\"MaxScore:\" + hits.getMaxScore());\r\n        System.out.println(\"hits========>>\");\r\n        for (SearchHit hit : hits) {\r\n        //输出每条查询的结果信息\r\n            System.out.println(hit.getSourceAsString());\r\n        }\r\n        System.out.println(\"<<========\");\r\n    };\r\n\r\n    public static void main(String[] args) {\r\n        ConnectElasticsearch.connect(SEARCH_BY_RANGE);\r\n    }\r\n\r\n}\r\n\r\n\r\n```\r\n\r\n后台打印\r\n\r\n```\r\ntook:1ms\r\ntimeout:false\r\ntotal:5 hits\r\nMaxScore:1.0\r\nhits========>>\r\n{\"name\":\"zhangsan\",\"age\":\"10\",\"sex\":\"女\"}\r\n{\"name\":\"lisi\",\"age\":\"30\",\"sex\":\"女\"}\r\n{\"name\":\"wangwu1\",\"age\":\"40\",\"sex\":\"男\"}\r\n{\"name\":\"wangwu2\",\"age\":\"20\",\"sex\":\"女\"}\r\n{\"name\":\"wangwu4\",\"age\":\"20\",\"sex\":\"男\"}\r\n<<========\r\n\r\nProcess finished with exit code 0\r\n\r\n```\r\n\r\n## 27-入门-JavaAPI-文档-高级查询-模糊查询 & 高亮查询\r\n\r\n### 模糊查询\r\n\r\n```java\r\nimport com.lun.elasticsearch.hello.ConnectElasticsearch;\r\nimport com.lun.elasticsearch.hello.ElasticsearchTask;\r\nimport org.elasticsearch.action.search.SearchRequest;\r\nimport org.elasticsearch.action.search.SearchResponse;\r\nimport org.elasticsearch.client.RequestOptions;\r\nimport org.elasticsearch.common.unit.Fuzziness;\r\nimport org.elasticsearch.index.query.BoolQueryBuilder;\r\nimport org.elasticsearch.index.query.QueryBuilders;\r\nimport org.elasticsearch.index.query.RangeQueryBuilder;\r\nimport org.elasticsearch.search.SearchHit;\r\nimport org.elasticsearch.search.SearchHits;\r\nimport org.elasticsearch.search.builder.SearchSourceBuilder;\r\nimport org.elasticsearch.search.sort.SortOrder;\r\n\r\npublic class QueryDoc {\r\n    \r\n    public static final ElasticsearchTask SEARCH_BY_FUZZY_CONDITION = client -> {\r\n        // 创建搜索请求对象\r\n        SearchRequest request = new SearchRequest();\r\n        request.indices(\"user\");\r\n        // 构建查询的请求体\r\n        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();\r\n        sourceBuilder.query(QueryBuilders.fuzzyQuery(\"name\",\"wangwu\").fuzziness(Fuzziness.ONE));\r\n        request.source(sourceBuilder);\r\n        SearchResponse response = client.search(request, RequestOptions.DEFAULT);\r\n        // 查询匹配\r\n        SearchHits hits = response.getHits();\r\n        System.out.println(\"took:\" + response.getTook());\r\n        System.out.println(\"timeout:\" + response.isTimedOut());\r\n        System.out.println(\"total:\" + hits.getTotalHits());\r\n        System.out.println(\"MaxScore:\" + hits.getMaxScore());\r\n        System.out.println(\"hits========>>\");\r\n        for (SearchHit hit : hits) {\r\n            //输出每条查询的结果信息\r\n            System.out.println(hit.getSourceAsString());\r\n        }\r\n        System.out.println(\"<<========\");\r\n    };\r\n\r\n\r\n    public static void main(String[] args) {\r\n//        ConnectElasticsearch.connect(SEARCH_ALL);\r\n//        ConnectElasticsearch.connect(SEARCH_BY_CONDITION);\r\n//        ConnectElasticsearch.connect(SEARCH_BY_PAGING);\r\n//        ConnectElasticsearch.connect(SEARCH_WITH_ORDER);\r\n//        ConnectElasticsearch.connect(SEARCH_BY_BOOL_CONDITION);\r\n//        ConnectElasticsearch.connect(SEARCH_BY_RANGE);\r\n        ConnectElasticsearch.connect(SEARCH_BY_FUZZY_CONDITION);\r\n    }\r\n\r\n}\r\n\r\n```\r\n\r\n后台打印\r\n\r\n```\r\ntook:152ms\r\ntimeout:false\r\ntotal:4 hits\r\nMaxScore:1.2837042\r\nhits========>>\r\n{\"name\":\"wangwu1\",\"age\":\"40\",\"sex\":\"男\"}\r\n{\"name\":\"wangwu2\",\"age\":\"20\",\"sex\":\"女\"}\r\n{\"name\":\"wangwu3\",\"age\":\"50\",\"sex\":\"男\"}\r\n{\"name\":\"wangwu4\",\"age\":\"20\",\"sex\":\"男\"}\r\n<<========\r\n\r\nProcess finished with exit code 0\r\n\r\n```\r\n\r\n### 高亮查询\r\n\r\n```java\r\nimport com.lun.elasticsearch.hello.ConnectElasticsearch;\r\nimport com.lun.elasticsearch.hello.ElasticsearchTask;\r\nimport org.elasticsearch.action.search.SearchRequest;\r\nimport org.elasticsearch.action.search.SearchResponse;\r\nimport org.elasticsearch.client.RequestOptions;\r\nimport org.elasticsearch.common.unit.Fuzziness;\r\nimport org.elasticsearch.index.query.BoolQueryBuilder;\r\nimport org.elasticsearch.index.query.QueryBuilders;\r\nimport org.elasticsearch.index.query.RangeQueryBuilder;\r\nimport org.elasticsearch.index.query.TermsQueryBuilder;\r\nimport org.elasticsearch.search.SearchHit;\r\nimport org.elasticsearch.search.SearchHits;\r\nimport org.elasticsearch.search.builder.SearchSourceBuilder;\r\nimport org.elasticsearch.search.fetch.subphase.highlight.HighlightBuilder;\r\nimport org.elasticsearch.search.fetch.subphase.highlight.HighlightField;\r\nimport org.elasticsearch.search.sort.SortOrder;\r\n\r\nimport java.util.Map;\r\n\r\npublic class QueryDoc {\r\n    \r\n    public static final ElasticsearchTask SEARCH_WITH_HIGHLIGHT = client -> {\r\n        // 高亮查询\r\n        SearchRequest request = new SearchRequest().indices(\"user\");\r\n        //2.创建查询请求体构建器\r\n        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();\r\n        //构建查询方式：高亮查询\r\n        TermsQueryBuilder termsQueryBuilder =\r\n                QueryBuilders.termsQuery(\"name\",\"zhangsan\");\r\n        //设置查询方式\r\n        sourceBuilder.query(termsQueryBuilder);\r\n        //构建高亮字段\r\n        HighlightBuilder highlightBuilder = new HighlightBuilder();\r\n        highlightBuilder.preTags(\"<font color='red'>\");//设置标签前缀\r\n        highlightBuilder.postTags(\"</font>\");//设置标签后缀\r\n        highlightBuilder.field(\"name\");//设置高亮字段\r\n        //设置高亮构建对象\r\n        sourceBuilder.highlighter(highlightBuilder);\r\n        //设置请求体\r\n        request.source(sourceBuilder);\r\n        //3.客户端发送请求，获取响应对象\r\n        SearchResponse response = client.search(request, RequestOptions.DEFAULT);\r\n        //4.打印响应结果\r\n        SearchHits hits = response.getHits();\r\n        System.out.println(\"took::\"+response.getTook());\r\n        System.out.println(\"time_out::\"+response.isTimedOut());\r\n        System.out.println(\"total::\"+hits.getTotalHits());\r\n        System.out.println(\"max_score::\"+hits.getMaxScore());\r\n        System.out.println(\"hits::::>>\");\r\n        for (SearchHit hit : hits) {\r\n            String sourceAsString = hit.getSourceAsString();\r\n            System.out.println(sourceAsString);\r\n            //打印高亮结果\r\n            Map<String, HighlightField> highlightFields = hit.getHighlightFields();\r\n            System.out.println(highlightFields);\r\n        }\r\n        System.out.println(\"<<::::\");\r\n    };\r\n\r\n\r\n    public static void main(String[] args) {\r\n        ConnectElasticsearch.connect(SEARCH_WITH_HIGHLIGHT);\r\n    }\r\n\r\n}\r\n\r\n```\r\n\r\n后台打印\r\n\r\n```\r\ntook::672ms\r\ntime_out::false\r\ntotal::1 hits\r\nmax_score::1.0\r\nhits::::>>\r\n{\"name\":\"zhangsan\",\"age\":\"10\",\"sex\":\"女\"}\r\n{name=[name], fragments[[<font color='red'>zhangsan</font>]]}\r\n<<::::\r\n\r\nProcess finished with exit code 0\r\n\r\n```\r\n\r\n## 28-入门-JavaAPI-文档-高级查询-最大值查询 & 分组查询\r\n\r\n### 最大值查询\r\n\r\n```java\r\nimport com.lun.elasticsearch.hello.ConnectElasticsearch;\r\nimport com.lun.elasticsearch.hello.ElasticsearchTask;\r\nimport org.elasticsearch.action.search.SearchRequest;\r\nimport org.elasticsearch.action.search.SearchResponse;\r\nimport org.elasticsearch.client.RequestOptions;\r\nimport org.elasticsearch.common.unit.Fuzziness;\r\nimport org.elasticsearch.index.query.BoolQueryBuilder;\r\nimport org.elasticsearch.index.query.QueryBuilders;\r\nimport org.elasticsearch.index.query.RangeQueryBuilder;\r\nimport org.elasticsearch.index.query.TermsQueryBuilder;\r\nimport org.elasticsearch.search.SearchHit;\r\nimport org.elasticsearch.search.SearchHits;\r\nimport org.elasticsearch.search.aggregations.AggregationBuilders;\r\nimport org.elasticsearch.search.builder.SearchSourceBuilder;\r\nimport org.elasticsearch.search.fetch.subphase.highlight.HighlightBuilder;\r\nimport org.elasticsearch.search.fetch.subphase.highlight.HighlightField;\r\nimport org.elasticsearch.search.sort.SortOrder;\r\n\r\nimport java.util.Map;\r\n\r\npublic class QueryDoc {\r\n    \r\n    public static final ElasticsearchTask SEARCH_WITH_MAX = client -> {\r\n        // 高亮查询\r\n        SearchRequest request = new SearchRequest().indices(\"user\");\r\n        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();\r\n        sourceBuilder.aggregation(AggregationBuilders.max(\"maxAge\").field(\"age\"));\r\n        //设置请求体\r\n        request.source(sourceBuilder);\r\n        //3.客户端发送请求，获取响应对象\r\n        SearchResponse response = client.search(request, RequestOptions.DEFAULT);\r\n        //4.打印响应结果\r\n        SearchHits hits = response.getHits();\r\n        System.out.println(response);\r\n    };\r\n\r\n    public static void main(String[] args) {\r\n        ConnectElasticsearch.connect(SEARCH_WITH_MAX);\r\n    }\r\n\r\n}\r\n\r\n```\r\n\r\n后台打印\r\n\r\n```\r\n{\"took\":16,\"timed_out\":false,\"_shards\":{\"total\":1,\"successful\":1,\"skipped\":0,\"failed\":0},\"hits\":{\"total\":{\"value\":6,\"relation\":\"eq\"},\"max_score\":1.0,\"hits\":[{\"_index\":\"user\",\"_type\":\"_doc\",\"_id\":\"1001\",\"_score\":1.0,\"_source\":{\"name\":\"zhangsan\",\"age\":\"10\",\"sex\":\"女\"}},{\"_index\":\"user\",\"_type\":\"_doc\",\"_id\":\"1002\",\"_score\":1.0,\"_source\":{\"name\":\"lisi\",\"age\":\"30\",\"sex\":\"女\"}},{\"_index\":\"user\",\"_type\":\"_doc\",\"_id\":\"1003\",\"_score\":1.0,\"_source\":{\"name\":\"wangwu1\",\"age\":\"40\",\"sex\":\"男\"}},{\"_index\":\"user\",\"_type\":\"_doc\",\"_id\":\"1004\",\"_score\":1.0,\"_source\":{\"name\":\"wangwu2\",\"age\":\"20\",\"sex\":\"女\"}},{\"_index\":\"user\",\"_type\":\"_doc\",\"_id\":\"1005\",\"_score\":1.0,\"_source\":{\"name\":\"wangwu3\",\"age\":\"50\",\"sex\":\"男\"}},{\"_index\":\"user\",\"_type\":\"_doc\",\"_id\":\"1006\",\"_score\":1.0,\"_source\":{\"name\":\"wangwu4\",\"age\":\"20\",\"sex\":\"男\"}}]},\"aggregations\":{\"max#maxAge\":{\"value\":50.0}}}\r\n\r\nProcess finished with exit code 0\r\n\r\n```\r\n\r\n### 分组查询\r\n\r\n```java\r\nimport com.lun.elasticsearch.hello.ConnectElasticsearch;\r\nimport com.lun.elasticsearch.hello.ElasticsearchTask;\r\nimport org.elasticsearch.action.search.SearchRequest;\r\nimport org.elasticsearch.action.search.SearchResponse;\r\nimport org.elasticsearch.client.RequestOptions;\r\nimport org.elasticsearch.common.unit.Fuzziness;\r\nimport org.elasticsearch.index.query.BoolQueryBuilder;\r\nimport org.elasticsearch.index.query.QueryBuilders;\r\nimport org.elasticsearch.index.query.RangeQueryBuilder;\r\nimport org.elasticsearch.index.query.TermsQueryBuilder;\r\nimport org.elasticsearch.search.SearchHit;\r\nimport org.elasticsearch.search.SearchHits;\r\nimport org.elasticsearch.search.aggregations.AggregationBuilders;\r\nimport org.elasticsearch.search.builder.SearchSourceBuilder;\r\nimport org.elasticsearch.search.fetch.subphase.highlight.HighlightBuilder;\r\nimport org.elasticsearch.search.fetch.subphase.highlight.HighlightField;\r\nimport org.elasticsearch.search.sort.SortOrder;\r\n\r\nimport java.util.Map;\r\n\r\npublic class QueryDoc {\r\n\r\n\tpublic static final ElasticsearchTask SEARCH_WITH_GROUP = client -> {\r\n        SearchRequest request = new SearchRequest().indices(\"user\");\r\n        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();\r\n        sourceBuilder.aggregation(AggregationBuilders.terms(\"age_groupby\").field(\"age\"));\r\n        //设置请求体\r\n        request.source(sourceBuilder);\r\n        //3.客户端发送请求，获取响应对象\r\n        SearchResponse response = client.search(request, RequestOptions.DEFAULT);\r\n        //4.打印响应结果\r\n        SearchHits hits = response.getHits();\r\n        System.out.println(response);\r\n    };\r\n\r\n    public static void main(String[] args) {\r\n        ConnectElasticsearch.connect(SEARCH_WITH_GROUP);\r\n    }\r\n\r\n}\r\n\r\n```\r\n\r\n后台打印\r\n\r\n```\r\n{\"took\":10,\"timed_out\":false,\"_shards\":{\"total\":1,\"successful\":1,\"skipped\":0,\"failed\":0},\"hits\":{\"total\":{\"value\":6,\"relation\":\"eq\"},\"max_score\":1.0,\"hits\":[{\"_index\":\"user\",\"_type\":\"_doc\",\"_id\":\"1001\",\"_score\":1.0,\"_source\":{\"name\":\"zhangsan\",\"age\":\"10\",\"sex\":\"女\"}},{\"_index\":\"user\",\"_type\":\"_doc\",\"_id\":\"1002\",\"_score\":1.0,\"_source\":{\"name\":\"lisi\",\"age\":\"30\",\"sex\":\"女\"}},{\"_index\":\"user\",\"_type\":\"_doc\",\"_id\":\"1003\",\"_score\":1.0,\"_source\":{\"name\":\"wangwu1\",\"age\":\"40\",\"sex\":\"男\"}},{\"_index\":\"user\",\"_type\":\"_doc\",\"_id\":\"1004\",\"_score\":1.0,\"_source\":{\"name\":\"wangwu2\",\"age\":\"20\",\"sex\":\"女\"}},{\"_index\":\"user\",\"_type\":\"_doc\",\"_id\":\"1005\",\"_score\":1.0,\"_source\":{\"name\":\"wangwu3\",\"age\":\"50\",\"sex\":\"男\"}},{\"_index\":\"user\",\"_type\":\"_doc\",\"_id\":\"1006\",\"_score\":1.0,\"_source\":{\"name\":\"wangwu4\",\"age\":\"20\",\"sex\":\"男\"}}]},\"aggregations\":{\"lterms#age_groupby\":{\"doc_count_error_upper_bound\":0,\"sum_other_doc_count\":0,\"buckets\":[{\"key\":20,\"doc_count\":2},{\"key\":10,\"doc_count\":1},{\"key\":30,\"doc_count\":1},{\"key\":40,\"doc_count\":1},{\"key\":50,\"doc_count\":1}]}}}\r\n\r\nProcess finished with exit code 0\r\n\r\n```\r\n\r\n# 第3章 Elasticsearch环境\r\n\r\n## 29-环境-简介\r\n\r\n### 单机 & 集群\r\n\r\n单台Elasticsearch服务器提供服务，往往都有最大的负载能力，超过这个阈值，服务器\r\n性能就会大大降低甚至不可用，所以生产环境中，一般都是运行在指定服务器集群中。\r\n除了负载能力，单点服务器也存在其他问题：\r\n\r\n- 单台机器存储容量有限\r\n- 单服务器容易出现单点故障，无法实现高可用\r\n- 单服务的并发处理能力有限\r\n\r\n配置服务器集群时，集群中节点数量没有限制，大于等于2个节点就可以看做是集群了。一\r\n般出于高性能及高可用方面来考虑集群中节点数量都是3个以上\r\n\r\n总之，集群能提高性能，增加容错。\r\n\r\n### 集群 Cluster\r\n\r\n**一个集群就是由一个或多个服务器节点组织在一起，共同持有整个的数据，并一起提供索引和搜索功能。**一个Elasticsearch集群有一个唯一的名字标识，这个名字默认就是”elasticsearch”。这个名字是重要的，因为一个节点只能通过指定某个集群的名字，来加入这个集群。\r\n\r\n### 节点Node\r\n\r\n集群中包含很多服务器，一个节点就是其中的一个服务器。作为集群的一部分，它存储数据，参与集群的索引和搜索功能。\r\n\r\n一个节点也是由一个名字来标识的，默认情况下，这个名字是一个随机的漫威漫画角色的名字，这个名字会在启动的时候赋予节点。这个名字对于管理工作来说挺重要的，因为在这个管理过程中，你会去确定网络中的哪些服务器对应于Elasticsearch集群中的哪些节点。\r\n\r\n一个节点可以通过配置集群名称的方式来加入一个指定的集群。默认情况下，每个节点都会被安排加入到一个叫做“elasticsearch”的集群中，这意味着，如果你在你的网络中启动了若干个节点，并假定它们能够相互发现彼此，它们将会自动地形成并加入到一个叫做“elasticsearch”的集群中。\r\n\r\n在一个集群里，只要你想，可以拥有任意多个节点。而且，如果当前你的网络中没有运\r\n行任何Elasticsearch节点，这时启动一个节点，会默认创建并加入一个叫做“elasticsearch”的\r\n集群。\r\n\r\n## 30-环境-Windows集群部署\r\n\r\n### 部署集群\r\n\r\n一、创建elasticsearch-cluster文件夹\r\n\r\n创建elasticsearch-7.8.0-cluster文件夹，在内部复制三个elasticsearch服务。\r\n\r\n![img](https://img-blog.csdnimg.cn/img_convert/6d6022b6d30a9e2c1a4e18092d5f130f.png)\r\n\r\n二、修改集群文件目录中每个节点的config/elasticsearch.yml配置文件\r\n\r\n**node-1001节点**\r\n\r\n```yaml\r\n#节点1的配置信息：\r\n#集群名称，节点之间要保持一致\r\ncluster.name: my-elasticsearch\r\n#节点名称，集群内要唯一\r\nnode.name: node-1001\r\nnode.master: true\r\nnode.data: true\r\n#ip地址\r\nnetwork.host: localhost\r\n#http端口\r\nhttp.port: 1001\r\n#tcp监听端口\r\ntransport.tcp.port: 9301\r\n#discovery.seed_hosts: [\"localhost:9301\", \"localhost:9302\",\"localhost:9303\"]\r\n#discovery.zen.fd.ping_timeout: 1m\r\n#discovery.zen.fd.ping_retries: 5\r\n#集群内的可以被选为主节点的节点列表\r\n#cluster.initial_master_nodes: [\"node-1\", \"node-2\",\"node-3\"]\r\n#跨域配置\r\n#action.destructive_requires_name: true\r\nhttp.cors.enabled: true\r\nhttp.cors.allow-origin: \"*\"\r\n\r\n```\r\n\r\n**node-1002节点**\r\n\r\n```yaml\r\n#节点2的配置信息：\r\n#集群名称，节点之间要保持一致\r\ncluster.name: my-elasticsearch\r\n#节点名称，集群内要唯一\r\nnode.name: node-1002\r\nnode.master: true\r\nnode.data: true\r\n#ip地址\r\nnetwork.host: localhost\r\n#http端口\r\nhttp.port: 1002\r\n#tcp监听端口\r\ntransport.tcp.port: 9302\r\ndiscovery.seed_hosts: [\"localhost:9301\"]\r\ndiscovery.zen.fd.ping_timeout: 1m\r\ndiscovery.zen.fd.ping_retries: 5\r\n#集群内的可以被选为主节点的节点列表\r\n#cluster.initial_master_nodes: [\"node-1\", \"node-2\",\"node-3\"]\r\n#跨域配置\r\n#action.destructive_requires_name: true\r\nhttp.cors.enabled: true\r\nhttp.cors.allow-origin: \"*\"\r\n\r\n```\r\n\r\n**node-1003节点**\r\n\r\n```yaml\r\n#节点3的配置信息：\r\n#集群名称，节点之间要保持一致\r\ncluster.name: my-elasticsearch\r\n#节点名称，集群内要唯一\r\nnode.name: node-1003\r\nnode.master: true\r\nnode.data: true\r\n#ip地址\r\nnetwork.host: localhost\r\n#http端口\r\nhttp.port: 1003\r\n#tcp监听端口\r\ntransport.tcp.port: 9303\r\n#候选主节点的地址，在开启服务后可以被选为主节点\r\ndiscovery.seed_hosts: [\"localhost:9301\", \"localhost:9302\"]\r\ndiscovery.zen.fd.ping_timeout: 1m\r\ndiscovery.zen.fd.ping_retries: 5\r\n#集群内的可以被选为主节点的节点列表\r\n#cluster.initial_master_nodes: [\"node-1\", \"node-2\",\"node-3\"]\r\n#跨域配置\r\n#action.destructive_requires_name: true\r\nhttp.cors.enabled: true\r\nhttp.cors.allow-origin: \"*\"\r\n\r\n```\r\n\r\n三、如果有必要，删除每个节点中的data目录中所有内容。\r\n\r\n### 启动集群\r\n\r\n分别依次双击执行节点的bin/elasticsearch.bat,启动节点服务器（可以编写一个脚本启动），启动后，会自动加入指定名称的集群。\r\n\r\n### 测试集群\r\n\r\n一、用Postman，查看集群状态\r\n\r\n1. `GET http://127.0.0.1:1001/_cluster/health`\r\n2. `GET http://127.0.0.1:1002/_cluster/health`\r\n3. `GET http://127.0.0.1:1003/_cluster/health`\r\n\r\n返回结果皆为如下：\r\n\r\n```json\r\n{\r\n    \"cluster_name\": \"my-application\",\r\n    \"status\": \"green\",\r\n    \"timed_out\": false,\r\n    \"number_of_nodes\": 3,\r\n    \"number_of_data_nodes\": 3,\r\n    \"active_primary_shards\": 0,\r\n    \"active_shards\": 0,\r\n    \"relocating_shards\": 0,\r\n    \"initializing_shards\": 0,\r\n    \"unassigned_shards\": 0,\r\n    \"delayed_unassigned_shards\": 0,\r\n    \"number_of_pending_tasks\": 0,\r\n    \"number_of_in_flight_fetch\": 0,\r\n    \"task_max_waiting_in_queue_millis\": 0,\r\n    \"active_shards_percent_as_number\": 100.0\r\n}\r\n\r\n```\r\n\r\n**status字段**指示着当前集群在总体上是否工作正常。它的三种颜色含义如下：\r\n\r\n1. green：所有的主分片和副本分片都正常运行。\r\n2. yellow：所有的主分片都正常运行，但不是所有的副本分片都正常运行。\r\n3. red：有主分片没能正常运行。\r\n\r\n二、用Postman，在一节点增加索引，另一节点获取索引\r\n\r\n向集群中的node-1001节点增加索引：\r\n\r\n```json\r\n#PUT http://127.0.0.1:1001/user\r\n\r\n```\r\n\r\n返回结果：\r\n\r\n```json\r\n{\r\n    \"acknowledged\": true,\r\n    \"shards_acknowledged\": true,\r\n    \"index\": \"user\"\r\n}\r\n\r\n```\r\n\r\n向集群中的node-1003节点获取索引：\r\n\r\n```json\r\n#GET http://127.0.0.1:1003/user\r\n\r\n```\r\n\r\n返回结果：\r\n\r\n```json\r\n{\r\n    \"user\": {\r\n        \"aliases\": {},\r\n        \"mappings\": {},\r\n        \"settings\": {\r\n            \"index\": {\r\n                \"creation_date\": \"1617993035885\",\r\n                \"number_of_shards\": \"1\",\r\n                \"number_of_replicas\": \"1\",\r\n                \"uuid\": \"XJKERwQlSJ6aUxZEN2EV0w\",\r\n                \"version\": {\r\n                    \"created\": \"7080099\"\r\n                },\r\n                \"provided_name\": \"user\"\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\n如果在1003创建索引，同样在1001也能获取索引信息，这就是集群能力。\r\n\r\n## 31-环境-Linux单节点部署\r\n\r\n### 软件安装\r\n\r\n一、下载软件\r\n\r\n[下载Linux版的Elasticsearch](https://www.elastic.co/cn/downloads/past-releases/elasticsearch-7-8-0)\r\n\r\n二、解压软件\r\n\r\n```shell\r\n# 解压缩\r\ntar -zxvf elasticsearch-7.8.0-linux-x86_64.tar.gz -C /opt/module\r\n# 改名\r\nmv elasticsearch-7.8.0 es\r\n\r\n```\r\n\r\n三、创建用户\r\n\r\n因为安全问题，Elasticsearch不允许root用户直接运行，所以要创建新用户，在root用户中创建新用户。\r\n\r\n```shell\r\nuseradd es #新增es用户\r\npasswd es #为es用户设置密码\r\nuserdel -r es #如果错了，可以删除再加\r\nchown -R es:es /opt/module/es #文件夹所有者\r\n\r\n```\r\n\r\n四、修改配置文件\r\n\r\n修改/opt/module/es/config/elasticsearch.yml文件。\r\n\r\n```yaml\r\n# 加入如下配置\r\ncluster.name: elasticsearch\r\nnode.name: node-1\r\nnetwork.host: 0.0.0.0\r\nhttp.port: 9200\r\ncluster.initial_master_nodes: [\"node-1\"]\r\n\r\n```\r\n\r\n修改/etc/security/limits.conf\r\n\r\n```\r\n# 在文件末尾中增加下面内容\r\n# 每个进程可以打开的文件数的限制\r\nes soft nofile 65536\r\nes hard nofile 65536\r\n\r\n```\r\n\r\n修改/etc/security/limits.d/20-nproc.conf\r\n\r\n```\r\n# 在文件末尾中增加下面内容\r\n# 每个进程可以打开的文件数的限制\r\nes soft nofile 65536\r\nes hard nofile 65536\r\n# 操作系统级别对每个用户创建的进程数的限制\r\n* hard nproc 4096\r\n# 注： * 带表Linux所有用户名称\r\n\r\n```\r\n\r\n修改/etc/sysctl.conf\r\n\r\n```\r\n# 在文件中增加下面内容\r\n# 一个进程可以拥有的VMA(虚拟内存区域)的数量,默认值为65536\r\nvm.max_map_count=655360\r\n\r\n```\r\n\r\n重新加载\r\n\r\n```\r\nsysctl -p\r\n\r\n```\r\n\r\n### 启动软件\r\n\r\n使用ES用户启动\r\n\r\n```\r\ncd /opt/module/es/\r\n#启动\r\nbin/elasticsearch\r\n#后台启动\r\nbin/elasticsearch -d\r\n\r\n```\r\n\r\n启动时，会动态生成文件，如果文件所属用户不匹配，会发生错误，需要重新进行修改用户和用户组\r\n\r\n![img](https://img-blog.csdnimg.cn/img_convert/75e24cd1fbc430577681bb4f8a0d3e2b.png)\r\n\r\n关闭防火墙\r\n\r\n```\r\n#暂时关闭防火墙\r\nsystemctl stop firewalld\r\n#永久关闭防火墙\r\nsystemctl enable firewalld.service #打开防火墙永久性生效，重启后不会复原\r\nsystemctl disable firewalld.service #关闭防火墙，永久性生效，重启后不会复原\r\n\r\n```\r\n\r\n### 测试软件\r\n\r\n浏览器中输入地址： http://linux1:9200/\r\n\r\n![img](https://img-blog.csdnimg.cn/img_convert/477065a2cb499a32871549c21e2fc487.png)\r\n\r\n## 32-环境-Linux集群部署\r\n\r\n### 软件安装\r\n\r\n一、下载软件\r\n\r\n[下载Linux版的Elasticsearch](https://www.elastic.co/cn/downloads/past-releases/elasticsearch-7-8-0)\r\n\r\n二、解压软件\r\n\r\n```shell\r\n# 解压缩\r\ntar -zxvf elasticsearch-7.8.0-linux-x86_64.tar.gz -C /opt/module\r\n# 改名\r\nmv elasticsearch-7.8.0 es-cluster\r\n\r\n```\r\n\r\n将软件分发到其他节点：linux2,linux3\r\n\r\n三、创建用户\r\n\r\n因为安全问题，Elasticsearch不允许root用户直接运行，所以要创建新用户，在root用户中创建新用户。\r\n\r\n```shell\r\nuseradd es #新增es用户\r\npasswd es #为es用户设置密码\r\nuserdel -r es #如果错了，可以删除再加\r\nchown -R es:es /opt/module/es #文件夹所有者\r\n\r\n```\r\n\r\n四、修改配置文件\r\n\r\n修改/opt/module/es/config/elasticsearch.yml文件，分发文件。\r\n\r\n```yaml\r\n# 加入如下配置\r\n#集群名称\r\ncluster.name: cluster-es\r\n#节点名称，每个节点的名称不能重复\r\nnode.name: node-1\r\n#ip地址，每个节点的地址不能重复\r\nnetwork.host: linux1\r\n#是不是有资格主节点\r\nnode.master: true\r\nnode.data: true\r\nhttp.port: 9200\r\n# head插件需要这打开这两个配置\r\nhttp.cors.allow-origin: \"*\"\r\nhttp.cors.enabled: true\r\nhttp.max_content_length: 200mb\r\n#es7.x之后新增的配置，初始化一个新的集群时需要此配置来选举master\r\ncluster.initial_master_nodes: [\"node-1\"]\r\n#es7.x之后新增的配置，节点发现\r\ndiscovery.seed_hosts: [\"linux1:9300\",\"linux2:9300\",\"linux3:9300\"]\r\ngateway.recover_after_nodes: 2\r\nnetwork.tcp.keep_alive: true\r\nnetwork.tcp.no_delay: true\r\ntransport.tcp.compress: true\r\n#集群内同时启动的数据任务个数，默认是2个\r\ncluster.routing.allocation.cluster_concurrent_rebalance: 16\r\n#添加或删除节点及负载均衡时并发恢复的线程个数，默认4个\r\ncluster.routing.allocation.node_concurrent_recoveries: 16\r\n#初始化数据恢复时，并发恢复线程的个数，默认4个\r\ncluster.routing.allocation.node_initial_primaries_recoveries: 16\r\n\r\n```\r\n\r\n修改/etc/security/limits.conf，分发文件\r\n\r\n```\r\n# 在文件末尾中增加下面内容\r\nes soft nofile 65536\r\nes hard nofile 65536\r\n\r\n```\r\n\r\n修改/etc/security/limits.d/20-nproc.conf，分发文件\r\n\r\n```\r\n# 在文件末尾中增加下面内容\r\nes soft nofile 65536\r\nes hard nofile 65536\r\n\\* hard nproc 4096\r\n\\# 注：*代表Linux所有用户名称\r\n\r\n```\r\n\r\n修改/etc/sysctl.conf\r\n\r\n```\r\n# 在文件中增加下面内容\r\nvm.max_map_count=655360\r\n\r\n```\r\n\r\n重新加载\r\n\r\n```\r\nsysctl -p\r\n\r\n```\r\n\r\n### 启动软件\r\n\r\n分别在不同节点上启动ES软件\r\n\r\n```\r\ncd /opt/module/es-cluster\r\n#启动\r\nbin/elasticsearch\r\n#后台启动\r\nbin/elasticsearch -d\r\n\r\n```\r\n\r\n### 测试集群\r\n\r\n![img](https://img-blog.csdnimg.cn/img_convert/0412e37cb5249d1ff0e813ee87f49a50.png)\r\n\r\n# 第4章 Elasticsearch进阶\r\n\r\n## 33-进阶-核心概念\r\n\r\n![img](https://img-blog.csdnimg.cn/img_convert/146a779da01f53e7f7a8d53132d3c7cf.png)\r\n\r\n### 索引Index\r\n\r\n一个索引就是一个拥有几分相似特征的文档的集合。比如说，你可以有一个客户数据的索引，另一个产品目录的索引，还有一个订单数据的索引。一个索引由一个名字来标识（必须全部是小写字母），并且当我们要对这个索引中的文档进行索引、搜索、更新和删除（CRUD）的时候，都要使用到这个名字。在一个集群中，可以定义任意多的索引。\r\n\r\n能搜索的数据必须索引，这样的好处是可以提高查询速度，比如：新华字典前面的目录就是索引的意思，目录可以提高查询速度。\r\n\r\n**Elasticsearch索引的精髓：一切设计都是为了提高搜索的性能。**\r\n\r\n### 类型Type\r\n\r\n在一个索引中，你可以定义一种或多种类型。\r\n\r\n一个类型是你的索引的一个逻辑上的分类/分区，其语义完全由你来定。通常，会为具\r\n有一组共同字段的文档定义一个类型。不同的版本，类型发生了不同的变化。\r\n\r\n| 版本 | Type                                            |\r\n| ---- | ----------------------------------------------- |\r\n| 5.x  | 支持多种 type                                   |\r\n| 6.x  | 只能有一种 type                                 |\r\n| 7.x  | 默认不再支持自定义索引类型（默认类型为： _doc） |\r\n\r\n### 文档Document\r\n\r\n一个文档是一个可被索引的基础信息单元，也就是一条数据。\r\n\r\n比如：你可以拥有某一个客户的文档，某一个产品的一个文档，当然，也可以拥有某个订单的一个文档。文档以JSON（Javascript Object Notation）格式来表示，而JSON是一个到处存在的互联网数据交互格式。\r\n\r\n在一个index/type里面，你可以存储任意多的文档。\r\n\r\n### 字段Field\r\n\r\n相当于是数据表的字段，对文档数据根据不同属性进行的分类标识。\r\n\r\n### 映射Mapping\r\n\r\nmapping是处理数据的方式和规则方面做一些限制，如：某个字段的数据类型、默认值、分析器、是否被索引等等。这些都是映射里面可以设置的，其它就是处理ES里面数据的一些使用规则设置也叫做映射，按着最优规则处理数据对性能提高很大，因此才需要建立映射，并且需要思考如何建立映射才能对性能更好。\r\n\r\n### 分片Shards\r\n\r\n一个索引可以存储超出单个节点硬件限制的大量数据。比如，一个具有10亿文档数据\r\n的索引占据1TB的磁盘空间，而任一节点都可能没有这样大的磁盘空间。或者单个节点处理搜索请求，响应太慢。为了解决这个问题，**Elasticsearch提供了将索引划分成多份的能力，每一份就称之为分片。**当你创建一个索引的时候，你可以指定你想要的分片的数量。**每个分片本身也是一个功能完善并且独立的“索引”**，这个“索引”可以被放置到集群中的任何节点上。\r\n\r\n分片很重要，主要有两方面的原因：\r\n\r\n1. 允许你水平分割/扩展你的内容容量。\r\n2. 允许你在分片之上进行分布式的、并行的操作，进而提高性能/吞吐量。\r\n\r\n至于一个分片怎样分布，它的文档怎样聚合和搜索请求，是完全由Elasticsearch管理的，对于作为用户的你来说，这些都是透明的，无需过分关心。\r\n\r\n被混淆的概念是，一个Lucene索引我们在Elasticsearch称作分片。一个Elasticsearch索引是分片的集合。当Elasticsearch在索引中搜索的时候，他发送查询到每一个属于索引的分片（Lucene索引），然后合并每个分片的结果到一个全局的结果集。\r\n\r\nLucene是Apache软件基金会Jakarta项目组的一个子项目，提供了一个简单却强大的应用程式接口，能够做全文索引和搜寻。在Java开发环境里Lucene是一个成熟的免费开源工具。就其本身而言，Lucene是当前以及最近几年最受欢迎的免费Java信息检索程序库。但Lucene只是一个提供全文搜索功能类库的核心工具包，而真正使用它还需要一个完善的服务框架搭建起来进行应用。\r\n\r\n目前市面上流行的搜索引擎软件，主流的就两款：Elasticsearch和Solr,这两款都是基于Lucene搭建的，可以独立部署启动的搜索引擎服务软件。由于内核相同，所以两者除了服务器安装、部署、管理、集群以外，对于数据的操作修改、添加、保存、查询等等都十分类似。\r\n\r\n### 副本Replicas\r\n\r\n在一个网络/云的环境里，失败随时都可能发生，在某个分片/节点不知怎么的就处于\r\n离线状态，或者由于任何原因消失了，这种情况下，有一个故障转移机制是非常有用并且是强烈推荐的。为此目的，Elasticsearch允许你创建分片的一份或多份拷贝，这些拷贝叫做复制分片(副本)。\r\n\r\n复制分片之所以重要，有两个主要原因：\r\n\r\n- 在分片/节点失败的情况下，**提供了高可用性**。因为这个原因，注意到复制分片从不与原/主要（original/primary）分片置于同一节点上是非常重要的。\r\n- 扩展你的搜索量/吞吐量，因为搜索可以在所有的副本上并行运行。\r\n\r\n总之，每个索引可以被分成多个分片。一个索引也可以被复制0次（意思是没有复制）或多次。一旦复制了，每个索引就有了主分片（作为复制源的原来的分片）和复制分片（主分片的拷贝）之别。\r\n\r\n分片和复制的数量可以在索引创建的时候指定。在索引创建之后，你可以在任何时候动态地改变复制的数量，但是你事后不能改变分片的数量。\r\n\r\n默认情况下，Elasticsearch中的每个索引被分片1个主分片和1个复制，这意味着，如果你的集群中至少有两个节点，你的索引将会有1个主分片和另外1个复制分片（1个完全拷贝），这样的话每个索引总共就有2个分片，我们需要根据索引需要确定分片个数。\r\n\r\n### 分配Allocation\r\n\r\n将分片分配给某个节点的过程，包括分配主分片或者副本。如果是副本，还包含从主分片复制数据的过程。这个过程是由master节点完成的。\r\n\r\n## 34-进阶-系统架构-简介\r\n\r\n![img](https://img-blog.csdnimg.cn/img_convert/e4d13427545dc174eb9ccface85c1f0c.png)\r\n\r\n一个运行中的Elasticsearch实例称为一个节点，而集群是由一个或者多个拥有相同\r\ncluster.name配置的节点组成，它们共同承担数据和负载的压力。当有节点加入集群中或者从集群中移除节点时，集群将会重新平均分布所有的数据。\r\n\r\n当一个节点被选举成为主节点时，它将负责管理集群范围内的所有变更，例如增加、\r\n删除索引，或者增加、删除节点等。而主节点并不需要涉及到文档级别的变更和搜索等操作，所以当集群只拥有一个主节点的情况下，即使流量的增加它也不会成为瓶颈。任何节点都可以成为主节点。我们的示例集群就只有一个节点，所以它同时也成为了主节点。\r\n\r\n作为用户，我们可以将请求发送到集群中的任何节点，包括主节点。每个节点都知道\r\n任意文档所处的位置，并且能够将我们的请求直接转发到存储我们所需文档的节点。无论我们将请求发送到哪个节点，它都能负责从各个包含我们所需文档的节点收集回数据，并将最终结果返回給客户端。Elasticsearch对这一切的管理都是透明的。\r\n\r\n## 35-进阶-单节点集群\r\n\r\n我们在包含一个空节点的集群内创建名为users的索引，为了演示目的，我们将分配3个主分片和一份副本（每个主分片拥有一个副本分片）。\r\n\r\n```json\r\n#PUT http://127.0.0.1:1001/users\r\n{\r\n    \"settings\" : {\r\n        \"number_of_shards\" : 3,\r\n        \"number_of_replicas\" : 1\r\n    }\r\n}\r\n\r\n```\r\n\r\n集群现在是拥有一个索引的单节点集群。所有3个主分片都被分配在node-1。\r\n\r\n![img](https://img-blog.csdnimg.cn/img_convert/54ee6753be248cc7d345b38a0eae7d96.png)\r\n\r\n通过elasticsearch-head插件（一个Chrome插件）查看集群情况。\r\n\r\n![img](https://img-blog.csdnimg.cn/img_convert/e8b15d0b243d486e91f478a220da63bf.png)\r\n\r\n- 集群健康值:yellow(3of6)：表示当前集群的全部主分片都正常运行，但是副本分片没有全部处在正常状态。\r\n- ![img](https://img-blog.csdnimg.cn/img_convert/489b6de480112879a00067b793bde685.png)：3个主分片正常。\r\n- ![img](https://img-blog.csdnimg.cn/img_convert/3ce9a78d26ee762f0a7a8abf7817a58e.png)：3个副本分片都是Unassigned，它们都没有被分配到任何节点。在同一个节点上既保存原始数据又保存副本是没有意义的，因为一旦失去了那个节点，我们也将丢失该节点上的所有副本数据。\r\n\r\n当前集群是正常运行的，但存在丢失数据的风险。\r\n\r\n------\r\n\r\n**elasticsearch-head chrome插件安装**\r\n\r\n[插件获取网址](https://github.com/mobz/elasticsearch-head)，下载压缩包，解压后将内容放入自定义命名为elasticsearch-head文件夹。\r\n\r\n接着点击Chrome右上角选项->工具->管理扩展（或则地址栏输入chrome://extensions/），选择打开“开发者模式”，让后点击“加载已解压得扩展程序”，选择elasticsearch-head/_site，即可完成chrome插件安装。\r\n\r\n\r\n## 36-进阶-故障转移\r\n\r\n当集群中只有一个节点在运行时，意味着会有一个单点故障问题——没有冗余。幸运的是，我们只需再启动一个节点即可防止数据丢失。当你在同一台机器上启动了第二个节点时，只要它和第一个节点有同样的cluster.name配置，它就会自动发现集群并加入到其中。但是在不同机器上启动节点的时候，为了加入到同一集群，你需要配置一个可连接到的单播主机列表。之所以配置为使用单播发现，以防止节点无意中加入集群。只有在同一台机器上\r\n运行的节点才会自动组成集群。\r\n\r\n如果启动了第二个节点，集群将会拥有两个节点:所有主分片和副本分片都已被分配。\r\n\r\n![img](https://img-blog.csdnimg.cn/img_convert/bf76cb1bfbdf07555918d9055817ab44.png)\r\n\r\n通过elasticsearch-head插件查看集群情况\r\n\r\n![img](https://img-blog.csdnimg.cn/img_convert/18db400822b83e727d6206f486b7b2ea.png)\r\n\r\n- 集群健康值:green(3of6)：表示所有6个分片（包括3个主分片和3个副本分片）都在正常运行。\r\n- ![img](https://img-blog.csdnimg.cn/img_convert/e485d8263a4aa3a94af0be951bd5a241.png)：3个主分片正常。\r\n- ![img](https://img-blog.csdnimg.cn/img_convert/e485d8263a4aa3a94af0be951bd5a241.png)：第二个节点加入到集群后，3个副本分片将会分配到这个节点上——每个主分片对应一个副本分片。这意味着当集群内任何一个节点出现问题时，我们的数据都完好无损。所有新近被索引的文档都将会保存在主分片上，然后被并行的复制到对应的副本分片上。这就保证了我们既可以从主分片又可以从副本分片上获得文档。\r\n\r\n## 37-进阶-水平扩容\r\n\r\n怎样为我们的正在增长中的应用程序按需扩容呢？当启动了第三个节点，我们的集群将会拥有三个节点的集群:为了分散负载而对分片进行重新分配。\r\n\r\n![img](https://img-blog.csdnimg.cn/img_convert/d527e26aa2bccdf54b11410024eadc92.png)\r\n\r\n通过elasticsearch-head插件查看集群情况。\r\n\r\n![img](https://img-blog.csdnimg.cn/img_convert/6985fe14454c1269204478320d089bd7.png)\r\n\r\n- 集群健康值:green(3of6)：表示所有6个分片（包括3个主分片和3个副本分片）都在正常运行。\r\n- ![img](https://img-blog.csdnimg.cn/img_convert/9494419153adb44bedb395ac5d7bc488.png)Node1和Node2上各有一个分片被迁移到了新的Node3节点，现在每个节点上都拥有2个分片，而不是之前的3个。这表示每个节点的硬件资源（CPU,RAM,I/O）将被更少的分片所共享，每个分片的性能将会得到提升。\r\n\r\n分片是一个功能完整的搜索引擎，它拥有使用一个节点上的所有资源的能力。我们这个拥有6个分片（3个主分片和3个副本分片）的索引可以最大扩容到6个节点，每个节点上存在一个分片，并且每个分片拥有所在节点的全部资源。\r\n\r\n**但是如果我们想要扩容超过6个节点怎么办呢？**\r\n\r\n主分片的数目在索引创建时就已经确定了下来。实际上，这个数目定义了这个索引能够\r\n存储 的最大数据量。（实际大小取决于你的数据、硬件和使用场景。）但是，读操作——\r\n搜索和返回数据——可以同时被主分片或副本分片所处理，所以当你拥有越多的副本分片\r\n时，也将拥有越高的吞吐量。\r\n\r\n在运行中的集群上是可以动态调整副本分片数目的，我们可以按需伸缩集群。让我们把\r\n副本数从默认的1增加到2。\r\n\r\n```json\r\n#PUT http://127.0.0.1:1001/users/_settings\r\n\r\n{\r\n    \"number_of_replicas\" : 2\r\n}\r\n\r\n```\r\n\r\nusers索引现在拥有9个分片：3个主分片和6个副本分片。这意味着我们可以将集群\r\n扩容到9个节点，每个节点上一个分片。相比原来3个节点时，集群搜索性能可以提升3倍。\r\n\r\n![img](https://img-blog.csdnimg.cn/img_convert/97fd01e34e5d8df23d226c4fef157801.png)\r\n\r\n通过elasticsearch-head插件查看集群情况：\r\n\r\n![img](https://img-blog.csdnimg.cn/img_convert/8bf9dbf0cec5b7875bf8aa9d17a9a67c.png)\r\n\r\n当然，如果只是在相同节点数目的集群上增加更多的副本分片并不能提高性能，因为每\r\n个分片从节点上获得的资源会变少。你需要增加更多的硬件资源来提升吞吐量。\r\n\r\n但是更多的副本分片数提高了数据冗余量：按照上面的节点配置，我们可以在失去 2 个节点\r\n的情况下不丢失任何数据。\r\n\r\n## 38-进阶-应对故障\r\n\r\n我们关闭第一个节点，这时集群的状态为:关闭了一个节点后的集群。\r\n\r\n![img](https://img-blog.csdnimg.cn/img_convert/44e841004be934e6bce08187ca3852bb.png)\r\n\r\n我们关闭的节点是一个主节点。而集群必须拥有一个主节点来保证正常工作，所以发生\r\n的第一件事情就是选举一个新的主节点：Node2。在我们关闭Node1的同时也失去了主\r\n分片1和2，并且在缺失主分片的时候索引也不能正常工作。如果此时来检查集群的状况，我们看到的状态将会为red：不是所有主分片都在正常工作。\r\n\r\n幸运的是，在其它节点上存在着这两个主分片的完整副本，所以新的主节点立即将这些分片在Node2和Node3上对应的副本分片提升为主分片，此时集群的状态将会为yellow。这个提升主分片的过程是瞬间发生的，如同按下一个开关一般。\r\n\r\n![img](https://img-blog.csdnimg.cn/img_convert/e956bda7e0d005699e27760d4193d101.png)\r\n\r\n**为什么我们集群状态是yellow而不是green呢？**\r\n\r\n虽然我们拥有所有的三个主分片，但是同时设置了每个主分片需要对应2份副本分片，而此\r\n时只存在一份副本分片。所以集群不能为green的状态，不过我们不必过于担心：如果我\r\n们同样关闭了Node2，我们的程序依然可以保持在不丢任何数据的情况下运行，因为\r\nNode3为每一个分片都保留着一份副本。\r\n\r\n如果想回复原来的样子，要确保Node-1的配置文件有如下配置：\r\n\r\n```yaml\r\ndiscovery.seed_hosts: [\"localhost:9302\", \"localhost:9303\"]\r\n\r\n```\r\n\r\n集群可以将缺失的副本分片再次进行分配，那么集群的状态也将恢复成之前的状态。如果Node1依然拥有着之前的分片，它将尝试去重用它们，同时仅从主分片复制发生了修改的数据文件。和之前的集群相比，只是Master节点切换了。\r\n\r\n![img](https://img-blog.csdnimg.cn/img_convert/37eea6a8dae7ba908312f2ebf0eced11.png)\r\n\r\n## 39-进阶-路由计算 & 分片控制\r\n\r\n### 路由计算\r\n\r\n当索引一个文档的时候，文档会被存储到一个主分片中。Elasticsearch如何知道一个\r\n文档应该存放到哪个分片中呢？当我们创建文档时，它如何决定这个文档应当被存储在分片1还是分片2中呢？首先这肯定不会是随机的，否则将来要获取文档的时候我们就不知道从何处寻找了。实际上，这个过程是根据下面这个公式决定的：\r\n\r\n```\r\nshard = hash(routing) % number_of_primary_shards\r\n\r\n```\r\n\r\nrouting是一个可变值，默认是文档的_id，也可以设置成一个自定义的值。routing通过hash函数生成一个数字，然后这个数字再除以number_of_primary_shards（主分片的数量）后得到余数。这个分布在0到number_of_primary_shards-1之间的余数，就是我们所寻求的文档所在分片的位置。\r\n\r\n![img](https://img-blog.csdnimg.cn/img_convert/9c34e8603887c2bed475416e3b67cd9a.png)\r\n\r\n这就解释了为什么我们要在创建索引的时候就确定好主分片的数量并且永远不会改变这个数量:因为如果数量变化了，那么所有之前路由的值都会无效，文档也再也找不到了。\r\n\r\n所有的文档API(get.index.delete、bulk,update以及mget）都接受一个叫做routing的路由参数，通过这个参数我们可以自定义文档到分片的映射。一个自定义的路由参数可以用来确保所有相关的文档—一例如所有属于同一个用户的文档——都被存储到同一个分片中。\r\n\r\n### 分片控制\r\n\r\n我们可以发送请求到集群中的任一节点。每个节点都有能力处理任意请求。每个节点都知道集群中任一文档位置，所以可以直接将请求转发到需要的节点上。在下面的例子中，如果将所有的请求发送到Node 1001，我们将其称为协调节点**coordinating node**。\r\n\r\n![img](https://img-blog.csdnimg.cn/img_convert/3940d6cdb197259368542b86384911a4.png)\r\n\r\n当发送请求的时候，为了扩展负载，更好的做法是轮询集群中所有的节点。\r\n\r\n## 40-进阶-数据写流程\r\n\r\n新建、索引和删除请求都是写操作，必须在主分片上面完成之后才能被复制到相关的副本分片。\r\n\r\n![img](https://img-blog.csdnimg.cn/img_convert/418356a32516c222a8d366df021276c2.png)\r\n\r\n在客户端收到成功响应时，文档变更已经在主分片和所有副本分片执行完成，变更是安全的。有一些可选的**请求参数**允许您影响这个过程，可能以数据安全为代价提升性能。这些选项很少使用，因为Elasticsearch已经很快，但是为了完整起见，请参考下文：\r\n\r\n1. consistency\r\n\r\n- 即一致性。在默认设置下，即使仅仅是在试图执行一个写操作之前，主分片都会要求必须要有规定数量quorum（或者换种说法，也即必须要有大多数）的分片副本处于活跃可用状态，才会去执行写操作（其中分片副本可以是主分片或者副本分片）。这是为了避免在发生网络分区故障（network partition）的时候进行写操作，进而导致数据不一致。规定数量即：**int((primary+number_of_replicas)/2)+1**\r\n- consistency参数的值可以设为：\r\n  - one：只要主分片状态ok就允许执行写操作。\r\n  - all：必须要主分片和所有副本分片的状态没问题才允许执行写操作。\r\n  - quorum：默认值为quorum,即大多数的分片副本状态没问题就允许执行写操作。\r\n- 注意，规定数量的计算公式中number_of_replicas指的是在索引设置中的设定副本分片数，而不是指当前处理活动状态的副本分片数。如果你的索引设置中指定了当前索引拥有3个副本分片，那规定数量的计算结果即：**int((1 primary + 3 replicas) / 2) + 1 = 3**，如果此时你只启动两个节点，那么处于活跃状态的分片副本数量就达不到规定数量，也因此您将无法索引和删除任何文档。\r\n\r\n1. timeout\r\n   - 如果没有足够的副本分片会发生什么？Elasticsearch会等待，希望更多的分片出现。默认情况下，它最多等待1分钟。如果你需要，你可以使用timeout参数使它更早终止：100是100毫秒，30s是30秒。\r\n\r\n新索引默认有1个副本分片，这意味着为满足规定数量应该需要两个活动的分片副本。但是，这些默认的设置会阻止我们在单一节点上做任何事情。为了避免这个问题，要求只有当number_of_replicas大于1的时候，规定数量才会执行。\r\n\r\n## 41-进阶-数据读流程\r\n\r\n![img](https://img-blog.csdnimg.cn/img_convert/7139df83ee6f7a59c5d3252d34cc8762.png)\r\n\r\n在处理读取请求时，协调结点在每次请求的时候都会通过轮询所有的副本分片来达到负载均衡。在文档被检索时，已经被索引的文档可能已经存在于主分片上但是还没有复制到副本分片。在这种情况下，副本分片可能会报告文档不存在，但是主分片可能成功返回文档。一旦索引请求成功返回给用户，文档在主分片和副本分片都是可用的。\r\n\r\n## 42-进阶-更新流程 & 批量操作流程\r\n\r\n### 更新流程\r\n\r\n部分更新一个文档结合了先前说明的读取和写入流程：\r\n\r\n![img](https://img-blog.csdnimg.cn/img_convert/ca41993144aee98311671278725437cd.png)\r\n\r\n部分更新一个文档的步骤如下：\r\n\r\n1. 客户端向Node 1发送更新请求。\r\n2. 它将请求转发到主分片所在的Node 3。\r\n3. Node 3从主分片检索文档，修改_source字段中的JSON，并且尝试重新索引主分片的文档。如果文档已经被另一个进程修改,它会重试步骤3,超过retry_on_conflict次后放弃。\r\n4. 如果Node 3成功地更新文档，它将新版本的文档并行转发到Node1和Node2上的副本分片，重新建立索引。一旦所有副本分片都返回成功，Node3向协调节点也返回成功，协调节点向客户端返回成功。\r\n\r\n当主分片把更改转发到副本分片时，它不会转发更新请求。相反，它转发完整文档的新版本。请记住，这些更改将会异步转发到副本分片，并且不能保证它们以发送它们相同的顺序到达。如果Elasticsearch仅转发更改请求，则可能以错误的顺序应用更改，导致得到损坏的文档。\r\n\r\n### 批量操作流程\r\n\r\n**mget和bulkAPI的模式类似于单文档模式。**区别在于协调节点知道每个文档存在于哪个分片中。它将整个多文档请求分解成每个分片的多文档请求，并且将这些请求并行转发到每个参与节点。\r\n\r\n协调节点一旦收到来自每个节点的应答，就将每个节点的响应收集整理成单个响应，返回给客户端。\r\n\r\n![img](https://img-blog.csdnimg.cn/img_convert/b90ea9c79138d8361ca339cff205fdb0.png)\r\n\r\n**用单个 mget 请求取回多个文档所需的步骤顺序:**\r\n\r\n1. 客户端向Node1发送mget请求。\r\n2. Node1为每个分片构建多文档获取请求，然后并行转发这些请求到托管在每个所需的主分片或者副本分片的节点上。一旦收到所有答复，Node1构建响应并将其返回给客户端。\r\n\r\n可以对docs数组中每个文档设置routing参数。\r\n\r\nbulk API，允许在单个批量请求中执行多个创建、索引、删除和更新请求。\r\n\r\n![img](https://img-blog.csdnimg.cn/img_convert/83499315a7b8ab81471a88f3e142f0a8.png)\r\n\r\n**bulk API按如下步骤顺序执行：**\r\n\r\n1. 客户端向Node1发送bulk请求。\r\n2. Node 1为每个节点创建一个批量请求，并将这些请求并行转发到每个包含主分片的节点主机。\r\n3. 主分片一个接一个按顺序执行每个操作。当每个操作成功时,主分片并行转发新文档（或删除）到副本分片，然后执行下一个操作。一旦所有的副本分片报告所有操作成功，该节点将向协调节点报告成功，协调节点将这些响应收集整理并返回给客户端。\r\n\r\n## 43-进阶-倒排索引\r\n\r\n分片是Elasticsearch最小的工作单元。但是究竟什么是一个分片，它是如何工作的？\r\n\r\n传统的数据库每个字段存储单个值，但这对全文检索并不够。文本字段中的每个单词需要被搜索，对数据库意味着需要单个字段有索引多值的能力。最好的支持是一个字段多个值需求的数据结构是**倒排索引**。\r\n\r\n### 倒排索引原理\r\n\r\nElasticsearch使用一种称为倒排索引的结构，它适用于快速的全文搜索。\r\n\r\n见其名，知其意，有倒排索引，肯定会对应有正向索引。正向索引（forward index），反向索引（inverted index）更熟悉的名字是**倒排索引**。\r\n\r\n所谓的**正向索引**，就是搜索引擎会将待搜索的文件都对应一个文件ID，搜索时将这个ID和搜索关键字进行对应，形成K-V对，然后对关键字进行统计计数。（统计？？下文有解释）\r\n\r\n![img](https://img-blog.csdnimg.cn/img_convert/cba02cc6d7c5f054dfe5d58fafac9a6a.png)\r\n\r\n但是互联网上收录在搜索引擎中的文档的数目是个天文数字，这样的索引结构根本无法满足实时返回排名结果的要求。所以，搜索引擎会将正向索引重新构建为倒排索引，即把文件ID对应到关键词的映射转换为关键词到文件ID的映射，每个关键词都对应着一系列的文件，这些文件中都出现这个关键词。\r\n\r\n![img](https://img-blog.csdnimg.cn/img_convert/a1f52e96e0ac218b5024d708202afba4.png)\r\n\r\n### 倒排索引的例子\r\n\r\n一个倒排索引由文档中所有不重复词的列表构成，对于其中每个词，有一个包含它的文档列表。例如，假设我们有两个文档，每个文档的content域包含如下内容：\r\n\r\n- The quick brown fox jumped over the lazy dog\r\n- Quick brown foxes leap over lazy dogs in summer\r\n\r\n为了创建倒排索引，我们首先将每个文档的content域拆分成单独的词（我们称它为词条或tokens)，创建一个包含所有不重复词条的排序列表，然后列出每个词条出现在哪个文档。结果如下所示：\r\n\r\n![img](https://img-blog.csdnimg.cn/img_convert/3cc642e9bae776c3e617f9d117d41e21.png)\r\n\r\n现在，如果我们想搜索`quick` `brown`，我们只需要查找包含每个词条的文档：\r\n\r\n![img](https://img-blog.csdnimg.cn/img_convert/f26aaa01e011edfa68736956b2f1ddea.png)\r\n\r\n两个文档都匹配，但是第一个文档比第二个匹配度更高。如果我们使用仅计算匹配词条数量的简单相似性算法，那么我们可以说，对于我们查询的相关性来讲，第一个文档比第二个文档更佳。\r\n\r\n但是，我们目前的倒排索引有一些问题：\r\n\r\n- `Quick`和`quick`以独立的词条出现，然而用户可能认为它们是相同的词。\r\n- `fox`和`foxes`非常相似，就像`dog`和`dogs`；他们有相同的词根。\r\n- `jumped`和`leap`，尽管没有相同的词根，但他们的意思很相近。他们是同义词。\r\n\r\n使用前面的索引搜索`+Quick` `+fox`不会得到任何匹配文档。(记住，＋前缀表明这个词必须存在）。\r\n\r\n只有同时出现`Quick`和`fox` 的文档才满足这个查询条件，但是第一个文档包含`quick` `fox` ，第二个文档包含`Quick` `foxes` 。\r\n\r\n我们的用户可以合理的期望两个文档与查询匹配。我们可以做的更好。\r\n\r\n如果我们将词条规范为标准模式，那么我们可以找到与用户搜索的词条不完全一致，但具有足够相关性的文档。例如：\r\n\r\n- `Quick`可以小写化为`quick`。\r\n- `foxes`可以词干提取变为词根的格式为`fox`。类似的，`dogs`可以为提取为`dog`。\r\n- `jumped`和`leap`是同义词，可以索引为相同的单词`jump` 。\r\n\r\n现在索引看上去像这样：\r\n\r\n![img](https://img-blog.csdnimg.cn/img_convert/19813d1918c89461303377444cf85c8c.png)\r\n\r\n这还远远不够。我们搜索`+Quick` `+fox` 仍然会失败，因为在我们的索引中，已经没有`Quick`了。但是，如果我们对搜索的字符串使用与content域相同的标准化规则，会变成查询`+quick` `+fox`，这样两个文档都会匹配！分词和标准化的过程称为**分析**，这非常重要。你只能搜索在索引中出现的词条，所以索引文本和查询字符串必须标准化为相同的格式。\r\n\r\n## 44-进阶-文档搜索\r\n\r\n### 不可改变的倒排索引\r\n\r\n早期的全文检索会为整个文档集合建立一个很大的倒排索引并将其写入到磁盘。一旦新的索引就绪，旧的就会被其替换，这样最近的变化便可以被检索到。\r\n\r\n倒排索引被写入磁盘后是不可改变的：它永远不会修改。\r\n\r\n- 不需要锁。如果你从来不更新索引，你就不需要担心多进程同时修改数据的问题。\r\n- 一旦索引被读入内核的文件系统缓存，便会留在哪里，由于其不变性。只要文件系统缓存中还有足够的空间，那么大部分读请求会直接请求内存，而不会命中磁盘。这提供了很大的性能提升。\r\n- 其它缓存(像filter缓存)，在索引的生命周期内始终有效。它们不需要在每次数据改变时被重建，因为数据不会变化。\r\n- 写入单个大的倒排索引允许数据被压缩，减少磁盘IO和需要被缓存到内存的索引的使用量。\r\n\r\n当然，一个不变的索引也有不好的地方。主要事实是它是不可变的!你不能修改它。如果你需要让一个新的文档可被搜索，你需要重建整个索引。这要么对一个索引所能包含的数据量造成了很大的限制，要么对索引可被更新的频率造成了很大的限制。\r\n\r\n### 动态更新索引\r\n\r\n如何在保留不变性的前提下实现倒排索引的更新？\r\n\r\n答案是：用更多的索引。通过增加新的补充索引来反映新近的修改，而不是直接重写整个倒排索引。每一个倒排索引都会被轮流查询到,从最早的开始查询完后再对结果进行合并。\r\n\r\nElasticsearch基于Lucene，这个java库引入了**按段搜索**的概念。每一段本身都是一个倒排索引，但索引在Lucene中除表示所有段的集合外，还增加了提交点的概念—一个列出了所有已知段的文件。\r\n\r\n![img](https://img-blog.csdnimg.cn/img_convert/9ee1adbb2d55e710257e01b812a6d8cf.png)\r\n\r\n按段搜索会以如下流程执行：\r\n\r\n一、新文档被收集到内存索引缓存。\r\n\r\n![img](https://img-blog.csdnimg.cn/img_convert/9d499fde966ee9825fa5a424d8357489.png)\r\n\r\n二、不时地,缓存被提交。\r\n\r\n1. 一个新的段，一个追加的倒排索引，被写入磁盘。\r\n2. 一个新的包含新段名字的提交点被写入磁盘。\r\n3. 磁盘进行同步，所有在文件系统缓存中等待的写入都刷新到磁盘，以确保它们被写入物理文件\r\n\r\n三、新的段被开启，让它包含的文档可见以被搜索。\r\n\r\n四、内存缓存被清空，等待接收新的文档。\r\n\r\n![img](https://img-blog.csdnimg.cn/img_convert/f74828ff58cc4635a97e88706a221e50.png)\r\n\r\n当一个查询被触发，所有已知的段按顺序被查询。词项统计会对所有段的结果进行聚合，以保证每个词和每个文档的关联都被准确计算。这种方式可以用相对较低的成本将新文档添加到索引。\r\n\r\n段是不可改变的，所以既不能从把文档从旧的段中移除，也不能修改旧的段来进行反映文档的更新。取而代之的是，每个提交点会包含一个.del文件，文件中会列出这些被删除文档的段信息。\r\n\r\n当一个**文档被“删除”**时，它实际上只是在.del文件中被标记删除。一个被标记删除的文档仍然可以被查询匹配到，但它会在最终结果被返回前从结果集中移除。\r\n\r\n**文档更新**也是类似的操作方式:当一个文档被更新时，旧版本文档被标记删除，文档的新版本被索引到一个新的段中。可能两个版本的文档都会被一个查询匹配到，但被删除的那个旧版本文档在结果集返回前就已经被移除。\r\n\r\n## 45-进阶-文档刷新 & 文档刷写 & 文档合并\r\n\r\n![img](https://img-blog.csdnimg.cn/img_convert/b3b31c1e592d5aa794e7c9fcb259c924.png)\r\n\r\n![img](https://img-blog.csdnimg.cn/img_convert/521c25f0f16247240234d1b8eb3c5f25.png)\r\n\r\n### 近实时搜索\r\n\r\n随着按段（per-segment）搜索的发展，一个新的文档从索引到可被搜索的延迟显著降低了。新文档在几分钟之内即可被检索，但这样还是不够快。磁盘在这里成为了瓶颈。**提交（Commiting）一个新的段到磁盘需要一个fsync来确保段被物理性地写入磁盘**，这样在断电的时候就不会丢失数据。但是fsync操作代价很大；如果每次索引一个文档都去执行一次的话会造成很大的性能问题。\r\n\r\n我们需要的是一个更轻量的方式来使一个文档可被搜索，这意味着fsync要从整个过程中被移除。在Elasticsearch和磁盘之间是**文件系统缓存**。像之前描述的一样，在内存索引缓冲区中的文档会被写入到一个新的段中。但是这里新段会被先写入到文件系统缓存—这一步代价会比较低，稍后再被刷新到磁盘—这一步代价比较高。不过只要文件已经在缓存中，就可以像其它文件一样被打开和读取了。\r\n\r\n![img](https://img-blog.csdnimg.cn/img_convert/a679d4f5f4bfa6913a53316251beef2a.png)\r\n\r\nLucene允许新段被写入和打开，使其包含的文档在未进行一次完整提交时便对搜索可见。这种方式比进行一次提交代价要小得多，并且在不影响性能的前提下可以被频繁地执行。\r\n\r\n![img](https://img-blog.csdnimg.cn/img_convert/673d3a77e254fa3a5a6f5293ffb125ab.png)\r\n\r\n在Elasticsearch中，写入和打开一个新段的轻量的过程叫做refresh。默认情况下每个分片会每秒自动刷新一次。这就是为什么我们说Elasticsearch是近实时搜索：文档的变化并不是立即对搜索可见，但会在一秒之内变为可见。\r\n\r\n这些行为可能会对新用户造成困惑：他们索引了一个文档然后尝试搜索它，但却没有搜到。这个问题的解决办法是用refresh API执行一次手动刷新：/usersl_refresh\r\n\r\n尽管刷新是比提交轻量很多的操作，它还是会有性能开销。当写测试的时候，手动刷新很有用，但是不要在生产环境下每次索引一个文档都去手动刷新。相反，你的应用需要意识到Elasticsearch 的近实时的性质，并接受它的不足。\r\n\r\n并不是所有的情况都需要每秒刷新。可能你正在使用Elasticsearch索引大量的日志文件，你可能想优化索引速度而不是近实时搜索，可以通过设置refresh_interval，降低每个索引的刷新频率\r\n\r\n```json\r\n{\r\n    \"settings\": {\r\n    \t\"refresh_interval\": \"30s\"\r\n    }\r\n}\r\n\r\n```\r\n\r\nrefresh_interval可以在既存索引上进行动态更新。在生产环境中，当你正在建立一个大的新索引时，可以先关闭自动刷新，待开始使用该索引时，再把它们调回来。\r\n\r\n```\r\n# 关闭自动刷新\r\nPUT /users/_settings\r\n{ \"refresh_interval\": -1 }\r\n\r\n# 每一秒刷新\r\nPUT /users/_settings\r\n{ \"refresh_interval\": \"1s\" }\r\n\r\n```\r\n\r\n### 持久化变更\r\n\r\n如果没有用fsync把数据从文件系统缓存刷（flush）到硬盘，我们不能保证数据在断电甚至是程序正常退出之后依然存在。为了保证Elasticsearch的可靠性，需要确保数据变化被持久化到磁盘。在动态更新索引，我们说一次完整的提交会将段刷到磁盘，并写入一个包含所有段列表的提交点。Elasticsearch在启动或重新打开一个索引的过程中使用这个提交点来判断哪些段隶属于当前分片。\r\n\r\n即使通过每秒刷新(refresh）实现了近实时搜索，我们仍然需要经常进行完整提交来确保能从失败中恢复。但在两次提交之间发生变化的文档怎么办?我们也不希望丢失掉这些数据。Elasticsearch增加了一个translog，或者叫事务日志，在每一次对Elasticsearch进行操作时均进行了日志记录。\r\n\r\n整个流程如下:\r\n\r\n一、一个文档被索引之后，就会被添加到内存缓冲区，并且追加到了translog\r\n\r\n![img](https://img-blog.csdnimg.cn/img_convert/baeab48c8d6b87660ac4fb954e9c9731.png)\r\n\r\n二、刷新（refresh）使分片每秒被刷新（refresh）一次：\r\n\r\n- 这些在内存缓冲区的文档被写入到一个新的段中，且没有进行fsync操作。\r\n- 这个段被打开，使其可被搜索。\r\n- 内存缓冲区被清空。\r\n\r\n![img](https://img-blog.csdnimg.cn/img_convert/17be4247e6b23f31b1e589c70d61e817.png)\r\n\r\n三、这个进程继续工作，更多的文档被添加到内存缓冲区和追加到事务日志。\r\n\r\n![img](https://img-blog.csdnimg.cn/img_convert/4b5c4a3a3ffb4c84625bb283f6a67018.png)\r\n\r\n四、每隔一段时间—例如translog变得越来越大，索引被刷新（flush）；一个新的translog被创建，并且一个全量提交被执行。\r\n\r\n- 所有在内存缓冲区的文档都被写入一个新的段。\r\n- 缓冲区被清空。\r\n- 一个提交点被写入硬盘。\r\n- 文件系统缓存通过fsync被刷新（flush）。\r\n- 老的translog被删除。\r\n\r\ntranslog提供所有还没有被刷到磁盘的操作的一个持久化纪录。当Elasticsearch启动的时候，它会从磁盘中使用最后一个提交点去恢复己知的段，并且会重放translog中所有在最后一次提交后发生的变更操作。\r\n\r\ntranslog也被用来提供实时CRUD。当你试着通过ID查询、更新、删除一个文档，它会在尝试从相应的段中检索之前，首先检查translog任何最近的变更。这意味着它总是能够实时地获取到文档的最新版本。\r\n\r\n![img](https://img-blog.csdnimg.cn/img_convert/11c7d2cc05244e669eb8402dd8049de9.png)\r\n\r\n执行一个提交并且截断translog的行为在Elasticsearch被称作一次flush。分片每30分钟被自动刷新（flush)，或者在translog太大的时候也会刷新。\r\n\r\n你很少需要自己手动执行flush操作，通常情况下，自动刷新就足够了。这就是说，在重启节点或关闭索引之前执行flush有益于你的索引。当Elasticsearch尝试恢复或重新打开一个索引，它需要重放translog中所有的操作，所以如果日志越短，恢复越快。\r\n\r\ntranslog的目的是保证操作不会丢失，在文件被fsync到磁盘前，被写入的文件在重启之后就会丢失。默认translog是每5秒被fsync刷新到硬盘，或者在每次写请求完成之后执行（e.g.index,delete,update,bulk）。这个过程在主分片和复制分片都会发生。最终，基本上，这意味着在整个请求被fsync到主分片和复制分片的translog之前，你的客户端不会得到一个200 OK响应。\r\n\r\n在每次请求后都执行一个fsync会带来一些性能损失，尽管实践表明这种损失相对较小（特别是bulk导入，它在一次请求中平摊了大量文档的开销）。\r\n\r\n但是对于一些大容量的偶尔丢失几秒数据问题也并不严重的集群，使用异步的fsync还是比较有益的。比如，写入的数据被缓存到内存中，再每5秒执行一次fsync。如果你决定使用异步translog的话，你需要保证在发生crash时，丢失掉sync_interval时间段的数据也无所谓。请在决定前知晓这个特性。如果你不确定这个行为的后果，最好是使用默认的参数{“index.translog.durability”:“request”}来避免数据丢失。\r\n\r\n### 段合并\r\n\r\n由于自动刷新流程每秒会创建一个新的段，这样会导致短时间内的段数量暴增。而段数目太多会带来较大的麻烦。每一个段都会消耗文件句柄、内存和cpu运行周期。更重要的是，每个搜索请求都必须轮流检查每个段；所以段越多，搜索也就越慢。\r\n\r\nElasticsearch通过在后台进行段合并来解决这个问题。小的段被合并到大的段，然后这些大的段再被合并到更大的段。\r\n\r\n段合并的时候会将那些旧的已删除文档从文件系统中清除。被删除的文档（或被更新文档的旧版本）不会被拷贝到新的大段中。\r\n\r\n启动段合并不需要你做任何事。进行索引和搜索时会自动进行。\r\n\r\n一、当索引的时候，刷新（refresh）操作会创建新的段并将段打开以供搜索使用。\r\n\r\n二、合并进程选择一小部分大小相似的段，并且在后台将它们合并到更大的段中。这并不会中断索引和搜索。\r\n\r\n![img](https://img-blog.csdnimg.cn/img_convert/c907ca35bd7c0393d46aec2c7038af19.png)\r\n\r\n三、一旦合并结束，老的段被删除\r\n\r\n- 新的段被刷新(flush)到了磁盘。\r\n- 写入一个包含新段且排除旧的和较小的段的新提交点。\r\n- 新的段被打开用来搜索。老的段被删除。\r\n\r\n![img](https://img-blog.csdnimg.cn/img_convert/a00cc1c19652c47fcfb663aaf337a41b.png)\r\n\r\n合并大的段需要消耗大量的I/O和CPU资源，如果任其发展会影响搜索性能。Elasticsearch在默认情况下会对合并流程进行资源限制，所以搜索仍然有足够的资源很好地执行。\r\n\r\n## 46-进阶-文档分析\r\n\r\n分析包含下面的过程：\r\n\r\n- 将一块文本分成适合于倒排索引的独立的词条。\r\n- 将这些词条统一化为标准格式以提高它们的“可搜索性”，或者recall。\r\n\r\n分析器执行上面的工作。分析器实际上是将三个功能封装到了一个包里：\r\n\r\n- 字符过滤器：首先，字符串按顺序通过每个字符过滤器。他们的任务是在分词前整理字符串。一个字符过滤器可以用来去掉HTML，或者将&转化成and。\r\n- 分词器：其次，字符串被分词器分为单个的词条。一个简单的分词器遇到空格和标点的时候，可能会将文本拆分成词条。\r\n- Token过滤器：最后，词条按顺序通过每个token过滤器。这个过程可能会改变词条（例如，小写化Quick），删除词条（例如，像a，and，the等无用词），或者增加词条（例如，像jump和leap这种同义词）\r\n\r\n### 内置分析器\r\n\r\nElasticsearch还附带了可以直接使用的预包装的分析器。接下来我们会列出最重要的分析器。为了证明它们的差异，我们看看每个分析器会从下面的字符串得到哪些词条：\r\n\r\n```\r\n\"Set the shape to semi-transparent by calling set_trans(5)\"\r\n\r\n```\r\n\r\n- 标准分析器\r\n\r\n标准分析器是Elasticsearch默认使用的分析器。它是分析各种语言文本最常用的选择。它根据Unicode 联盟定义的单词边界划分文本。删除绝大部分标点。最后，将词条小写。它会产生：\r\n\r\n```\r\nset, the, shape, to, semi, transparent, by, calling, set_trans, 5\r\n\r\n```\r\n\r\n- 简单分析器\r\n\r\n简单分析器在任何不是字母的地方分隔文本，将词条小写。它会产生：\r\n\r\n```\r\nset, the, shape, to, semi, transparent, by, calling, set, trans\r\n\r\n```\r\n\r\n- 空格分析器\r\n\r\n空格分析器在空格的地方划分文本。它会产生:\r\n\r\n```\r\nSet, the, shape, to, semi-transparent, by, calling, set_trans(5)\r\n\r\n```\r\n\r\n- 语言分析器\r\n\r\n特定语言分析器可用于很多语言。它们可以考虑指定语言的特点。例如，英语分析器附带了一组英语无用词（常用单词，例如and或者the,它们对相关性没有多少影响），它们会被删除。由于理解英语语法的规则，这个分词器可以提取英语单词的词干。\r\n\r\n英语分词器会产生下面的词条：\r\n\r\n```\r\nset, shape, semi, transpar, call, set_tran, 5\r\n\r\n```\r\n\r\n注意看transparent、calling和set_trans已经变为词根格式。\r\n\r\n### 分析器使用场景\r\n\r\n当我们索引一个文档，它的全文域被分析成词条以用来创建倒排索引。但是，当我们在全文域搜索的时候，我们需要将查询字符串通过相同的分析过程，以保证我们搜索的词条格式与索引中的词条格式一致。\r\n\r\n全文查询，理解每个域是如何定义的，因此它们可以做正确的事：\r\n\r\n- 当你查询一个全文域时，会对查询字符串应用相同的分析器，以产生正确的搜索词条列表。\r\n- 当你查询一个精确值域时，不会分析查询字符串，而是搜索你指定的精确值。\r\n\r\n### 测试分析器\r\n\r\n有些时候很难理解分词的过程和实际被存储到索引中的词条，特别是你刚接触Elasticsearch。为了理解发生了什么，你可以使用analyze API来看文本是如何被分析的。在消息体里，指定分析器和要分析的文本。\r\n\r\n```json\r\n#GET http://localhost:9200/_analyze\r\n{\r\n    \"analyzer\": \"standard\",\r\n    \"text\": \"Text to analyze\"\r\n}\r\n\r\n```\r\n\r\n结果中每个元素代表一个单独的词条：\r\n\r\n```json\r\n{\r\n    \"tokens\": [\r\n        {\r\n            \"token\": \"text\", \r\n            \"start_offset\": 0, \r\n            \"end_offset\": 4, \r\n            \"type\": \"<ALPHANUM>\", \r\n            \"position\": 1\r\n        }, \r\n        {\r\n            \"token\": \"to\", \r\n            \"start_offset\": 5, \r\n            \"end_offset\": 7, \r\n            \"type\": \"<ALPHANUM>\", \r\n            \"position\": 2\r\n        }, \r\n        {\r\n            \"token\": \"analyze\", \r\n            \"start_offset\": 8, \r\n            \"end_offset\": 15, \r\n            \"type\": \"<ALPHANUM>\", \r\n            \"position\": 3\r\n        }\r\n    ]\r\n}\r\n\r\n```\r\n\r\n- token是实际存储到索引中的词条。\r\n- start_ offset 和end_ offset指明字符在原始字符串中的位置。\r\n- position指明词条在原始文本中出现的位置。\r\n\r\n### 指定分析器\r\n\r\n当Elasticsearch在你的文档中检测到一个新的字符串域，它会自动设置其为一个全文字符串域，使用标准分析器对它进行分析。你不希望总是这样。可能你想使用一个不同的分析器，适用于你的数据使用的语言。有时候你想要一个字符串域就是一个字符串域，不使用分析，直接索引你传入的精确值，例如用户ID或者一个内部的状态域或标签。要做到这一点，我们必须手动指定这些域的映射。\r\n\r\n（细粒度指定分析器）\r\n\r\n### IK分词器\r\n\r\n首先通过Postman发送GET请求查询分词效果\r\n\r\n```json\r\n# GET http://localhost:9200/_analyze\r\n{\r\n\t\"text\":\"测试单词\"\r\n}\r\n\r\n```\r\n\r\nES 的默认分词器无法识别中文中测试、单词这样的词汇，而是简单的将每个字拆完分为一个词。\r\n\r\n```json\r\n{\r\n    \"tokens\": [\r\n        {\r\n            \"token\": \"测\", \r\n            \"start_offset\": 0, \r\n            \"end_offset\": 1, \r\n            \"type\": \"<IDEOGRAPHIC>\", \r\n            \"position\": 0\r\n        }, \r\n        {\r\n            \"token\": \"试\", \r\n            \"start_offset\": 1, \r\n            \"end_offset\": 2, \r\n            \"type\": \"<IDEOGRAPHIC>\", \r\n            \"position\": 1\r\n        }, \r\n        {\r\n            \"token\": \"单\", \r\n            \"start_offset\": 2, \r\n            \"end_offset\": 3, \r\n            \"type\": \"<IDEOGRAPHIC>\", \r\n            \"position\": 2\r\n        }, \r\n        {\r\n            \"token\": \"词\", \r\n            \"start_offset\": 3, \r\n            \"end_offset\": 4, \r\n            \"type\": \"<IDEOGRAPHIC>\", \r\n            \"position\": 3\r\n        }\r\n    ]\r\n}\r\n\r\n```\r\n\r\n这样的结果显然不符合我们的使用要求，所以我们需要下载ES对应版本的中文分词器。\r\n\r\n[IK中文分词器下载网址](https://github.com/medcl/elasticsearch-analysis-ik/releases/tag/v7.8.0)\r\n\r\n将解压后的后的文件夹放入ES根目录下的plugins目录下，重启ES即可使用。\r\n\r\n我们这次加入新的查询参数\"analyzer\":“ik_max_word”。\r\n\r\n```json\r\n# GET http://localhost:9200/_analyze\r\n{\r\n\t\"text\":\"测试单词\",\r\n\t\"analyzer\":\"ik_max_word\"\r\n}\r\n\r\n```\r\n\r\n- ik_max_word：会将文本做最细粒度的拆分。\r\n- ik_smart：会将文本做最粗粒度的拆分。\r\n\r\n使用中文分词后的结果为：\r\n\r\n```json\r\n{\r\n    \"tokens\": [\r\n        {\r\n            \"token\": \"测试\", \r\n            \"start_offset\": 0, \r\n            \"end_offset\": 2, \r\n            \"type\": \"CN_WORD\", \r\n            \"position\": 0\r\n        }, \r\n        {\r\n            \"token\": \"单词\", \r\n            \"start_offset\": 2, \r\n            \"end_offset\": 4, \r\n            \"type\": \"CN_WORD\", \r\n            \"position\": 1\r\n        }\r\n    ]\r\n}\r\n\r\n```\r\n\r\nES中也可以进行扩展词汇，首先查询\r\n\r\n```json\r\n#GET http://localhost:9200/_analyze\r\n\r\n{\r\n    \"text\":\"弗雷尔卓德\",\r\n    \"analyzer\":\"ik_max_word\"\r\n}\r\n\r\n```\r\n\r\n仅仅可以得到每个字的分词结果，我们需要做的就是使分词器识别到弗雷尔卓德也是一个词语。\r\n\r\n```json\r\n{\r\n    \"tokens\": [\r\n        {\r\n            \"token\": \"弗\",\r\n            \"start_offset\": 0,\r\n            \"end_offset\": 1,\r\n            \"type\": \"CN_CHAR\",\r\n            \"position\": 0\r\n        },\r\n        {\r\n            \"token\": \"雷\",\r\n            \"start_offset\": 1,\r\n            \"end_offset\": 2,\r\n            \"type\": \"CN_CHAR\",\r\n            \"position\": 1\r\n        },\r\n        {\r\n            \"token\": \"尔\",\r\n            \"start_offset\": 2,\r\n            \"end_offset\": 3,\r\n            \"type\": \"CN_CHAR\",\r\n            \"position\": 2\r\n        },\r\n        {\r\n            \"token\": \"卓\",\r\n            \"start_offset\": 3,\r\n            \"end_offset\": 4,\r\n            \"type\": \"CN_CHAR\",\r\n            \"position\": 3\r\n        },\r\n        {\r\n            \"token\": \"德\",\r\n            \"start_offset\": 4,\r\n            \"end_offset\": 5,\r\n            \"type\": \"CN_CHAR\",\r\n            \"position\": 4\r\n        }\r\n    ]\r\n}\r\n\r\n```\r\n\r\n1. 首先进入ES根目录中的plugins文件夹下的ik文件夹，进入config目录，创建custom.dic文件，写入“弗雷尔卓德”。\r\n2. 同时打开IKAnalyzer.cfg.xml文件，将新建的custom.dic配置其中。\r\n3. 重启ES服务器。\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<!DOCTYPE properties SYSTEM \"http://java.sun.com/dtd/properties.dtd\">\r\n<properties>\r\n\t<comment>IK Analyzer扩展配置</comment>\r\n\t<!--用户可以在这里配置自己的扩展字典 -->\r\n\t<entry key=\"ext_dict\">custom.dic</entry>\r\n\t <!--用户可以在这里配置自己的扩展停止词字典-->\r\n\t<entry key=\"ext_stopwords\"></entry>\r\n\t<!--用户可以在这里配置远程扩展字典 -->\r\n\t<!-- <entry key=\"remote_ext_dict\">words_location</entry> -->\r\n\t<!--用户可以在这里配置远程扩展停止词字典-->\r\n\t<!-- <entry key=\"remote_ext_stopwords\">words_location</entry> -->\r\n</properties>\r\n\r\n```\r\n\r\n扩展后再次查询\r\n\r\n```json\r\n# GET http://localhost:9200/_analyze\r\n{\r\n\t\"text\":\"测试单词\",\r\n\t\"analyzer\":\"ik_max_word\"\r\n}\r\n\r\n```\r\n\r\n返回结果如下：\r\n\r\n```json\r\n{\r\n    \"tokens\": [\r\n        {\r\n            \"token\": \"弗雷尔卓德\",\r\n            \"start_offset\": 0,\r\n            \"end_offset\": 5,\r\n            \"type\": \"CN_WORD\",\r\n            \"position\": 0\r\n        }\r\n    ]\r\n}\r\n\r\n```\r\n\r\n### 自定义分析器\r\n\r\n虽然Elasticsearch带有一些现成的分析器，然而在分析器上Elasticsearch真正的强大之处在于，你可以通过在一个适合你的特定数据的设置之中组合字符过滤器、分词器、词汇单元过滤器来创建自定义的分析器。在分析与分析器我们说过，一个分析器就是在一个包里面组合了三种函数的一个包装器，三种函数按照顺序被执行：\r\n\r\n#### 字符过滤器\r\n\r\n字符过滤器用来整理一个尚未被分词的字符串。例如，如果我们的文本是HTML格式的，它会包含像`<p>`或者`<div>`这样的HTML标签，这些标签是我们不想索引的。我们可以使用html清除字符过滤器来移除掉所有的HTML标签，并且像把`Á`转换为相对应的Unicode字符Á 这样，转换HTML实体。一个分析器可能有0个或者多个字符过滤器。\r\n\r\n#### 分词器\r\n\r\n一个分析器必须有一个唯一的分词器。分词器把字符串分解成单个词条或者词汇单元。标准分析器里使用的标准分词器把一个字符串根据单词边界分解成单个词条，并且移除掉大部分的标点符号，然而还有其他不同行为的分词器存在。\r\n\r\n例如，关键词分词器完整地输出接收到的同样的字符串，并不做任何分词。空格分词器只根据空格分割文本。正则分词器根据匹配正则表达式来分割文本。\r\n\r\n#### 词单元过滤器\r\n\r\n经过分词，作为结果的词单元流会按照指定的顺序通过指定的词单元过滤器。词单元过滤器可以修改、添加或者移除词单元。我们已经提到过lowercase和stop词过滤器，但是在Elasticsearch里面还有很多可供选择的词单元过滤器。词干过滤器把单词遏制为词干。ascii_folding过滤器移除变音符，把一个像\"très”这样的词转换为“tres”。\r\n\r\nngram和edge_ngram词单元过滤器可以产生适合用于部分匹配或者自动补全的词单元。\r\n\r\n#### 自定义分析器例子\r\n\r\n接下来，我们看看如何创建自定义的分析器：\r\n\r\n```json\r\n#PUT http://localhost:9200/my_index\r\n\r\n{\r\n    \"settings\": {\r\n        \"analysis\": {\r\n            \"char_filter\": {\r\n                \"&_to_and\": {\r\n                    \"type\": \"mapping\", \r\n                    \"mappings\": [\r\n                        \"&=> and \"\r\n                    ]\r\n                }\r\n            }, \r\n            \"filter\": {\r\n                \"my_stopwords\": {\r\n                    \"type\": \"stop\", \r\n                    \"stopwords\": [\r\n                        \"the\", \r\n                        \"a\"\r\n                    ]\r\n                }\r\n            }, \r\n            \"analyzer\": {\r\n                \"my_analyzer\": {\r\n                    \"type\": \"custom\", \r\n                    \"char_filter\": [\r\n                        \"html_strip\", \r\n                        \"&_to_and\"\r\n                    ], \r\n                    \"tokenizer\": \"standard\", \r\n                    \"filter\": [\r\n                        \"lowercase\", \r\n                        \"my_stopwords\"\r\n                    ]\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\n索引被创建以后，使用analyze API来测试这个新的分析器：\r\n\r\n```json\r\n# GET http://127.0.0.1:9200/my_index/_analyze\r\n{\r\n    \"text\":\"The quick & brown fox\",\r\n    \"analyzer\": \"my_analyzer\"\r\n}\r\n\r\n```\r\n\r\n返回结果为：\r\n\r\n```json\r\n{\r\n    \"tokens\": [\r\n        {\r\n            \"token\": \"quick\",\r\n            \"start_offset\": 4,\r\n            \"end_offset\": 9,\r\n            \"type\": \"<ALPHANUM>\",\r\n            \"position\": 1\r\n        },\r\n        {\r\n            \"token\": \"and\",\r\n            \"start_offset\": 10,\r\n            \"end_offset\": 11,\r\n            \"type\": \"<ALPHANUM>\",\r\n            \"position\": 2\r\n        },\r\n        {\r\n            \"token\": \"brown\",\r\n            \"start_offset\": 12,\r\n            \"end_offset\": 17,\r\n            \"type\": \"<ALPHANUM>\",\r\n            \"position\": 3\r\n        },\r\n        {\r\n            \"token\": \"fox\",\r\n            \"start_offset\": 18,\r\n            \"end_offset\": 21,\r\n            \"type\": \"<ALPHANUM>\",\r\n            \"position\": 4\r\n        }\r\n    ]\r\n}\r\n\r\n```\r\n\r\n## 47-进阶-文档控制\r\n\r\n### 文档冲突\r\n\r\n当我们使用index API更新文档，可以一次性读取原始文档，做我们的修改，然后重新索引整个文档。最近的索引请求将获胜：无论最后哪一个文档被索引，都将被唯一存储在Elasticsearch中。如果其他人同时更改这个文档，他们的更改将丢失。\r\n\r\n很多时候这是没有问题的。也许我们的主数据存储是一个关系型数据库，我们只是将数据复制到Elasticsearch中并使其可被搜索。也许两个人同时更改相同的文档的几率很小。或者对于我们的业务来说偶尔丢失更改并不是很严重的问题。\r\n\r\n但有时丢失了一个变更就是非常严重的。试想我们使用Elasticsearch存储我们网上商城商品库存的数量，每次我们卖一个商品的时候，我们在Elasticsearch中将库存数量减少。有一天，管理层决定做一次促销。突然地，我们一秒要卖好几个商品。假设有两个web程序并行运行，每一个都同时处理所有商品的销售。\r\n\r\n![img](https://img-blog.csdnimg.cn/img_convert/49ca2ec50db3ddd0fcd1f364ac600b96.png)\r\n\r\nweb_1对stock_count所做的更改已经丢失，因为web_2不知道它的stock_count的拷贝已经过期。结果我们会认为有超过商品的实际数量的库存，因为卖给顾客的库存商品并不存在，我们将让他们非常失望。\r\n\r\n变更越频繁，读数据和更新数据的间隙越长，也就越可能丢失变更。在数据库领域中，有两种方法通常被用来确保并发更新时变更不会丢失：\r\n\r\n- 悲观并发控制：这种方法被关系型数据库广泛使用，它假定有变更冲突可能发生，因此阻塞访问资源以防止冲突。一个典型的例子是读取一行数据之前先将其锁住，确保只有放置锁的线程能够对这行数据进行修改。\r\n- 乐观并发控制：Elasticsearch中使用的这种方法假定冲突是不可能发生的，并且不会阻塞正在尝试的操作。然而，如果源数据在读写当中被修改，更新将会失败。应用程序接下来将决定该如何解决冲突。例如，可以重试更新、使用新的数据、或者将相关情况报告给用户。\r\n\r\n### 乐观并发控制\r\n\r\nElasticsearch是分布式的。当文档创建、更新或删除时，新版本的文档必须复制到集群中的其他节点。Elasticsearch也是异步和并发的，这意味着这些复制请求被并行发送，并且到达目的地时也许顺序是乱的。Elasticsearch需要一种方法确保文档的旧版本不会覆盖新的版本。\r\n\r\n当我们之前讨论index,GET和DELETE请求时，我们指出每个文档都有一个_version（版本号），当文档被修改时版本号递增。Elasticsearch使用这个version号来确保变更以正确顺序得到执行。如果旧版本的文档在新版本之后到达，它可以被简单的忽略。\r\n\r\n我们可以利用version号来确保应用中相互冲突的变更不会导致数据丢失。我们通过指定想要修改文档的version号来达到这个目的。如果该版本不是当前版本号，我们的请求将会失败。\r\n\r\n老的版本es使用version，但是新版本不支持了，会报下面的错误，提示我们用if_seq_no和if_primary_term\r\n\r\n创建索引\r\n\r\n```json\r\n#PUT http://127.0.0.1:9200/shopping/_create/1001\r\n\r\n```\r\n\r\n返回结果\r\n\r\n```json\r\n{\r\n    \"_index\": \"shopping\",\r\n    \"_type\": \"_doc\",\r\n    \"_id\": \"1001\",\r\n    \"_version\": 1,\r\n    \"result\": \"created\",\r\n    \"_shards\": {\r\n        \"total\": 2,\r\n        \"successful\": 1,\r\n        \"failed\": 0\r\n    },\r\n    \"_seq_no\": 10,\r\n    \"_primary_term\": 15\r\n}\r\n\r\n```\r\n\r\n更新数据\r\n\r\n```json\r\n#POST http://127.0.0.1:9200/shopping/_update/1001\r\n{\r\n    \"doc\":{\r\n        \"title\":\"华为手机\"\r\n    }\r\n}\r\n\r\n```\r\n\r\n返回结果：\r\n\r\n```json\r\n{\r\n    \"_index\": \"shopping\",\r\n    \"_type\": \"_doc\",\r\n    \"_id\": \"1001\",\r\n    \"_version\": 2,\r\n    \"result\": \"updated\",\r\n    \"_shards\": {\r\n        \"total\": 2,\r\n        \"successful\": 1,\r\n        \"failed\": 0\r\n    },\r\n    \"_seq_no\": 11,\r\n    \"_primary_term\": 15\r\n}\r\n\r\n```\r\n\r\n旧版本使用的防止冲突更新方法：\r\n\r\n```json\r\n#POST http://127.0.0.1:9200/shopping/_update/1001?version=1\r\n{\r\n    \"doc\":{\r\n        \"title\":\"华为手机2\"\r\n    }\r\n}\r\n\r\n```\r\n\r\n返回结果：\r\n\r\n```json\r\n{\r\n    \"error\": {\r\n        \"root_cause\": [\r\n            {\r\n                \"type\": \"action_request_validation_exception\",\r\n                \"reason\": \"Validation Failed: 1: internal versioning can not be used for optimistic concurrency control. Please use `if_seq_no` and `if_primary_term` instead;\"\r\n            }\r\n        ],\r\n        \"type\": \"action_request_validation_exception\",\r\n        \"reason\": \"Validation Failed: 1: internal versioning can not be used for optimistic concurrency control. Please use `if_seq_no` and `if_primary_term` instead;\"\r\n    },\r\n    \"status\": 400\r\n}\r\n\r\n```\r\n\r\n新版本使用的防止冲突更新方法：\r\n\r\n```json\r\n#POST http://127.0.0.1:9200/shopping/_update/1001?if_seq_no=11&if_primary_term=15\r\n{\r\n    \"doc\":{\r\n        \"title\":\"华为手机2\"\r\n    }\r\n}\r\n\r\n```\r\n\r\n返回结果：\r\n\r\n```json\r\n{\r\n    \"_index\": \"shopping\",\r\n    \"_type\": \"_doc\",\r\n    \"_id\": \"1001\",\r\n    \"_version\": 3,\r\n    \"result\": \"updated\",\r\n    \"_shards\": {\r\n        \"total\": 2,\r\n        \"successful\": 1,\r\n        \"failed\": 0\r\n    },\r\n    \"_seq_no\": 12,\r\n    \"_primary_term\": 16\r\n}\r\n\r\n```\r\n\r\n### 外部系统版本控制\r\n\r\n一个常见的设置是使用其它数据库作为主要的数据存储，使用Elasticsearch做数据检索，这意味着主数据库的所有更改发生时都需要被复制到Elasticsearch，如果多个进程负责这一数据同步，你可能遇到类似于之前描述的并发问题。\r\n\r\n如果你的主数据库已经有了版本号，或一个能作为版本号的字段值比如timestamp，那么你就可以在Elasticsearch中通过增加version_type=extermal到查询字符串的方式重用这些相同的版本号，版本号必须是大于零的整数，且小于9.2E+18，一个Java中long类型的正值。\r\n\r\n外部版本号的处理方式和我们之前讨论的内部版本号的处理方式有些不同，Elasticsearch不是检查当前_version和请求中指定的版本号是否相同，而是检查当前_version是否小于指定的版本号。如果请求成功，外部的版本号作为文档的新_version进行存储。\r\n\r\n```json\r\n#POST http://127.0.0.1:9200/shopping/_doc/1001?version=300&version_type=external\r\n{\r\n\t\"title\":\"华为手机2\"\r\n}\r\n\r\n```\r\n\r\n返回结果：\r\n\r\n```json\r\n{\r\n    \"_index\": \"shopping\",\r\n    \"_type\": \"_doc\",\r\n    \"_id\": \"1001\",\r\n    \"_version\": 300,\r\n    \"result\": \"updated\",\r\n    \"_shards\": {\r\n        \"total\": 2,\r\n        \"successful\": 1,\r\n        \"failed\": 0\r\n    },\r\n    \"_seq_no\": 13,\r\n    \"_primary_term\": 16\r\n}\r\n\r\n```\r\n\r\n## 48-进阶-文档展示-Kibana\r\n\r\nKibana是一个免费且开放的用户界面，能够让你对Elasticsearch数据进行可视化，并让你在Elastic Stack中进行导航。你可以进行各种操作，从跟踪查询负载，到理解请求如何流经你的整个应用，都能轻松完成。\r\n\r\n[Kibana下载网址](https://artifacts.elastic.co/downloads/kibana/kibana-7.8.0-windows-x86_64.zip)\r\n\r\n一、解压缩下载的zip文件。\r\n\r\n二、修改config/kibana.yml文件。\r\n\r\n```yaml\r\n# 默认端口\r\nserver.port: 5601\r\n# ES服务器的地址\r\nelasticsearch.hosts: [\"http://localhost:9200\"]\r\n# 索引名\r\nkibana.index: \".kibana\"\r\n# 支持中文\r\ni18n.locale: \"zh-CN\"\r\n\r\n```\r\n\r\n三、Windows环境下执行bin/kibana.bat文件。（首次启动有点耗时）\r\n\r\n四、通过浏览器访问：http://localhost:5601。\r\n\r\n![img](https://img-blog.csdnimg.cn/img_convert/d066ba5e26916624b5d056d04c5580ac.png)\r\n\r\n# 第5章 Elasticsearch集成\r\n\r\n## 49-框架集成-SpringData-整体介绍\r\n\r\nSpring Data是一个用于简化数据库、非关系型数据库、索引库访问，并支持云服务的开源框架。其主要目标是使得对数据的访问变得方便快捷，并支持map-reduce框架和云计算数据服务。Spring Data可以极大的简化JPA(Elasticsearch…)的写法，可以在几乎不用写实现的情况下，实现对数据的访问和操作。除了CRUD外，还包括如分页、排序等一些常用的功能。\r\n\r\n[Spring Data的官网](https://spring.io/projects/spring-data)\r\n\r\nSpring Data常用的功能模块如下：\r\n\r\n- Spring Data JDBC\r\n- Spring Data JPA\r\n- Spring Data LDAP\r\n- Spring Data MongoDB\r\n- Spring Data Redis\r\n- Spring Data R2DBC\r\n- Spring Data REST\r\n- Spring Data for Apache Cassandra\r\n- Spring Data for Apache Geode\r\n- Spring Data for Apache Solr\r\n- Spring Data for Pivotal GemFire\r\n- Spring Data Couchbase\r\n- Spring Data Elasticsearch\r\n- Spring Data Envers\r\n- Spring Data Neo4j\r\n- Spring Data JDBC Extensions\r\n- Spring for Apache Hadoop\r\n\r\n### Spring Data Elasticsearch介绍\r\n\r\nSpring Data Elasticsearch基于Spring Data API简化Elasticsearch操作，将原始操作Elasticsearch的客户端API进行封装。Spring Data为Elasticsearch项目提供集成搜索引擎。Spring Data Elasticsearch POJO的关键功能区域为中心的模型与Elastichsearch交互文档和轻松地编写一个存储索引库数据访问层。\r\n\r\n[Spring Data Elasticsearch官网](https://spring.io/projects/spring-data-elasticsearch)\r\n\r\n## 50-框架集成-SpringData-代码功能集成\r\n\r\n一、创建Maven项目。\r\n\r\n二、修改pom文件，增加依赖关系。\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\r\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\r\n    <modelVersion>4.0.0</modelVersion>\r\n\r\n    <parent>\r\n        <groupId>org.springframework.boot</groupId>\r\n        <artifactId>spring-boot-starter-parent</artifactId>\r\n        <version>2.3.6.RELEASE</version>\r\n        <relativePath/>\r\n    </parent>\r\n\r\n    <groupId>com.lun</groupId>\r\n    <artifactId>SpringDataWithES</artifactId>\r\n    <version>1.0.0-SNAPSHOT</version>\r\n\r\n    <properties>\r\n        <maven.compiler.source>8</maven.compiler.source>\r\n        <maven.compiler.target>8</maven.compiler.target>\r\n    </properties>\r\n    <dependencies>\r\n        <dependency>\r\n            <groupId>org.projectlombok</groupId>\r\n            <artifactId>lombok</artifactId>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.springframework.boot</groupId>\r\n            <artifactId>spring-boot-starter-data-elasticsearch</artifactId>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.springframework.boot</groupId>\r\n            <artifactId>spring-boot-devtools</artifactId>\r\n            <scope>runtime</scope>\r\n            <optional>true</optional>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.springframework.boot</groupId>\r\n            <artifactId>spring-boot-starter-test</artifactId>\r\n            <scope>test</scope>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.springframework.boot</groupId>\r\n            <artifactId>spring-boot-test</artifactId>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>junit</groupId>\r\n            <artifactId>junit</artifactId>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.springframework</groupId>\r\n            <artifactId>spring-test</artifactId>\r\n        </dependency>\r\n    </dependencies>\r\n</project>\r\n\r\n```\r\n\r\n三、增加配置文件。\r\n\r\n在resources目录中增加application.properties文件\r\n\r\n```properties\r\n# es 服务地址\r\nelasticsearch.host=127.0.0.1\r\n# es 服务端口\r\nelasticsearch.port=9200\r\n# 配置日志级别,开启 debug 日志\r\nlogging.level.com.atguigu.es=debug\r\n\r\n```\r\n\r\n四、Spring Boot主程序。\r\n\r\n```java\r\nimport org.springframework.boot.SpringApplication;\r\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\r\n\r\n@SpringBootApplication\r\npublic class MainApplication {\r\n    public static void main(String[] args) {\r\n        SpringApplication.run(MainApplication.class, args);\r\n    }\r\n}\r\n\r\n```\r\n\r\n五、数据实体类。\r\n\r\n```java\r\nimport lombok.AllArgsConstructor;\r\nimport lombok.Data;\r\nimport lombok.NoArgsConstructor;\r\nimport lombok.ToString;\r\nimport org.springframework.data.annotation.Id;\r\nimport org.springframework.data.elasticsearch.annotations.Document;\r\nimport org.springframework.data.elasticsearch.annotations.Field;\r\nimport org.springframework.data.elasticsearch.annotations.FieldType;\r\n\r\n@Data\r\n@NoArgsConstructor\r\n@AllArgsConstructor\r\n@ToString\r\n@Document(indexName = \"shopping\", shards = 3, replicas = 1)\r\npublic class Product {\r\n    //必须有 id,这里的 id 是全局唯一的标识，等同于 es 中的\"_id\"\r\n    @Id\r\n    private Long id;//商品唯一标识\r\n\r\n    /**\r\n     * type : 字段数据类型\r\n     * analyzer : 分词器类型\r\n     * index : 是否索引(默认:true)\r\n     * Keyword : 短语,不进行分词\r\n     */\r\n    @Field(type = FieldType.Text, analyzer = \"ik_max_word\")\r\n    private String title;//商品名称\r\n\r\n    @Field(type = FieldType.Keyword)\r\n    private String category;//分类名称\r\n\r\n    @Field(type = FieldType.Double)\r\n    private Double price;//商品价格\r\n\r\n    @Field(type = FieldType.Keyword, index = false)\r\n    private String images;//图片地址\r\n}\r\n\r\n```\r\n\r\n六、配置类\r\n\r\n- ElasticsearchRestTemplate是spring-data-elasticsearch项目中的一个类,和其他spring项目中的template类似。\r\n- 在新版的spring-data-elasticsearch中，ElasticsearchRestTemplate代替了原来的ElasticsearchTemplate。\r\n- 原因是ElasticsearchTemplate基于TransportClient，TransportClient即将在8.x以后的版本中移除。所以，我们推荐使用ElasticsearchRestTemplate。\r\n- ElasticsearchRestTemplate基于RestHighLevelClient客户端的。需要自定义配置类，继承AbstractElasticsearchConfiguration，并实现elasticsearchClient()抽象方法，创建RestHighLevelClient对象。\r\n\r\nAbstractElasticsearchConfiguration源码：\r\n\r\n```json\r\npackage org.springframework.data.elasticsearch.config;\r\n\r\nimport org.elasticsearch.client.RestHighLevelClient;\r\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.data.elasticsearch.core.ElasticsearchOperations;\r\nimport org.springframework.data.elasticsearch.core.ElasticsearchRestTemplate;\r\nimport org.springframework.data.elasticsearch.core.convert.ElasticsearchConverter;\r\n\r\n/**\r\n * @author Christoph Strobl\r\n * @author Peter-Josef Meisch\r\n * @since 3.2\r\n * @see ElasticsearchConfigurationSupport\r\n */\r\npublic abstract class AbstractElasticsearchConfiguration extends ElasticsearchConfigurationSupport {\r\n\r\n\t//需重写本方法\r\n\tpublic abstract RestHighLevelClient elasticsearchClient();\r\n\r\n\t@Bean(name = { \"elasticsearchOperations\", \"elasticsearchTemplate\" })\r\n\tpublic ElasticsearchOperations elasticsearchOperations(ElasticsearchConverter elasticsearchConverter) {\r\n\t\treturn new ElasticsearchRestTemplate(elasticsearchClient(), elasticsearchConverter);\r\n\t}\r\n}\r\n\r\n```\r\n\r\n需要自定义配置类，继承AbstractElasticsearchConfiguration，并实现elasticsearchClient()抽象方法，创建RestHighLevelClient对象。\r\n\r\n```java\r\nimport lombok.Data;\r\nimport org.apache.http.HttpHost;\r\nimport org.elasticsearch.client.RestClient;\r\nimport org.elasticsearch.client.RestClientBuilder;\r\nimport org.elasticsearch.client.RestHighLevelClient;\r\nimport org.springframework.boot.context.properties.ConfigurationProperties;\r\nimport org.springframework.context.annotation.Configuration;\r\nimport org.springframework.data.elasticsearch.config.AbstractElasticsearchConfiguration;\r\n\r\n@ConfigurationProperties(prefix = \"elasticsearch\")\r\n@Configuration\r\n@Data\r\npublic class ElasticsearchConfig extends AbstractElasticsearchConfiguration{\r\n\r\n    private String host ;\r\n    private Integer port ;\r\n    //重写父类方法\r\n    @Override\r\n    public RestHighLevelClient elasticsearchClient() {\r\n        RestClientBuilder builder = RestClient.builder(new HttpHost(host, port));\r\n        RestHighLevelClient restHighLevelClient = new\r\n                RestHighLevelClient(builder);\r\n        return restHighLevelClient;\r\n    }\r\n}\r\n\r\n```\r\n\r\n七、DAO 数据访问对象\r\n\r\n```java\r\nimport com.lun.model.Product;\r\nimport org.springframework.data.elasticsearch.repository.ElasticsearchRepository;\r\nimport org.springframework.stereotype.Repository;\r\n\r\n@Repository\r\npublic interface ProductDao extends ElasticsearchRepository<Product, Long>{\r\n\r\n}\r\n\r\n```\r\n\r\n## 51-框架集成-SpringData-集成测试-索引操作\r\n\r\n```java\r\nimport com.lun.model.Product;\r\nimport org.junit.Test;\r\nimport org.junit.runner.RunWith;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.boot.test.context.SpringBootTest;\r\nimport org.springframework.data.elasticsearch.core.ElasticsearchRestTemplate;\r\nimport org.springframework.test.context.junit4.SpringRunner;\r\n\r\n@RunWith(SpringRunner.class)\r\n@SpringBootTest\r\npublic class SpringDataESIndexTest {\r\n    //注入 ElasticsearchRestTemplate\r\n    @Autowired\r\n    private ElasticsearchRestTemplate elasticsearchRestTemplate;\r\n    //创建索引并增加映射配置\r\n    @Test\r\n    public void createIndex(){\r\n        //创建索引，系统初始化会自动创建索引\r\n        System.out.println(\"创建索引\");\r\n    }\r\n\r\n    @Test\r\n    public void deleteIndex(){\r\n        //创建索引，系统初始化会自动创建索引\r\n        boolean flg = elasticsearchRestTemplate.deleteIndex(Product.class);\r\n        System.out.println(\"删除索引 = \" + flg);\r\n    }\r\n}\r\n\r\n```\r\n\r\n用Postman检测有没有创建和删除。\r\n\r\n```json\r\n#GET http://localhost:9200/_cat/indices?v \r\n\r\n```\r\n\r\n## 52-框架集成-SpringData-集成测试-文档操作\r\n\r\n```java\r\nimport com.lun.dao.ProductDao;\r\nimport com.lun.model.Product;\r\nimport org.junit.Test;\r\nimport org.junit.runner.RunWith;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.boot.test.context.SpringBootTest;\r\nimport org.springframework.data.domain.Page;\r\nimport org.springframework.data.domain.PageRequest;\r\nimport org.springframework.data.domain.Sort;\r\nimport org.springframework.test.context.junit4.SpringRunner;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\n@RunWith(SpringRunner.class)\r\n@SpringBootTest\r\npublic class SpringDataESProductDaoTest {\r\n\r\n    @Autowired\r\n    private ProductDao productDao;\r\n    /**\r\n     * 新增\r\n     */\r\n    @Test\r\n    public void save(){\r\n        Product product = new Product();\r\n        product.setId(2L);\r\n        product.setTitle(\"华为手机\");\r\n        product.setCategory(\"手机\");\r\n        product.setPrice(2999.0);\r\n        product.setImages(\"http://www.atguigu/hw.jpg\");\r\n        productDao.save(product);\r\n    }\r\n    //POSTMAN, GET http://localhost:9200/product/_doc/2\r\n\r\n    //修改\r\n    @Test\r\n    public void update(){\r\n        Product product = new Product();\r\n        product.setId(2L);\r\n        product.setTitle(\"小米 2 手机\");\r\n        product.setCategory(\"手机\");\r\n        product.setPrice(9999.0);\r\n        product.setImages(\"http://www.atguigu/xm.jpg\");\r\n        productDao.save(product);\r\n    }\r\n    //POSTMAN, GET http://localhost:9200/product/_doc/2\r\n\r\n\r\n    //根据 id 查询\r\n    @Test\r\n    public void findById(){\r\n        Product product = productDao.findById(2L).get();\r\n        System.out.println(product);\r\n    }\r\n\r\n    @Test\r\n    public void findAll(){\r\n        Iterable<Product> products = productDao.findAll();\r\n        for (Product product : products) {\r\n            System.out.println(product);\r\n        }\r\n    }\r\n\r\n    //删除\r\n    @Test\r\n    public void delete(){\r\n        Product product = new Product();\r\n        product.setId(2L);\r\n        productDao.delete(product);\r\n    }\r\n    //POSTMAN, GET http://localhost:9200/product/_doc/2\r\n\r\n    //批量新增\r\n    @Test\r\n    public void saveAll(){\r\n        List<Product> productList = new ArrayList<>();\r\n        for (int i = 0; i < 10; i++) {\r\n            Product product = new Product();\r\n            product.setId(Long.valueOf(i));\r\n            product.setTitle(\"[\"+i+\"]小米手机\");\r\n            product.setCategory(\"手机\");\r\n            product.setPrice(1999.0 + i);\r\n            product.setImages(\"http://www.atguigu/xm.jpg\");\r\n            productList.add(product);\r\n        }\r\n        productDao.saveAll(productList);\r\n    }\r\n\r\n    //分页查询\r\n    @Test\r\n    public void findByPageable(){\r\n        //设置排序(排序方式，正序还是倒序，排序的id)\r\n        Sort sort = Sort.by(Sort.Direction.DESC,\"id\");\r\n        int currentPage=0;//当前页，第一页从0开始，1表示第二页\r\n        int pageSize = 5;//每页显示多少条\r\n        //设置查询分页\r\n        PageRequest pageRequest = PageRequest.of(currentPage, pageSize,sort);\r\n        //分页查询\r\n        Page<Product> productPage = productDao.findAll(pageRequest);\r\n        for (Product Product : productPage.getContent()) {\r\n            System.out.println(Product);\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\n## 53-框架集成-SpringData-集成测试-文档搜索\r\n\r\n```java\r\nimport com.lun.dao.ProductDao;\r\nimport com.lun.model.Product;\r\nimport org.elasticsearch.index.query.QueryBuilders;\r\nimport org.elasticsearch.index.query.TermQueryBuilder;\r\nimport org.junit.Test;\r\nimport org.junit.runner.RunWith;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.boot.test.context.SpringBootTest;\r\nimport org.springframework.data.domain.PageRequest;\r\nimport org.springframework.test.context.junit4.SpringRunner;\r\n\r\n@RunWith(SpringRunner.class)\r\n@SpringBootTest\r\npublic class SpringDataESSearchTest {\r\n\r\n    @Autowired\r\n    private ProductDao productDao;\r\n    /**\r\n     * term 查询\r\n     * search(termQueryBuilder) 调用搜索方法，参数查询构建器对象\r\n     */\r\n    @Test\r\n    public void termQuery(){\r\n        TermQueryBuilder termQueryBuilder = QueryBuilders.termQuery(\"title\", \"小米\");\r\n                Iterable<Product> products = productDao.search(termQueryBuilder);\r\n        for (Product product : products) {\r\n            System.out.println(product);\r\n        }\r\n    }\r\n    /**\r\n     * term 查询加分页\r\n     */\r\n    @Test\r\n    public void termQueryByPage(){\r\n        int currentPage= 0 ;\r\n        int pageSize = 5;\r\n        //设置查询分页\r\n        PageRequest pageRequest = PageRequest.of(currentPage, pageSize);\r\n        TermQueryBuilder termQueryBuilder = QueryBuilders.termQuery(\"title\", \"小米\");\r\n                Iterable<Product> products =\r\n                        productDao.search(termQueryBuilder,pageRequest);\r\n        for (Product product : products) {\r\n            System.out.println(product);\r\n        }\r\n    }\r\n\r\n}\r\n\r\n```\r\n\r\n## 54-框架集成-SparkStreaming-集成\r\n\r\nSpark Streaming是Spark core API的扩展，支持实时数据流的处理，并且具有可扩展，高吞吐量，容错的特点。数据可以从许多来源获取,如Kafka，Flume，Kinesis或TCP sockets，并且可以使用复杂的算法进行处理，这些算法使用诸如map，reduce，join和window等高级函数表示。最后，处理后的数据可以推送到文件系统，数据库等。实际上，您可以将Spark的机器学习和图形处理算法应用于数据流。\r\n\r\n一、创建Maven项目。\r\n\r\n二、修改pom文件，增加依赖关系。\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<project\r\n    xmlns=\"http://maven.apache.org/POM/4.0.0\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\r\n    <modelVersion>4.0.0</modelVersion>\r\n    <groupId>com.lun.es</groupId>\r\n    <artifactId>sparkstreaming-elasticsearch</artifactId>\r\n    <version>1.0</version>\r\n    <properties>\r\n        <maven.compiler.source>8</maven.compiler.source>\r\n        <maven.compiler.target>8</maven.compiler.target>\r\n    </properties>\r\n    <dependencies>\r\n        <dependency>\r\n            <groupId>org.apache.spark</groupId>\r\n            <artifactId>spark-core_2.12</artifactId>\r\n            <version>3.0.0</version>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.apache.spark</groupId>\r\n            <artifactId>spark-streaming_2.12</artifactId>\r\n            <version>3.0.0</version>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.elasticsearch</groupId>\r\n            <artifactId>elasticsearch</artifactId>\r\n            <version>7.8.0</version>\r\n        </dependency>\r\n        <!-- elasticsearch 的客户端 -->\r\n        <dependency>\r\n            <groupId>org.elasticsearch.client</groupId>\r\n            <artifactId>elasticsearch-rest-high-level-client</artifactId>\r\n            <version>7.8.0</version>\r\n        </dependency>\r\n        <!-- elasticsearch 依赖 2.x 的 log4j -->\r\n        <dependency>\r\n            <groupId>org.apache.logging.log4j</groupId>\r\n            <artifactId>log4j-api</artifactId>\r\n            <version>2.8.2</version>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.apache.logging.log4j</groupId>\r\n            <artifactId>log4j-core</artifactId>\r\n            <version>2.8.2</version>\r\n        </dependency>\r\n        <!-- <dependency>-->\r\n        <!-- <groupId>com.fasterxml.jackson.core</groupId>-->\r\n        <!-- <artifactId>jackson-databind</artifactId>-->\r\n        <!-- <version>2.11.1</version>-->\r\n        <!-- </dependency>-->\r\n        <!-- &lt;!&ndash; junit 单元测试 &ndash;&gt;-->\r\n        <!-- <dependency>-->\r\n        <!-- <groupId>junit</groupId>-->\r\n        <!-- <artifactId>junit</artifactId>-->\r\n        <!-- <version>4.12</version>-->\r\n        <!-- </dependency>-->\r\n    </dependencies>\r\n</project>\r\n\r\n```\r\n\r\n三、功能实现\r\n\r\n```scala\r\nimport org.apache.http.HttpHost\r\nimport org.apache.spark.SparkConf\r\nimport org.apache.spark.streaming.dstream.ReceiverInputDStream\r\nimport org.apache.spark.streaming.{Seconds, StreamingContext}\r\nimport org.elasticsearch.action.index.IndexRequest\r\nimport org.elasticsearch.client.indices.CreateIndexRequest\r\nimport org.elasticsearch.client.{RequestOptions, RestClient, RestHighLevelClient}\r\nimport org.elasticsearch.common.xcontent.XContentType\r\nimport java.util.Date\r\n\r\nobject SparkStreamingESTest {\r\n\r\n    def main(args: Array[String]): Unit = {\r\n        val sparkConf = new SparkConf().setMaster(\"local[*]\").setAppName(\"ESTest\")\r\n        val ssc = new StreamingContext(sparkConf, Seconds(3))\r\n        val ds: ReceiverInputDStream[String] = ssc.socketTextStream(\"localhost\", 9999)\r\n        ds.foreachRDD(\r\n            rdd => {\r\n                println(\"*************** \" + new Date())\r\n                rdd.foreach(\r\n                    data => {\r\n                        val client = new RestHighLevelClient(RestClient.builder(new HttpHost(\"localhost\", 9200, \"http\")));\r\n                        // 新增文档 - 请求对象\r\n                        val request = new IndexRequest();\r\n                        \r\n                        // 设置索引及唯一性标识\r\n                        val ss = data.split(\" \")\r\n                        println(\"ss = \" + ss.mkString(\",\"))\r\n                        request.index(\"sparkstreaming\").id(ss(0));\r\n                        \r\n                        val productJson =\r\n                            s\"\"\"\r\n                            | { \"data\":\"${ss(1)}\" }\r\n                            |\"\"\".stripMargin;\r\n                        \r\n                        // 添加文档数据，数据格式为 JSON 格式\r\n                        request.source(productJson,XContentType.JSON);\r\n                        \r\n                        // 客户端发送请求，获取响应对象\r\n                        val response = client.index(request,\r\n                        RequestOptions.DEFAULT);\r\n                        System.out.println(\"_index:\" + response.getIndex());\r\n                        System.out.println(\"_id:\" + response.getId());\r\n                        System.out.println(\"_result:\" + response.getResult());\r\n                        client.close()\r\n                    }\r\n                )\r\n            }\r\n        )\r\n        ssc.start()\r\n        ssc.awaitTermination()\r\n    }\r\n}\r\n\r\n```\r\n\r\n## 55-框架集成-Flink-集成\r\n\r\nApache Spark是一-种基于内存的快速、通用、可扩展的大数据分析计算引擎。Apache Spark掀开了内存计算的先河，以内存作为赌注，贏得了内存计算的飞速发展。但是在其火热的同时，开发人员发现，在Spark中，计算框架普遍存在的缺点和不足依然没有完全解决，而这些问题随着5G时代的来临以及决策者对实时数据分析结果的迫切需要而凸显的更加明显：\r\n\r\n- 乱序数据，迟到数据\r\n- 低延迟，高吞吐，准确性\r\n- 容错性\r\n- 数据精准一次性处理（Exactly-Once）\r\n\r\nApache Flink是一个框架和分布式处理引擎，用于对无界和有界数据流进行有状态计算。在Spark火热的同时，也默默地发展自己，并尝试着解决其他计算框架的问题。慢慢地，随着这些问题的解决，Flink慢慢被绝大数程序员所熟知并进行大力推广，阿里公司在2015年改进Flink，并创建了内部分支Blink，目前服务于阿里集团内部搜索、推荐、广告和蚂蚁等大量核心实时业务。\r\n\r\n一、创建Maven项目。\r\n\r\n二、修改pom文件，增加相关依赖类库。\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project\r\n    xmlns=\"http://maven.apache.org/POM/4.0.0\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\nxsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0\r\nhttp://maven.apache.org/xsd/maven-4.0.0.xsd\">\r\n    <modelVersion>4.0.0</modelVersion>\r\n    <groupId>com.lun.es</groupId>\r\n    <artifactId>flink-elasticsearch</artifactId>\r\n    <version>1.0</version>\r\n    <properties>\r\n        <maven.compiler.source>8</maven.compiler.source>\r\n        <maven.compiler.target>8</maven.compiler.target>\r\n    </properties>\r\n    <dependencies>\r\n        <dependency>\r\n            <groupId>org.apache.flink</groupId>\r\n            <artifactId>flink-scala_2.12</artifactId>\r\n            <version>1.12.0</version>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.apache.flink</groupId>\r\n            <artifactId>flink-streaming-scala_2.12</artifactId>\r\n            <version>1.12.0</version>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.apache.flink</groupId>\r\n            <artifactId>flink-clients_2.12</artifactId>\r\n            <version>1.12.0</version>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.apache.flink</groupId>\r\n            <artifactId>flink-connector-elasticsearch7_2.11</artifactId>\r\n            <version>1.12.0</version>\r\n        </dependency>\r\n        <!-- jackson -->\r\n        <dependency>\r\n            <groupId>com.fasterxml.jackson.core</groupId>\r\n            <artifactId>jackson-core</artifactId>\r\n            <version>2.11.1</version>\r\n        </dependency>\r\n    </dependencies>\r\n</project>\r\n\r\n```\r\n\r\n三、功能实现\r\n\r\n```java\r\nimport org.apache.flink.api.common.functions.RuntimeContext;\r\nimport org.apache.flink.streaming.api.datastream.DataStreamSource;\r\nimport org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;\r\nimport org.apache.flink.streaming.connectors.elasticsearch.ElasticsearchSinkFunction;\r\nimport org.apache.flink.streaming.connectors.elasticsearch.RequestIndexer;\r\nimport org.apache.flink.streaming.connectors.elasticsearch7.ElasticsearchSink;\r\nimport org.apache.http.HttpHost;\r\nimport org.elasticsearch.action.index.IndexRequest;\r\nimport org.elasticsearch.client.Requests;\r\nimport java.util.ArrayList;\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport java.util.Map;\r\n\r\npublic class FlinkElasticsearchSinkTest {\r\n\r\n\tpublic static void main(String[] args) throws Exception {\r\n\r\n\t\tStreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();\r\n\t\tDataStreamSource<String> source = env.socketTextStream(\"localhost\", 9999);\r\n\t\tList<HttpHost> httpHosts = new ArrayList<>();\r\n\t\thttpHosts.add(new HttpHost(\"127.0.0.1\", 9200, \"http\"));\r\n\t\t//httpHosts.add(new HttpHost(\"10.2.3.1\", 9200, \"http\"));\r\n\r\n\t\t// use a ElasticsearchSink.Builder to create an ElasticsearchSink\r\n\t\tElasticsearchSink.Builder<String> esSinkBuilder = new ElasticsearchSink.Builder<>(httpHosts, \r\n\t\t\tnew ElasticsearchSinkFunction<String>() {\r\n\t\t\t\tpublic IndexRequest createIndexRequest(String element) {\r\n\t\t\t\t\tMap<String, String> json = new HashMap<>();\r\n\t\t\t\t\tjson.put(\"data\", element);\r\n\t\t\t\t\treturn Requests.indexRequest()\r\n\t\t\t\t\t\t.index(\"my-index\")\r\n\t\t\t\t\t\t//.type(\"my-type\")\r\n\t\t\t\t\t\t.source(json);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t@Override\r\n\t\t\t\tpublic void process(String element, RuntimeContext ctx, RequestIndexer indexer) {\r\n\t\t\t\t\tindexer.add(createIndexRequest(element));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\t\t\r\n\t\t// configuration for the bulk requests; this instructs the sink to emit after every element, otherwise they would be buffered\r\n\t\tesSinkBuilder.setBulkFlushMaxActions(1);\r\n\r\n\t\t// provide a RestClientFactory for custom configuration on the internally createdREST client\r\n\t\t// esSinkBuilder.setRestClientFactory(\r\n\t\t// restClientBuilder -> {\r\n\t\t\t// restClientBuilder.setDefaultHeaders(...)\r\n\t\t\t// restClientBuilder.setMaxRetryTimeoutMillis(...)\r\n\t\t\t// restClientBuilder.setPathPrefix(...)\r\n\t\t\t// restClientBuilder.setHttpClientConfigCallback(...)\r\n\t\t// }\r\n\t\t// );\r\n\t\tsource.addSink(esSinkBuilder.build());\r\n\t\tenv.execute(\"flink-es\");\r\n\t}\r\n}\r\n\r\n```\r\n\r\n# 第6章 Elasticsearch优化\r\n\r\n## 56-优化-硬件选择\r\n\r\nElasticsearch的基础是Lucene，所有的索引和文档数据是存储在本地的磁盘中，具体的路径可在ES的配置文件…/config/elasticsearch.yml中配置，如下：\r\n\r\n```yaml\r\n#\r\n# Path to directory where to store the data (separate multiple locations by comma):\r\n#\r\npath.data: /path/to/data\r\n#\r\n# Path to log files:\r\n#\r\npath.logs: /path/to/logs\r\n\r\n```\r\n\r\n磁盘在现代服务器上通常都是瓶颈。Elasticsearch重度使用磁盘，你的磁盘能处理的吞吐量越大，你的节点就越稳定。这里有一些优化磁盘I/O的技巧：\r\n\r\n- 使用SSD就像其他地方提过的，他们比机械磁盘优秀多了。\r\n- 使用RAID0。条带化RAID会提高磁盘IO，代价显然就是当一块硬盘故障时整个就故障了。不要使用镜像或者奇偶校验RAID，因为副本已经提供了这个功能。\r\n- 另外，使用多块硬盘，并允许Elasticsearch通过多个pathdata目录配置把数据条带化分配到它们上面。\r\n- 不要使用远程挂载的存储，比如NFS或者SMB/CIFS。这个引入的延迟对性能来说完全是背道而驰的。\r\n\r\n## 57-优化-分片策略\r\n\r\n### 合理设置分片数\r\n\r\n分片和副本的设计为ES提供了支持分布式和故障转移的特性，但并不意味着分片和副本是可以无限分配的。而且索引的分片完成分配后由于索引的路由机制，我们是不能重新修改分片数的。\r\n\r\n可能有人会说，我不知道这个索引将来会变得多大，并且过后我也不能更改索引的大小，所以为了保险起见，还是给它设为1000个分片吧。但是需要知道的是，一个分片并不是没有代价的。需要了解：\r\n\r\n- 一个分片的底层即为一个Lucene索引，会消耗一定文件句柄、内存、以及 CPU运转。\r\n- 每一个搜索请求都需要命中索引中的每一个分片，如果每一个分片都处于不同的节点还好，但如果多个分片都需要在同一个节点上竞争使用相同的资源就有些糟糕了。\r\n- 用于计算相关度的词项统计信息是基于分片的。如果有许多分片，每一个都只有很少的数据会导致很低的相关度。\r\n\r\n一个业务索引具体需要分配多少分片可能需要架构师和技术人员对业务的增长有个预先的判断，横向扩展应当分阶段进行。为下一阶段准备好足够的资源。只有当你进入到下一个阶段，你才有时间思考需要作出哪些改变来达到这个阶段。一般来说，我们遵循一些原则：\r\n\r\n- 控制每个分片占用的硬盘容量不超过ES的最大JVM的堆空间设置（一般设置不超过32G，参考下文的JVM设置原则），因此，如果索引的总容量在500G左右，那分片大小在16个左右即可；当然，最好同时考虑原则2。\r\n- 考虑一下node数量，一般一个节点有时候就是一台物理机，如果分片数过多，大大超过了节点数，很可能会导致一个节点上存在多个分片，一旦该节点故障，即使保持了1个以上的副本，同样有可能会导致数据丢失，集群无法恢复。所以，一般都设置分片数不超过节点数的3倍。\r\n- 主分片，副本和节点最大数之间数量，我们分配的时候可以参考以下关系：\r\n  `节点数<=主分片数*（副本数+1）`\r\n\r\n### 推迟分片分配\r\n\r\n对于节点瞬时中断的问题，默认情况，集群会等待一分钟来查看节点是否会重新加入，如果这个节点在此期间重新加入，重新加入的节点会保持其现有的分片数据，不会触发新的分片分配。这样就可以减少ES在自动再平衡可用分片时所带来的极大开销。\r\n\r\n通过修改参数delayed_timeout，可以延长再均衡的时间，可以全局设置也可以在索引级别进行修改：\r\n\r\n```json\r\n#PUT /_all/_settings\r\n{\r\n\t\"settings\": {\r\n\t\t\"index.unassigned.node_left.delayed_timeout\": \"5m\"\r\n\t}\r\n}\r\n\r\n```\r\n\r\n## 58-优化-路由选择\r\n\r\n当我们查询文档的时候，Elasticsearch如何知道一个文档应该存放到哪个分片中呢？它其实是通过下面这个公式来计算出来：\r\n\r\n```\r\nshard = hash(routing) % number_of_primary_shards\r\n\r\n```\r\n\r\nrouting默认值是文档的id，也可以采用自定义值，比如用户id。\r\n\r\n### 不带routing查询\r\n\r\n在查询的时候因为不知道要查询的数据具体在哪个分片上，所以整个过程分为2个步骤\r\n\r\n- 分发：请求到达协调节点后，协调节点将查询请求分发到每个分片上。\r\n- 聚合：协调节点搜集到每个分片上查询结果，在将查询的结果进行排序，之后给用户返回结果。\r\n\r\n### 带routing查询\r\n\r\n查询的时候，可以直接根据routing信息定位到某个分配查询，不需要查询所有的分配，经过协调节点排序。向上面自定义的用户查询，如果routing设置为userid的话，就可以直接查询出数据来，效率提升很多。\r\n\r\n## 59-优化-写入速度优化\r\n\r\nES 的默认配置，是综合了数据可靠性、写入速度、搜索实时性等因素。实际使用时，我们需要根据公司要求，进行偏向性的优化。\r\n\r\n针对于搜索性能要求不高，但是对写入要求较高的场景，我们需要尽可能的选择恰当写优化策略。综合来说，可以考虑以下几个方面来提升写索引的性能：\r\n\r\n- 加大Translog Flush，目的是降低Iops、Writeblock。\r\n- 增加Index Refesh间隔，目的是减少Segment Merge的次数。\r\n- 调整Bulk线程池和队列。\r\n- 优化节点间的任务分布。\r\n- 优化Lucene层的索引建立，目的是降低CPU及IO。\r\n\r\n### 优化存储设备\r\n\r\nES 是一种密集使用磁盘的应用，在段合并的时候会频繁操作磁盘，所以对磁盘要求较高，当磁盘速度提升之后，集群的整体性能会大幅度提高。\r\n\r\n### 合理使用合并\r\n\r\nLucene以段的形式存储数据。当有新的数据写入索引时，Lucene就会自动创建一个新的段。\r\n\r\n随着数据量的变化，段的数量会越来越多，消耗的多文件句柄数及CPU就越多，查询效率就会下降。\r\n\r\n由于Lucene段合并的计算量庞大，会消耗大量的I/O，所以ES默认采用较保守的策略，让后台定期进行段合并。\r\n\r\n### 减少Refresh的次数\r\n\r\nLucene在新增数据时，采用了延迟写入的策略，默认情况下索引的refresh_interval为1秒。\r\n\r\nLucene将待写入的数据先写到内存中，超过1秒（默认）时就会触发一次Refresh，然后Refresh会把内存中的的数据刷新到操作系统的文件缓存系统中。\r\n\r\n如果我们对搜索的实效性要求不高，可以将Refresh周期延长，例如30秒。\r\n\r\n这样还可以有效地减少段刷新次数，但这同时意味着需要消耗更多的Heap内存。\r\n\r\n### 加大Flush设置\r\n\r\nFlush的主要目的是把文件缓存系统中的段持久化到硬盘，当Translog的数据量达到512MB或者30分钟时，会触发一次Flush。\r\n\r\nindex.translog.flush_threshold_size参数的默认值是512MB，我们进行修改。\r\n\r\n增加参数值意味着文件缓存系统中可能需要存储更多的数据，所以我们需要为操作系统的文件缓存系统留下足够的空间。\r\n\r\n### 减少副本的数量\r\n\r\nES为了保证集群的可用性，提供了Replicas（副本）支持，然而每个副本也会执行分析、索引及可能的合并过程，所以Replicas的数量会严重影响写索引的效率。\r\n\r\n当写索引时，需要把写入的数据都同步到副本节点，副本节点越多，写索引的效率就越慢。\r\n\r\n如果我们需要大批量进行写入操作，可以先禁止Replica复制，设置\r\nindex.number_of_replicas:0关闭副本。在写入完成后，Replica修改回正常的状态。\r\n\r\n## 60-优化-内存设置\r\n\r\nES默认安装后设置的内存是1GB，对于任何一个现实业务来说，这个设置都太小了。如果是通过解压安装的ES，则在ES安装文件中包含一个jvm.option文件，添加如下命令来设置ES的堆大小，Xms表示堆的初始大小，Xmx表示可分配的最大内存，都是1GB。\r\n\r\n确保Xmx和Xms的大小是相同的，其目的是为了能够在Java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小而浪费资源，可以减轻伸缩堆大小带来的压力。\r\n\r\n假设你有一个64G内存的机器，按照正常思维思考，你可能会认为把64G内存都给ES比较好，但现实是这样吗，越大越好？虽然内存对ES来说是非常重要的，但是答案是否定的！\r\n\r\n因为ES堆内存的分配需要满足以下两个原则：\r\n\r\n- 不要超过物理内存的50%：Lucene的设计目的是把底层OS里的数据缓存到内存中。Lucene的段是分别存储到单个文件中的，这些文件都是不会变化的，所以很利于缓存，同时操作系统也会把这些段文件缓存起来，以便更快的访问。如果我们设置的堆内存过大，Lucene可用的内存将会减少，就会严重影响降低Lucene的全文本查询性能。\r\n- 堆内存的大小最好不要超过32GB：在Java中，所有对象都分配在堆上，然后有一个KlassPointer指针指向它的类元数据。这个指针在64位的操作系统上为64位，64位的操作系统可以使用更多的内存（2^64）。在32位的系统上为32位，32位的操作系统的最大寻址空间为4GB（2^32）。但是64位的指针意味着更大的浪费，因为你的指针本身大了。浪费内存不算，更糟糕的是，更大的指针在主内存和缓存器（例如LLC,L1等）之间移动数据的时候，会占用更多的带宽。\r\n\r\n最终我们都会采用31G设置\r\n\r\n- -Xms 31g\r\n- -Xmx 31g\r\n\r\n假设你有个机器有128GB的内存，你可以创建两个节点，每个节点内存分配不超过32GB。也就是说不超过64GB内存给ES的堆内存，剩下的超过64GB的内存给Lucene。\r\n\r\n## 61-优化-重要配置\r\n\r\n| 参数名                             | 参数值        | 说明                                                         |\r\n| ---------------------------------- | ------------- | ------------------------------------------------------------ |\r\n| cluster.name                       | elasticsearch | 配置ES的集群名称，默认值是ES，建议改成与所存数据相关的名称，ES会自动发现在同一网段下的集群名称相同的节点。 |\r\n| node.name                          | node-1        | 集群中的节点名，在同一个集群中不能重复。节点的名称一旦设置，就不能再改变了。当然，也可以设置成服务器的主机名称，例如node.name:${HOSTNAME}。 |\r\n| node.master                        | true          | 指定该节点是否有资格被选举成为Master节点，默认是True，如果被设置为True，则只是有资格成为Master节点，具体能否成为Master节点，需要通过选举产生。 |\r\n| node.data                          | true          | 指定该节点是否存储索引数据，默认为True。数据 的增、删、改、查都是在Data节点完成的。 |\r\n| index.number_of_shards             | 1             | 设置都索引分片个数，默认是1片。也可以在创建索引时设置该值，具体设置为多大都值要根据数据量的大小来定。如果数据量不大，则设置成1时效率最高 |\r\n| index.number_of_replicas           | 1             | 设置默认的索引副本个数，默认为1个。副本数越多，集群的可用性越好，但是写索引时需要同步的数据越多。 |\r\n| transport.tcp.compress             | true          | 设置在节点间传输数据时是否压缩，默认为False， 不压缩        |\r\n| discovery.zen.minimum_master_nodes | 1             | 设置在选举Master节点时需要参与的最少的候选主节点数，默认为1。如果使用默认值，则当网络不稳定时有可能会出现脑裂。合理的数值为(master_eligible_nodes/2)+1，其中master_eligible_nodes表示集群中的候选主节点数 |\r\n| discovery.zen.ping.timeout         | 3s            | 设置在集群中自动发现其他节点时Ping连接的超时时间，默认为3秒。在较差的网络环境下需要设置得大一点，防止因误判该节点的存活状态而导致分片的转移 |\r\n\r\n# 第7章 Elasticsearch面试题\r\n\r\n## 62-面试题\r\n\r\n### 为什么要使用Elasticsearch？\r\n\r\n系统中的数据，随着业务的发展，时间的推移，将会非常多，而业务中往往采用模糊查询进行数据的搜索，而模糊查询会导致查询引擎放弃索引，导致系统查询数据时都是全表扫描，在百万级别的数据库中，查询效率是非常低下的，而我们使用ES做一个全文索引，将经常查询的系统功能的某些字段，比如说电商系统的商品表中商品名，描述、价格还有id这些字段我们放入ES索引库里，可以提高查询速度。\r\n\r\n### Elasticsearch的master选举流程？\r\n\r\n- Elasticsearch的选主是ZenDiscovery模块负责的，主要包含Ping（节点之间通过这个RPC来发现彼此）和Unicast（单播模块包含-一个主机列表以控制哪些节点需要ping通）这两部分。\r\n- 对所有可以成为master的节点（node master:true）根据nodeId字典排序，每次选举每个节点都把自己所知道节点排一次序，然后选出第一个（第0位）节点，暂且认为它是master节点。\r\n- 如果对某个节点的投票数达到一定的值（可以成为master节点数n/2+1）并且该节点自己也选举自己，那这个节点就是master。否则重新选举一直到满足上述条件。\r\n- master节点的职责主要包括集群、节点和索引的管理，不负责文档级别的管理；data节点可以关闭http功能。\r\n\r\n### Elasticsearch集群脑裂问题？\r\n\r\n“脑裂”问题可能的成因：\r\n\r\n- 网络问题：集群间的网络延迟导致一些节点访问不到master,认为master挂掉了从而选举出新的master,并对master上的分片和副本标红，分配新的主分片。\r\n- 节点负载：主节点的角色既为master又为data,访问量较大时可能会导致ES停止响应造成大面积延迟，此时其他节点得不到主节点的响应认为主节点挂掉了，会重新选取主节点。\r\n- 内存回收：data节点上的ES进程占用的内存较大，引发JVM的大规模内存回收，造成ES进程失去响应。\r\n\r\n脑裂问题解决方案：\r\n\r\n- 减少误判：discovery.zen ping_timeout节点状态的响应时间，默认为3s，可以适当调大，如果master在该响应时间的范围内没有做出响应应答，判断该节点已经挂掉了。调大参数（如6s，discovery.zen.ping_timeout:6），可适当减少误判。\r\n- 选举触发：discovery.zen.minimum._master_nodes:1，该参數是用于控制选举行为发生的最小集群主节点数量。当备选主节点的个數大于等于该参数的值，且备选主节点中有该参数个节点认为主节点挂了，进行选举。官方建议为(n /2)+1,n为主节点个数（即有资格成为主节点的节点个数）。\r\n- 角色分离：即master节点与data节点分离，限制角色\r\n  - 主节点配置为：node master: true，node data: false\r\n  - 从节点配置为：node master: false，node data: true\r\n\r\n### Elasticsearch索引文档的流程？\r\n\r\n![img](https://img-blog.csdnimg.cn/img_convert/1bdc6c30d1be9b1bff83a683c64d2ac7.png)\r\n\r\n- 协调节点默认使用文档ID参与计算（也支持通过routing），以便为路由提供合适的分片：shard = hash(document_id) % (num_of_primary_shards)\r\n- 当分片所在的节点接收到来自协调节点的请求后，会将请求写入到MemoryBuffer，然后定时（默认是每隔1秒）写入到FilesystemCache，这个从MemoryBuffer到FilesystemCache的过程就叫做refresh；\r\n- 当然在某些情况下，存在Momery Buffer和FilesystemCache的数据可能会丢失，ES是通过translog的机制来保证数据的可靠性的。其实现机制是接收到请求后，同时也会写入到translog中，当Filesystemcache中的数据写入到磁盘中时，才会清除掉，这个过程叫做flush；\r\n- 在flush过程中，内存中的缓冲将被清除，内容被写入一个新段，段的fsync将创建一个新的提交点，并将内容刷新到磁盘，旧的translog将被删除并开始一个新的translog。\r\n- flush触发的时机是定时触发（默认30分钟）或者translog变得太大（默认为512M）时；\r\n\r\n### Elasticsearch更新和删除文档的流程？\r\n\r\n- 删除和更新也都是写操作，但是Elasticsearch中的文档是不可变的，因此不能被删除或者改动以展示其变更；\r\n- 磁盘上的每个段都有一个相应的.del文件。当删除请求发送后，文档并没有真的被删除，而是在.del文件中被标记为删除。该文档依然能匹配查询，但是会在结果中被过滤掉。当段合并时，在.del文件中被标记为删除的文档将不会被写入新段。\r\n- 在新的文档被创建时，Elasticsearch会为该文档指定一个版本号，当执行更新时，旧版本的文档在.del文件中被标记为删除，新版本的文档被索引到一个新段。旧版本的文档依然能匹配查询，但是会在结果中被过滤掉。\r\n\r\n### Elasticsearch搜索的流程？\r\n\r\n![img](https://img-blog.csdnimg.cn/img_convert/053a14eee04ace7b4e5aec0ce53a5284.png)\r\n\r\n- 搜索被执行成一个两阶段过程，我们称之为Query Then Fetch；\r\n- 在初始查询阶段时，查询会广播到索引中每一个分片拷贝（主分片或者副本分片）。每个分片在本地执行搜索并构建一个匹配文档的大小为from+size的优先队列。PS：在搜索的时候是会查询Filesystem Cache的，但是有部分数据还在Memory Buffer，所以搜索是近实时的。\r\n- 每个分片返回各自优先队列中所有文档的ID和排序值给协调节点，它合并这些值到自己的优先队列中来产生一个全局排序后的结果列表。\r\n- 接下来就是取回阶段，协调节点辨别出哪些文档需要被取回并向相关的分片提交多个GET请求。每个分片加载并丰富文档，如果有需要的话，接着返回文档给协调节点。一旦所有的文档都被取回了，协调节点返回结果给客户端。\r\n- Query Then Fetch的搜索类型在文档相关性打分的时候参考的是本分片的数据，这样在文档数量较少的时候可能不够准确，DFS Query Then Fetch增加了一个预查询的处理，询问Term和Document frequency，这个评分更准确，但是性能会变差。\r\n\r\n### Elasticsearch在部署时，对Linux的设置有哪些优化方法？\r\n\r\n- 64GB内存的机器是非常理想的，但是32GB和16GB机器也是很常见的。少于8GB会适得其反。\r\n- 如果你要在更快的CPUs和更多的核心之间选择，选择更多的核心更好。多个内核提供的额外并发远胜过稍微快一点点的时钟频率。\r\n- 如果你负担得起SSD，它将远远超出任何旋转介质。基于SSD的节点，查询和索引性能都有提升。如果你负担得起，SSD是一个好的选择。\r\n- 即使数据中心们近在咫尺，也要避免集群跨越多个数据中心。绝对要避免集群跨越大的地理距离。\r\n- 请确保运行你应用程序的JVM和服务器的JVM是完全一样的。在Elasticsearch的几个地方，使用Java的本地序列化。\r\n- 通过设置gateway.recover_after_nodes、gateway.expected_nodes、gateway.recover_after_time可以在集群重启的时候避免过多的分片交换，这可能会让数据恢复从数个小时缩短为几秒钟。\r\n- Elasticsearch默认被配置为使用单播发现，以防止节点无意中加入集群。只有在同一台机器上运行的节点才会自动组成集群。最好使用单播代替组播。\r\n- 不要随意修改垃圾回收器（CMS）和各个线程池的大小。\r\n- 把你的内存的（少于）一半给Lucene（但不要超过32GB！），通过ES_HEAP_SIZE环境变量设置。\r\n- 内存交换到磁盘对服务器性能来说是致命的。如果内存交换到磁盘上，一个100微秒的操作可能变成10毫秒。再想想那么多10微秒的操作时延累加起来。不难看出swapping对于性能是多么可怕。\r\n- Lucene使用了大量的文件。同时，Elasticsearch在节点和HTTP客户端之间进行通信也使用了大量的套接字。所有这一切都需要足够的文件描述符。你应该增加你的文件描述符，设置一个很大的值，如64,000。\r\n\r\n### GC方面，在使用Elasticsearch时要注意什么？\r\n\r\n倒排词典的索引需要常驻内存，无法GC，需要监控data node 上 segment memory增长趋势。\r\n\r\n各类缓存，field cache, filter cache, indexing cache, bulk queue等等，要设置合理的大小，并且要应该根据最坏的情况来看heap是否够用，也就是各类缓存全部占满的时候，还有heap空间可以分配给其他任务吗？避免采用clear cache等“自欺欺人”的方式来释放内存。\r\n\r\n避免返回大量结果集的搜索与聚合。确实需要大量拉取数据的场景，可以采用scan & scroll api来实现。\r\n\r\ncluster stats驻留内存并无法水平扩展，超大规模集群可以考虑分拆成多个集群通过tribe node连接。\r\n\r\n想知道heap够不够，必须结合实际应用场景，并对集群的heap使用情况做持续的监控。\r\n\r\n### Elasticsearch对于大数据量（上亿量级）的聚合如何实现？\r\n\r\nElasticsearch提供的首个近似聚合是cardinality度量。它提供一个字段的基数，即该字段的 distinct或者unique值的数目。它是基于HLL算法的。HLL会先对我们的输入作哈希运算，然后根据哈希运算的结果中的bits做概率估算从而得到基数。其特点是：可配置的精度，用来控制内存的使用（更精确＝更多内存）；小的数据集精度是非常高的；我们可以通过配置参数，来设置去重需要的固定内存使用量。无论数千还是数十亿的唯一值，内存使用量只与你配置的精确度相关。\r\n\r\n### 在并发情况下，Elasticsearch如果保证读写一致？\r\n\r\n- 可以通过版本号使用乐观并发控制，以确保新版本不会被旧版本覆盖，由应用层来处理具体的冲突；\r\n- 另外对于写操作，一致性级别支持quorum/one/all，默认为quorum，即只有当大多数分片可用时才允许写操作。但即使大多数可用，也可能存在因为网络等原因导致写入副本失败，这样该副本被认为故障，分片将会在一个不同的节点上重建。\r\n- 对于读操作，可以设置replication为sync(默认)，这使得操作在主分片和副本分片都完成后才会返回；如果设置replication为async时，也可以通过设置搜索请求参数_preference为primary来查询主分片，确保文档是最新版本。\r\n\r\n### 如何监控Elasticsearch集群状态？\r\n\r\n1. elasticsearch-head插件。\r\n2. 通过Kibana监控Elasticsearch。你可以实时查看你的集群健康状态和性能，也可以分析过去的集群、索引和节点指标\r\n\r\n### 是否了解字典树？\r\n\r\n字典树又称单词查找树，Trie树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。\r\n\r\nTrie的核心思想是空间换时间，利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。它有3个基本性质：\r\n\r\n- 根节点不包含字符，除根节点外每一个节点都只包含一个字符。\r\n- 从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。\r\n- 每个节点的所有子节点包含的字符都不相同。\r\n\r\n对于中文的字典树，每个节点的子节点用一个哈希表存储，这样就不用浪费太大的空间，而且查询速度上可以保留哈希的复杂度O(1)。\r\n\r\n### Elasticsearch中的集群、节点、索引、文档、类型是什么？\r\n\r\n- 集群是一个或多个节点（服务器）的集合，它们共同保存您的整个数据，并提供跨所有节点的联合索引和搜索功能。群集由唯一名称标识，默认情况下为\"elasticsearch\"。此名称很重要，因为如果节点设置为按名称加入群集，则该节点只能是群集的一部分。\r\n- 节点是属于集群一部分的单个服务器。它存储数据并参与群集索引和搜索功能。\r\n- 索引就像关系数据库中的“数据库”。它有一个定义多种类型的映射。索引是逻辑名称空间，映射到一个或多个主分片，并且可以有零个或多个副本分片。MySQL=>数据库，Elasticsearch=>索引。\r\n- 文档类似于关系数据库中的一行。不同之处在于索引中的每个文档可以具有不同的结构(字段)，但是对于通用字段应该具有相同的数据类型。MySQL=>Databases=>Tables=>Columns/Rows，Elasticsearch=>Indices=>Types=>具有属性的文档Doc。\r\n- 类型是索引的逻辑类别/分区，其语义完全取决于用户。\r\n\r\n### Elasticsearch中的倒排索引是什么？\r\n\r\n倒排索引是搜索引擎的核心。搜索引擎的主要目标是在查找发生搜索条件的文档时提供快速搜索。ES中的倒排索引其实就是lucene的倒排索引，区别于传统的正向索引，倒排索引会再存储数据时将关键词和数据进行关联，保存到倒排表中，然后查询时，将查询内容进行分词后在倒排表中进行查询，最后匹配数据即可。","categories":[{"name":"数据库","path":"api/categories/数据库.json"}],"tags":[]}