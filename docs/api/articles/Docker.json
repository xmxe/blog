{"title":"Docker","slug":"Docker","date":"2022-09-28T07:09:19.982Z","updated":"2023-03-23T01:42:50.165Z","comments":true,"path":"api/articles/Docker.json","excerpt":null,"covers":"https://pic2.zhimg.com/v2-98bbd70b053dd779240634a00c7f0950_1440w.jpg","content":"<h4 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h4><h5 id=\"在线安装\"><a href=\"#在线安装\" class=\"headerlink\" title=\"在线安装\"></a>在线安装</h5><ol>\n<li>安装docker需要关闭selinux,由于selinux和LXC（Docker实现虚拟化的方式）有冲突，所以需要禁用selinux。编辑&#x2F;etc&#x2F;selinux&#x2F;config，设置两个关键变量。<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token assign-left variable\">SELINUX</span><span class=\"token operator\">=</span>disabled\n\n<span class=\"token assign-left variable\">SELINUXTYPE</span><span class=\"token operator\">=</span>targeted<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre></li>\n<li>关闭防火墙</li>\n<li>安装容器<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">yum <span class=\"token parameter variable\">-y</span> <span class=\"token function\">install</span> docker-ce<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n<li>启动服务<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">systemctl start <span class=\"token function\">docker</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n<li>测试容器<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> run hello-world\n\n<span class=\"token comment\"># PS:</span>\n<span class=\"token comment\"># centos7安装命令 yum -y install docker-ce</span>\n<span class=\"token comment\"># ubuntu安装命令 apt install docker-ce</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ol>\n<h5 id=\"离线安装\"><a href=\"#离线安装\" class=\"headerlink\" title=\"离线安装\"></a>离线安装</h5><ol>\n<li><p>下载离线包 <a href=\"https://download.docker.com/linux/static/stable/x86_64/\">https://download.docker.com/linux/static/stable/x86_64/</a></p>\n</li>\n<li><p>解压</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">tar</span> <span class=\"token parameter variable\">-xvf</span> docker-18.06.1-ce.tgz<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n<li><p>将解压出来的docker文件内容移动到&#x2F;usr&#x2F;bin&#x2F;目录下</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">cp</span> docker/* /usr/bin/<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>4.将docker注册为service：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># vim /etc/systemd/system/docker.service</span>\n\n<span class=\"token comment\"># lib/systemd/system、/usr/lib/systemd/system、/etc/systemd/system都可以，lib/systemd/system真实地址是/usr/lib/system/system地址，</span>\n<span class=\"token comment\"># /usr/lib/systemd/system/ 软件包安装的单元</span>\n<span class=\"token comment\"># /etc/systemd/system/ 系统管理员安装的单元,优先级更高</span>\n<span class=\"token comment\"># 优先级为 /etc/systemd/system，/run/systemd/system，/lib/systemd/system</span>\n<span class=\"token comment\"># 如果同一选项三个地方都配置了，优先级高的会覆盖优先级低的。</span>\n\n<span class=\"token punctuation\">[</span>Unit<span class=\"token punctuation\">]</span>\n<span class=\"token assign-left variable\">Description</span><span class=\"token operator\">=</span>Docker Application Container Engine\n<span class=\"token assign-left variable\">Documentation</span><span class=\"token operator\">=</span>https://docs.docker.com\n<span class=\"token assign-left variable\">After</span><span class=\"token operator\">=</span>network-online.target firewalld.service\n<span class=\"token assign-left variable\">Wants</span><span class=\"token operator\">=</span>network-online.target\n\n<span class=\"token punctuation\">[</span>Service<span class=\"token punctuation\">]</span>\n\n<span class=\"token assign-left variable\">Type</span><span class=\"token operator\">=</span>notify\n<span class=\"token comment\"># the default is not to use systemd for cgroups because the delegate issues still</span>\n<span class=\"token comment\"># exists and systemd currently does not support the cgroup feature set required</span>\n<span class=\"token comment\"># for containers run by docker</span>\n\n<span class=\"token assign-left variable\">ExecStart</span><span class=\"token operator\">=</span>/usr/bin/dockerd <span class=\"token parameter variable\">-H</span> tcp://0.0.0.0:2375 <span class=\"token parameter variable\">-H</span> unix://var/run/docker.sock\n\n<span class=\"token assign-left variable\">ExecReload</span><span class=\"token operator\">=</span>/bin/kill <span class=\"token parameter variable\">-s</span> HUP <span class=\"token variable\">$MAINPID</span>\n\n<span class=\"token comment\"># Having non-zero Limit*s causes performance problems due to accounting overhead</span>\n<span class=\"token comment\"># in the kernel. We recommend using cgroups to do container-local accounting.</span>\n\n<span class=\"token assign-left variable\">LimitNOFILE</span><span class=\"token operator\">=</span>infinity\n\n<span class=\"token assign-left variable\">LimitNPROC</span><span class=\"token operator\">=</span>infinity\n\n<span class=\"token assign-left variable\">LimitCORE</span><span class=\"token operator\">=</span>infinity\n\n<span class=\"token comment\"># Uncomment TasksMax if your systemd version supports it.</span>\n<span class=\"token comment\"># Only systemd 226 and above support this version.</span>\n<span class=\"token comment\"># TasksMax=infinity</span>\n\n<span class=\"token assign-left variable\">TimeoutStartSec</span><span class=\"token operator\">=</span><span class=\"token number\">0</span>\n\n<span class=\"token comment\"># set delegate yes so that systemd does not reset the cgroups of docker containers</span>\n\n<span class=\"token assign-left variable\">Delegate</span><span class=\"token operator\">=</span>yes\n\n<span class=\"token comment\"># kill only the docker process, not all processes in the cgroup</span>\n\n<span class=\"token assign-left variable\">KillMode</span><span class=\"token operator\">=</span>process\n\n<span class=\"token comment\"># restart the docker process if it exits prematurely</span>\n\n<span class=\"token assign-left variable\">Restart</span><span class=\"token operator\">=</span>on-failure\n\n<span class=\"token assign-left variable\">StartLimitBurst</span><span class=\"token operator\">=</span><span class=\"token number\">3</span>\n\n<span class=\"token assign-left variable\">StartLimitInterval</span><span class=\"token operator\">=</span>60s\n\n\n<span class=\"token punctuation\">[</span>Install<span class=\"token punctuation\">]</span>\n\n<span class=\"token assign-left variable\">WantedBy</span><span class=\"token operator\">=</span>multi-user.target<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>添加文件权限并启动docker</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">chmod</span> +x /etc/systemd/system/docker.service<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n<li><p>重载unit配置文件</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">systemctl daemon-reload<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n<li><p>启动Docker</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">systemctl start <span class=\"token function\">docker</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n<li><p>设置开机自启</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">systemctl <span class=\"token builtin class-name\">enable</span> docker.service<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n<li><p>查看Docker状态</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">systemctl status <span class=\"token function\">docker</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n<li><p>查看Docker版本</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> <span class=\"token parameter variable\">-v</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n</ol>\n<h4 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h4><h5 id=\"镜像\"><a href=\"#镜像\" class=\"headerlink\" title=\"镜像\"></a>镜像</h5><ul>\n<li><p>查看镜像</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker images\n-a :列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）；\n--digests :显示镜像的摘要信息；\n-f :显示满足条件的镜像；\n--format :指定返回值的模板文件；\n--no-trunc :显示完整的镜像信息；\n-q :只显示镜像ID。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>拉取镜像</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker pull name:tag<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>推送镜像</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker push myapache:v1<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>导出镜像</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker save -o &lt;保存路径&gt; &lt;镜像名称:标签&gt;\n\ndocker save -o .&#x2F;ubuntu18.tar ubuntu:18.04<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>导入镜像</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker load -i 文件名 或者docker load --input 文件名\n\ndocker load --input .&#x2F;ubuntu18.tar<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>删除镜像</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker rmi images_id<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>删除所有镜像</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker rmi &#96;docker images -q&#96;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>搜索镜像</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker search *<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>查看指定镜像的创建历史</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker history [OPTIONS] IMAGE\n\nOPTIONS说明：\n-H :以可读的格式打印镜像大小和日期，默认为true；\n--no-trunc :显示完整的提交记录；\n-q :仅列出提交记录ID。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h5 id=\"容器\"><a href=\"#容器\" class=\"headerlink\" title=\"容器\"></a>容器</h5><ul>\n<li><p>查看正在运行的容器</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker ps 或者docker container ls<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>查看所有容器</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker ps -a 或者 docker container ls -a<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>导出容器</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker export &lt;容器名&gt; &gt; &lt;保存路径&gt;\n\n或者docker export -o &lt;容器名&gt; &lt;保存路径&gt; -o :将输入内容写到文件。\ndocker export ubuntu18 &gt; .&#x2F;ubuntu18.tar\n将id为a404c6c174a2的容器按日期保存为tar文件\ndocker export -o mysql-&#96;date +%Y%m%d&#96;.tar a404c6c174a2<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>导入容器</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker import &lt;文件路径&gt; &lt;容器名&gt;\ndocker import .&#x2F;ubuntu18.tar ubuntu18<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</li>\n<li><p>删除容器</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker rm [OPTIONS] container_id\n\nOPTIONS说明：\n-f :通过 SIGKILL 信号强制删除一个运行中的容器。\n-l :移除容器间的网络连接，而非容器本身。\n-v :删除与容器关联的卷。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>删除所有容器</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker rm $(docker ps -a -q) \n或者\ndocker rm &#96;docker ps -a -q&#96;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>启动容器</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker container start container_id<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>停止所有容器</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker stop $(docker ps -a -q)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>杀掉运行中的容器</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker kill -s(可忽略) CONTAINER\n-s :向容器发送一个信号 \n例：docker kill -s KILL mynginx<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>在运行的容器中执行命令</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker exec [OPTIONS] CONTAINER COMMAND [ARG...]\n例如：进入容器 docker exec -itd 容器id &#x2F;bin&#x2F;bash\n（-d :分离模式: 在后台运行 -i :即使没有附加也保持STDIN 打开-t :分配一个伪终端）\n&#x2F;bin&#x2F;bash：在container中启动一个bash shell\nexit 退出bash shell<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>暂停容器中所有的进程</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker pause container_id<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>恢复容器中所有的进程</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker unpause container_id<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>创建一个新的容器不运行</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker create 参数同docker run<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>创建一个新的容器并运行</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker run\n-i: 以交互模式运行容器，通常与-t同时使用\n-t: 为容器重新分配一个伪输入终端，通常与-i同时使用\n-it 以交互模式运行\n-P: 随机端口映射，容器内部端口随机映射到主机的端口\n-p: 指定端口映射，格式为：主机(宿主)端口:容器端口\n-d 后台运行 并返回容器ID\n-v,--volume 挂载 主机目录:容器目录,绑定一个卷\n-u,--user&#x3D;&quot;&quot;， 指定容器的用户\n-a,--attach&#x3D;[]， 登录容器（必须是以docker run -d启动的容器）\n-w,--workdir&#x3D;&quot;&quot;， 指定容器的工作目录\n-c,--cpu-shares&#x3D;0， 设置容器CPU权重，在CPU共享场景使用\n-e username&#x3D;&quot;ritchie&quot;,--env&#x3D;[] 设置环境变量容器中可以使用该环境变量\n-m,--memory&#x3D;&quot;&quot;， 指定容器的内存上限\n-P,--publish-all&#x3D;false，指定容器暴露的端口\n-h,--hostname&#x3D;&quot;&quot;， 指定容器的主机名\n--name&#x3D;”” 容器命名\n--cap-add&#x3D;[]添加权限，权限清单详见：\thttp:&#x2F;&#x2F;linux.die.net&#x2F;man&#x2F;7&#x2F;capabilities\n--cap-drop&#x3D;[]删除权限，权限清单详见：\thttp:&#x2F;&#x2F;linux.die.net&#x2F;man&#x2F;7&#x2F;capabilities\n--cidfile&#x3D;&quot;&quot; 运行容器后,在指定文件中写入容器PID值，一种典型的监控系\t统用法\n--cpuset&#x3D;&quot;&quot;， 设置容器可以使用哪些CPU，此参数可以用来容器独占CPU\n--device&#x3D;[]， 添加主机设备给容器，相当于设备直通\n--dns&#x3D;[]， 指定容器的dns服务器\n--dns-search&#x3D;[]指定容器的dns搜索域名,写入到容器的&#x2F;etc&#x2F;resolv.conf文\t件\n--entrypoint&#x3D;&quot;&quot;， 覆盖image的入口点\n--env-file&#x3D;[]， 从指定文件读入环境变量\n--expose&#x3D;[]， 指定容器暴露的端口，即修改镜像的暴露端口\n--link&#x3D;[]， 添加链接到另一个容器，使用其他容器的IP、env等信息\n--lxc-conf&#x3D;[]， 指定容器的配置文件，只有在指定--exec-driver&#x3D;lxc时\t使用\n--net&#x3D;&quot;bridge&quot;， 容器网络设置:\nbridge 使用docker daemon指定的网桥\nhost 容器使用主机的网络\ncontainer:NAME_or_ID &gt; 使用其他容器的网路，共享IP和PORT等网络资源\nnone 容器使用自己的网络（类似--net&#x3D;bridge），但是不进行配置\n--privileged&#x3D;false指定容器是否为特权容器,特权容器拥有所有的capabilities\n--restart&#x3D;&quot;no&quot;，指定容器停止后的重启策略:\nno - 容器退出时不重启\non-failure - 只在容器以非0状态码退出时重启。可选的，可以退出docker daemon尝试重启容器的次数\nalways – 不管退出状态码是什么始终重启容器。当指定always时，docker daemon将无限次数地重启容器。容器也会在daemon启动时尝试重启，不管容器当时的状态如何。\nunless-stopped – 不管退出状态码是什么始终重启容器，不过当daemon启动时，如果容器之前已经为停止状态，不要尝试启动它。\n--rm&#x3D;false指定容器停止后自动删除容器(不支持以docker run -d启动的容器)\n--sig-proxy&#x3D;true 设置由代理接受并处理信号，但是SIGCHLD、SIGSTOP和\tSIGKILL不能被代理<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>获取容器&#x2F;镜像的元数据</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker inspect [OPTIONS] NAME|ID [NAME|ID...]\nOPTIONS说明：\n-f :指定返回值的模板文件。\n-s :显示总的文件大小。\n--type :为指定类型返回JSON。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>查看容器中运行的进程信息</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker top container_id<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>连接到正在运行中的容器</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker attach container_id<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>阻塞运行直到容器停止，然后打印出它的退出代码</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker wait containser_id<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n</ul>\n<h5 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h5><ul>\n<li><p>从服务器获取实时事件</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker events OPTIONS\n\nOPTIONS说明：\n-f ：根据条件过滤事件；\n--since ：从指定的时间戳后显示所有事件;\n--until ：流水时间显示到指定的时间为止；\ndocker events --since&#x3D;&quot;1467302400&quot;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>查看日志</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker logs [OPTIONS] CONTAINER\n--details 显示更多的信息\n-f, --follow 跟踪实时日志\n--since string 显示自某个timestamp之后的日志，或相对时间，如42m（即42分钟）\n--tail string 从日志末尾显示多少行日志，默认是all\n-t, --timestamps 显示时间戳\n--until string 显示自某个timestamp之前的日志，或相对时间，如42m（即42分钟）\n\n查看指定时间后的日志，只显示最后100行：\ndocker logs -f -t --since&#x3D;&quot;2018-02-08&quot; --tail&#x3D;100 CONTAINER_ID\n查看最近30分钟的日志:\ndocker logs --since 30m CONTAINER_ID\n查看某时间之后的日志：\ndocker logs -t --since&#x3D;&quot;2018-02-08T13:23:37&quot; CONTAINER_ID\n查看某时间段日志：\ndocker logs -t --since&#x3D;&quot;2018-02-08T13:23:37&quot; --until &quot;2018-02-09T12:23:37&quot; CONTAINER_ID<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>列出指定的容器的端口映射</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker port container_id<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>提交</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]\n\nOPTIONS说明：\n-a :提交的镜像作者；\n-c :使用Dockerfile指令来创建镜像；\n-m :提交时的说明文字；\n-p :在commit时，将容器暂停。\n\n将容器a404c6c174a2 保存为新的镜像,并添加提交人信息和说明信息。\ndocker commit -a &quot;runoob.com&quot; -m &quot;my apache&quot; a404c6c174a2 mymysql:v1<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>容器与主机之间的数据拷贝</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">将主机&#x2F;www&#x2F;runoob目录拷贝到容器96f7f14e99ab的&#x2F;www目录下。\ndocker cp &#x2F;www&#x2F;runoob 96f7f14e99ab:&#x2F;www&#x2F;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</li>\n<li><p>查看容器文件结构更改</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker diff mymysql<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>使用 Dockerfile 创建镜像</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker build\n--build-arg&#x3D;[] :设置镜像创建时的变量；\n--cpu-shares :设置 cpu 使用权重；\n--cpu-period :限制 CPU CFS周期；\n--cpu-quota :限制 CPU CFS配额；\n--cpuset-cpus :指定使用的CPU id；\n--cpuset-mems :指定使用的内存 id；\n--disable-content-trust :忽略校验，默认开启；\n-f :指定要使用的Dockerfile路径；\n--force-rm :设置镜像过程中删除中间容器；\n--isolation :使用容器隔离技术；\n--label&#x3D;[] :设置镜像使用的元数据；\n-m :设置内存最大值；\n--memory-swap :设置Swap的最大值为内存+swap，&quot;-1&quot;表示不限swap；\n--no-cache :创建镜像的过程不使用缓存；\n--pull :尝试去更新镜像的新版本；\n--quiet, -q :安静模式，成功后只输出镜像 ID；\n--rm :设置镜像成功后删除中间容器；\n--shm-size :设置&#x2F;dev&#x2F;shm的大小，默认值是64M；\n--ulimit :Ulimit配置。\n--squash :将Dockerfile中所有的操作压缩为一层。\n--tag, -t: 镜像的名字及标签，通常name:tag或者name格式；可以在一次构建中为一个镜像设置多个标签。\n--network: 默认default。在构建期间设置RUN指令的网络模式<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>登陆到一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker login -u -p\n-u 登陆的用户名 -p :登陆的密码<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</li>\n<li><p>登出一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库Docker Hub</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker logout<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>标记本地镜像，将其归入某一仓库</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker tag<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n</ul>\n<h4 id=\"docker加速命令\"><a href=\"#docker加速命令\" class=\"headerlink\" title=\"docker加速命令\"></a>docker加速命令</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">curl -sSL https:&#x2F;&#x2F;get.daocloud.io&#x2F;daotools&#x2F;set_mirror.sh | sh -s http:&#x2F;&#x2F;f1361db2.m.daocloud.io\n或\nvim &#x2F;etc&#x2F;docker&#x2F;daemon.json\n&#123;\n  &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;registry.docker-cn.com&quot;]\n&#125;\n\n其他站点\nhttp:&#x2F;&#x2F;hub-mirror.c.163.com\nhttps:&#x2F;&#x2F;3laho3y3.mirror.aliyuncs.com\nhttp:&#x2F;&#x2F;f1361db2.m.daocloud.io\nhttps:&#x2F;&#x2F;mirror.ccs.tencentyun.com\nhttps:&#x2F;&#x2F;docker.mirrors.ustc.edu.cn<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"与Spring-Boot\"><a href=\"#与Spring-Boot\" class=\"headerlink\" title=\"与Spring Boot\"></a>与Spring Boot</h4><ul>\n<li><a href=\"https://mp.weixin.qq.com/s/15ZAVUg5DfcF53QpEetT7Q\">一键部署Spring Boot到远程Docker容器</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/dP-c3twzR0PMUvPWZA-U0Q\">Jenkins+Docker一键自动化部署SpringBoot项目</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/CXUwpTbAVoXEeB7EcrCjAw\">搭建SpringBoot项目并将其Docker化</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=Mzg2MDYzODI5Nw==&mid=2247493762&idx=1&sn=114663a4a13ba5bb27d05e0d77de37c1&source=41#wechat_redirect\">SpringBoot使用Docker快速部署项目</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/du2sypGQczJh7gQz_4IX9g\">Docker部署Spring Boot项目的2种方式！</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=Mzg2MDYzODI5Nw==&mid=2247493962&idx=1&sn=af6c945d629003cfd30564698c017598&source=41#wechat_redirect\">SpringBoot项目构建Docker镜像深度调优</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/01SZo3NNf5zuAC8wAI6C-g\">还在手动部署springboot项目？不妨试试它，让你部署项目飞起来！</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/HSRIYQVKR9TGtwetd3LU5w\">Docker+Spring Boot+FastDFS搭建一套分布式文件服务器，太强了！</a></li>\n</ul>\n<h4 id=\"相关文章\"><a href=\"#相关文章\" class=\"headerlink\" title=\"相关文章\"></a>相关文章</h4><ul>\n<li><a href=\"https://mp.weixin.qq.com/s/ELZo2z4fHonoBGXQI0M9CA\">图解Docker架构，傻瓜都能看懂！</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/gmZDBuYDXnNdykEx66Y0Cw\">构建Java镜像的10个最佳实践</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/LOmqsoBJd7h1HPwf0i1uwQ\">10个冷门但又非常实用的Docker使用技巧！！</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/tTsizeLeVyvQ44GXMNqrjA\">Docker实战总结</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/t81enr-ypBxk1K4lYqWZww\">Docker从入门到干活，看这一篇足矣</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/x-M5iKvvuseIQwUdVmxSPQ\">如何编写最佳的Dockerfile</a></li>\n<li><a href=\"https://www.jianshu.com/p/658911a8cff3\">Docker：Docker Compose详解</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/fB59zXK7cPBt1asSyUpqDg\">CentOS&#x2F;Ubuntu安装Docker和Docker Compose</a></li>\n<li><a href=\"http://guide.daocloud.io/dcs/docker-9152677.html\">DaoCloud安装docker指南</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/fzlNnJe9SMA5k3TDXOfZUA\">Docker常用命令，还有谁不会？</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/PpI7_fY5ACjmtmnlqr7ZMQ\">一款吊炸天的Docker图形化工具，太强大</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/w0sFaHApOSrwgva0886ijQ\">5款顶级Docker容器GUI管理工具！免费又好用</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/rAOsia2LU2_Fl4vrjQ2tvA\">Docker轻量级编排创建工具Humpback</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/6smzsvYSbRvSPcpbfnH98A\">带着问题学Kubernetes架构！</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/B2tIs6YitA93iYxEZ_8Ovw\">为什么大家都在学习k8s</a></li>\n<li><a href=\"https://kuboard.cn/\">Kuboard-Kubernetes多集群管理界面</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/WWRp-e9QPcLg8-m-V3UU1Q\">图文详解Kubernetes，傻瓜都能看懂！</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/8UJnsx0NJyxlKXeduhg5Yw\">Kubernetes缺少的多租户功能，你可以通过这些方式实现</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/yg5ACCeeyJa0AVP1LatUhA\">IDEA使用Docker插件，实现一键自动化部署</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/KU3bpxiNbHGJQ_XVRqsedg\">Docker有几种网络模式</a></li>\n</ul>\n","more":"<h4 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h4><h5 id=\"在线安装\"><a href=\"#在线安装\" class=\"headerlink\" title=\"在线安装\"></a>在线安装</h5><ol>\n<li>安装docker需要关闭selinux,由于selinux和LXC（Docker实现虚拟化的方式）有冲突，所以需要禁用selinux。编辑&#x2F;etc&#x2F;selinux&#x2F;config，设置两个关键变量。<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token assign-left variable\">SELINUX</span><span class=\"token operator\">=</span>disabled\n\n<span class=\"token assign-left variable\">SELINUXTYPE</span><span class=\"token operator\">=</span>targeted<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre></li>\n<li>关闭防火墙</li>\n<li>安装容器<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">yum <span class=\"token parameter variable\">-y</span> <span class=\"token function\">install</span> docker-ce<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n<li>启动服务<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">systemctl start <span class=\"token function\">docker</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n<li>测试容器<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> run hello-world\n\n<span class=\"token comment\"># PS:</span>\n<span class=\"token comment\"># centos7安装命令 yum -y install docker-ce</span>\n<span class=\"token comment\"># ubuntu安装命令 apt install docker-ce</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ol>\n<h5 id=\"离线安装\"><a href=\"#离线安装\" class=\"headerlink\" title=\"离线安装\"></a>离线安装</h5><ol>\n<li><p>下载离线包 <a href=\"https://download.docker.com/linux/static/stable/x86_64/\">https://download.docker.com/linux/static/stable/x86_64/</a></p>\n</li>\n<li><p>解压</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">tar</span> <span class=\"token parameter variable\">-xvf</span> docker-18.06.1-ce.tgz<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n<li><p>将解压出来的docker文件内容移动到&#x2F;usr&#x2F;bin&#x2F;目录下</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">cp</span> docker/* /usr/bin/<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>4.将docker注册为service：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># vim /etc/systemd/system/docker.service</span>\n\n<span class=\"token comment\"># lib/systemd/system、/usr/lib/systemd/system、/etc/systemd/system都可以，lib/systemd/system真实地址是/usr/lib/system/system地址，</span>\n<span class=\"token comment\"># /usr/lib/systemd/system/ 软件包安装的单元</span>\n<span class=\"token comment\"># /etc/systemd/system/ 系统管理员安装的单元,优先级更高</span>\n<span class=\"token comment\"># 优先级为 /etc/systemd/system，/run/systemd/system，/lib/systemd/system</span>\n<span class=\"token comment\"># 如果同一选项三个地方都配置了，优先级高的会覆盖优先级低的。</span>\n\n<span class=\"token punctuation\">[</span>Unit<span class=\"token punctuation\">]</span>\n<span class=\"token assign-left variable\">Description</span><span class=\"token operator\">=</span>Docker Application Container Engine\n<span class=\"token assign-left variable\">Documentation</span><span class=\"token operator\">=</span>https://docs.docker.com\n<span class=\"token assign-left variable\">After</span><span class=\"token operator\">=</span>network-online.target firewalld.service\n<span class=\"token assign-left variable\">Wants</span><span class=\"token operator\">=</span>network-online.target\n\n<span class=\"token punctuation\">[</span>Service<span class=\"token punctuation\">]</span>\n\n<span class=\"token assign-left variable\">Type</span><span class=\"token operator\">=</span>notify\n<span class=\"token comment\"># the default is not to use systemd for cgroups because the delegate issues still</span>\n<span class=\"token comment\"># exists and systemd currently does not support the cgroup feature set required</span>\n<span class=\"token comment\"># for containers run by docker</span>\n\n<span class=\"token assign-left variable\">ExecStart</span><span class=\"token operator\">=</span>/usr/bin/dockerd <span class=\"token parameter variable\">-H</span> tcp://0.0.0.0:2375 <span class=\"token parameter variable\">-H</span> unix://var/run/docker.sock\n\n<span class=\"token assign-left variable\">ExecReload</span><span class=\"token operator\">=</span>/bin/kill <span class=\"token parameter variable\">-s</span> HUP <span class=\"token variable\">$MAINPID</span>\n\n<span class=\"token comment\"># Having non-zero Limit*s causes performance problems due to accounting overhead</span>\n<span class=\"token comment\"># in the kernel. We recommend using cgroups to do container-local accounting.</span>\n\n<span class=\"token assign-left variable\">LimitNOFILE</span><span class=\"token operator\">=</span>infinity\n\n<span class=\"token assign-left variable\">LimitNPROC</span><span class=\"token operator\">=</span>infinity\n\n<span class=\"token assign-left variable\">LimitCORE</span><span class=\"token operator\">=</span>infinity\n\n<span class=\"token comment\"># Uncomment TasksMax if your systemd version supports it.</span>\n<span class=\"token comment\"># Only systemd 226 and above support this version.</span>\n<span class=\"token comment\"># TasksMax=infinity</span>\n\n<span class=\"token assign-left variable\">TimeoutStartSec</span><span class=\"token operator\">=</span><span class=\"token number\">0</span>\n\n<span class=\"token comment\"># set delegate yes so that systemd does not reset the cgroups of docker containers</span>\n\n<span class=\"token assign-left variable\">Delegate</span><span class=\"token operator\">=</span>yes\n\n<span class=\"token comment\"># kill only the docker process, not all processes in the cgroup</span>\n\n<span class=\"token assign-left variable\">KillMode</span><span class=\"token operator\">=</span>process\n\n<span class=\"token comment\"># restart the docker process if it exits prematurely</span>\n\n<span class=\"token assign-left variable\">Restart</span><span class=\"token operator\">=</span>on-failure\n\n<span class=\"token assign-left variable\">StartLimitBurst</span><span class=\"token operator\">=</span><span class=\"token number\">3</span>\n\n<span class=\"token assign-left variable\">StartLimitInterval</span><span class=\"token operator\">=</span>60s\n\n\n<span class=\"token punctuation\">[</span>Install<span class=\"token punctuation\">]</span>\n\n<span class=\"token assign-left variable\">WantedBy</span><span class=\"token operator\">=</span>multi-user.target<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>添加文件权限并启动docker</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">chmod</span> +x /etc/systemd/system/docker.service<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n<li><p>重载unit配置文件</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">systemctl daemon-reload<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n<li><p>启动Docker</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">systemctl start <span class=\"token function\">docker</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n<li><p>设置开机自启</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">systemctl <span class=\"token builtin class-name\">enable</span> docker.service<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n<li><p>查看Docker状态</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">systemctl status <span class=\"token function\">docker</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n<li><p>查看Docker版本</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> <span class=\"token parameter variable\">-v</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n</ol>\n<h4 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h4><h5 id=\"镜像\"><a href=\"#镜像\" class=\"headerlink\" title=\"镜像\"></a>镜像</h5><ul>\n<li><p>查看镜像</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker images\n-a :列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）；\n--digests :显示镜像的摘要信息；\n-f :显示满足条件的镜像；\n--format :指定返回值的模板文件；\n--no-trunc :显示完整的镜像信息；\n-q :只显示镜像ID。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>拉取镜像</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker pull name:tag<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>推送镜像</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker push myapache:v1<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>导出镜像</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker save -o &lt;保存路径&gt; &lt;镜像名称:标签&gt;\n\ndocker save -o .&#x2F;ubuntu18.tar ubuntu:18.04<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>导入镜像</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker load -i 文件名 或者docker load --input 文件名\n\ndocker load --input .&#x2F;ubuntu18.tar<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>删除镜像</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker rmi images_id<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>删除所有镜像</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker rmi &#96;docker images -q&#96;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>搜索镜像</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker search *<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>查看指定镜像的创建历史</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker history [OPTIONS] IMAGE\n\nOPTIONS说明：\n-H :以可读的格式打印镜像大小和日期，默认为true；\n--no-trunc :显示完整的提交记录；\n-q :仅列出提交记录ID。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h5 id=\"容器\"><a href=\"#容器\" class=\"headerlink\" title=\"容器\"></a>容器</h5><ul>\n<li><p>查看正在运行的容器</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker ps 或者docker container ls<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>查看所有容器</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker ps -a 或者 docker container ls -a<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>导出容器</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker export &lt;容器名&gt; &gt; &lt;保存路径&gt;\n\n或者docker export -o &lt;容器名&gt; &lt;保存路径&gt; -o :将输入内容写到文件。\ndocker export ubuntu18 &gt; .&#x2F;ubuntu18.tar\n将id为a404c6c174a2的容器按日期保存为tar文件\ndocker export -o mysql-&#96;date +%Y%m%d&#96;.tar a404c6c174a2<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>导入容器</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker import &lt;文件路径&gt; &lt;容器名&gt;\ndocker import .&#x2F;ubuntu18.tar ubuntu18<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</li>\n<li><p>删除容器</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker rm [OPTIONS] container_id\n\nOPTIONS说明：\n-f :通过 SIGKILL 信号强制删除一个运行中的容器。\n-l :移除容器间的网络连接，而非容器本身。\n-v :删除与容器关联的卷。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>删除所有容器</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker rm $(docker ps -a -q) \n或者\ndocker rm &#96;docker ps -a -q&#96;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>启动容器</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker container start container_id<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>停止所有容器</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker stop $(docker ps -a -q)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>杀掉运行中的容器</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker kill -s(可忽略) CONTAINER\n-s :向容器发送一个信号 \n例：docker kill -s KILL mynginx<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>在运行的容器中执行命令</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker exec [OPTIONS] CONTAINER COMMAND [ARG...]\n例如：进入容器 docker exec -itd 容器id &#x2F;bin&#x2F;bash\n（-d :分离模式: 在后台运行 -i :即使没有附加也保持STDIN 打开-t :分配一个伪终端）\n&#x2F;bin&#x2F;bash：在container中启动一个bash shell\nexit 退出bash shell<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>暂停容器中所有的进程</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker pause container_id<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>恢复容器中所有的进程</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker unpause container_id<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>创建一个新的容器不运行</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker create 参数同docker run<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>创建一个新的容器并运行</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker run\n-i: 以交互模式运行容器，通常与-t同时使用\n-t: 为容器重新分配一个伪输入终端，通常与-i同时使用\n-it 以交互模式运行\n-P: 随机端口映射，容器内部端口随机映射到主机的端口\n-p: 指定端口映射，格式为：主机(宿主)端口:容器端口\n-d 后台运行 并返回容器ID\n-v,--volume 挂载 主机目录:容器目录,绑定一个卷\n-u,--user&#x3D;&quot;&quot;， 指定容器的用户\n-a,--attach&#x3D;[]， 登录容器（必须是以docker run -d启动的容器）\n-w,--workdir&#x3D;&quot;&quot;， 指定容器的工作目录\n-c,--cpu-shares&#x3D;0， 设置容器CPU权重，在CPU共享场景使用\n-e username&#x3D;&quot;ritchie&quot;,--env&#x3D;[] 设置环境变量容器中可以使用该环境变量\n-m,--memory&#x3D;&quot;&quot;， 指定容器的内存上限\n-P,--publish-all&#x3D;false，指定容器暴露的端口\n-h,--hostname&#x3D;&quot;&quot;， 指定容器的主机名\n--name&#x3D;”” 容器命名\n--cap-add&#x3D;[]添加权限，权限清单详见：\thttp:&#x2F;&#x2F;linux.die.net&#x2F;man&#x2F;7&#x2F;capabilities\n--cap-drop&#x3D;[]删除权限，权限清单详见：\thttp:&#x2F;&#x2F;linux.die.net&#x2F;man&#x2F;7&#x2F;capabilities\n--cidfile&#x3D;&quot;&quot; 运行容器后,在指定文件中写入容器PID值，一种典型的监控系\t统用法\n--cpuset&#x3D;&quot;&quot;， 设置容器可以使用哪些CPU，此参数可以用来容器独占CPU\n--device&#x3D;[]， 添加主机设备给容器，相当于设备直通\n--dns&#x3D;[]， 指定容器的dns服务器\n--dns-search&#x3D;[]指定容器的dns搜索域名,写入到容器的&#x2F;etc&#x2F;resolv.conf文\t件\n--entrypoint&#x3D;&quot;&quot;， 覆盖image的入口点\n--env-file&#x3D;[]， 从指定文件读入环境变量\n--expose&#x3D;[]， 指定容器暴露的端口，即修改镜像的暴露端口\n--link&#x3D;[]， 添加链接到另一个容器，使用其他容器的IP、env等信息\n--lxc-conf&#x3D;[]， 指定容器的配置文件，只有在指定--exec-driver&#x3D;lxc时\t使用\n--net&#x3D;&quot;bridge&quot;， 容器网络设置:\nbridge 使用docker daemon指定的网桥\nhost 容器使用主机的网络\ncontainer:NAME_or_ID &gt; 使用其他容器的网路，共享IP和PORT等网络资源\nnone 容器使用自己的网络（类似--net&#x3D;bridge），但是不进行配置\n--privileged&#x3D;false指定容器是否为特权容器,特权容器拥有所有的capabilities\n--restart&#x3D;&quot;no&quot;，指定容器停止后的重启策略:\nno - 容器退出时不重启\non-failure - 只在容器以非0状态码退出时重启。可选的，可以退出docker daemon尝试重启容器的次数\nalways – 不管退出状态码是什么始终重启容器。当指定always时，docker daemon将无限次数地重启容器。容器也会在daemon启动时尝试重启，不管容器当时的状态如何。\nunless-stopped – 不管退出状态码是什么始终重启容器，不过当daemon启动时，如果容器之前已经为停止状态，不要尝试启动它。\n--rm&#x3D;false指定容器停止后自动删除容器(不支持以docker run -d启动的容器)\n--sig-proxy&#x3D;true 设置由代理接受并处理信号，但是SIGCHLD、SIGSTOP和\tSIGKILL不能被代理<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>获取容器&#x2F;镜像的元数据</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker inspect [OPTIONS] NAME|ID [NAME|ID...]\nOPTIONS说明：\n-f :指定返回值的模板文件。\n-s :显示总的文件大小。\n--type :为指定类型返回JSON。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>查看容器中运行的进程信息</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker top container_id<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>连接到正在运行中的容器</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker attach container_id<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>阻塞运行直到容器停止，然后打印出它的退出代码</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker wait containser_id<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n</ul>\n<h5 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h5><ul>\n<li><p>从服务器获取实时事件</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker events OPTIONS\n\nOPTIONS说明：\n-f ：根据条件过滤事件；\n--since ：从指定的时间戳后显示所有事件;\n--until ：流水时间显示到指定的时间为止；\ndocker events --since&#x3D;&quot;1467302400&quot;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>查看日志</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker logs [OPTIONS] CONTAINER\n--details 显示更多的信息\n-f, --follow 跟踪实时日志\n--since string 显示自某个timestamp之后的日志，或相对时间，如42m（即42分钟）\n--tail string 从日志末尾显示多少行日志，默认是all\n-t, --timestamps 显示时间戳\n--until string 显示自某个timestamp之前的日志，或相对时间，如42m（即42分钟）\n\n查看指定时间后的日志，只显示最后100行：\ndocker logs -f -t --since&#x3D;&quot;2018-02-08&quot; --tail&#x3D;100 CONTAINER_ID\n查看最近30分钟的日志:\ndocker logs --since 30m CONTAINER_ID\n查看某时间之后的日志：\ndocker logs -t --since&#x3D;&quot;2018-02-08T13:23:37&quot; CONTAINER_ID\n查看某时间段日志：\ndocker logs -t --since&#x3D;&quot;2018-02-08T13:23:37&quot; --until &quot;2018-02-09T12:23:37&quot; CONTAINER_ID<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>列出指定的容器的端口映射</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker port container_id<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>提交</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]\n\nOPTIONS说明：\n-a :提交的镜像作者；\n-c :使用Dockerfile指令来创建镜像；\n-m :提交时的说明文字；\n-p :在commit时，将容器暂停。\n\n将容器a404c6c174a2 保存为新的镜像,并添加提交人信息和说明信息。\ndocker commit -a &quot;runoob.com&quot; -m &quot;my apache&quot; a404c6c174a2 mymysql:v1<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>容器与主机之间的数据拷贝</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">将主机&#x2F;www&#x2F;runoob目录拷贝到容器96f7f14e99ab的&#x2F;www目录下。\ndocker cp &#x2F;www&#x2F;runoob 96f7f14e99ab:&#x2F;www&#x2F;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</li>\n<li><p>查看容器文件结构更改</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker diff mymysql<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>使用 Dockerfile 创建镜像</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker build\n--build-arg&#x3D;[] :设置镜像创建时的变量；\n--cpu-shares :设置 cpu 使用权重；\n--cpu-period :限制 CPU CFS周期；\n--cpu-quota :限制 CPU CFS配额；\n--cpuset-cpus :指定使用的CPU id；\n--cpuset-mems :指定使用的内存 id；\n--disable-content-trust :忽略校验，默认开启；\n-f :指定要使用的Dockerfile路径；\n--force-rm :设置镜像过程中删除中间容器；\n--isolation :使用容器隔离技术；\n--label&#x3D;[] :设置镜像使用的元数据；\n-m :设置内存最大值；\n--memory-swap :设置Swap的最大值为内存+swap，&quot;-1&quot;表示不限swap；\n--no-cache :创建镜像的过程不使用缓存；\n--pull :尝试去更新镜像的新版本；\n--quiet, -q :安静模式，成功后只输出镜像 ID；\n--rm :设置镜像成功后删除中间容器；\n--shm-size :设置&#x2F;dev&#x2F;shm的大小，默认值是64M；\n--ulimit :Ulimit配置。\n--squash :将Dockerfile中所有的操作压缩为一层。\n--tag, -t: 镜像的名字及标签，通常name:tag或者name格式；可以在一次构建中为一个镜像设置多个标签。\n--network: 默认default。在构建期间设置RUN指令的网络模式<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>登陆到一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker login -u -p\n-u 登陆的用户名 -p :登陆的密码<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n</li>\n<li><p>登出一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库Docker Hub</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker logout<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li><p>标记本地镜像，将其归入某一仓库</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker tag<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n</ul>\n<h4 id=\"docker加速命令\"><a href=\"#docker加速命令\" class=\"headerlink\" title=\"docker加速命令\"></a>docker加速命令</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">curl -sSL https:&#x2F;&#x2F;get.daocloud.io&#x2F;daotools&#x2F;set_mirror.sh | sh -s http:&#x2F;&#x2F;f1361db2.m.daocloud.io\n或\nvim &#x2F;etc&#x2F;docker&#x2F;daemon.json\n&#123;\n  &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;registry.docker-cn.com&quot;]\n&#125;\n\n其他站点\nhttp:&#x2F;&#x2F;hub-mirror.c.163.com\nhttps:&#x2F;&#x2F;3laho3y3.mirror.aliyuncs.com\nhttp:&#x2F;&#x2F;f1361db2.m.daocloud.io\nhttps:&#x2F;&#x2F;mirror.ccs.tencentyun.com\nhttps:&#x2F;&#x2F;docker.mirrors.ustc.edu.cn<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"与Spring-Boot\"><a href=\"#与Spring-Boot\" class=\"headerlink\" title=\"与Spring Boot\"></a>与Spring Boot</h4><ul>\n<li><a href=\"https://mp.weixin.qq.com/s/15ZAVUg5DfcF53QpEetT7Q\">一键部署Spring Boot到远程Docker容器</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/dP-c3twzR0PMUvPWZA-U0Q\">Jenkins+Docker一键自动化部署SpringBoot项目</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/CXUwpTbAVoXEeB7EcrCjAw\">搭建SpringBoot项目并将其Docker化</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=Mzg2MDYzODI5Nw==&mid=2247493762&idx=1&sn=114663a4a13ba5bb27d05e0d77de37c1&source=41#wechat_redirect\">SpringBoot使用Docker快速部署项目</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/du2sypGQczJh7gQz_4IX9g\">Docker部署Spring Boot项目的2种方式！</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=Mzg2MDYzODI5Nw==&mid=2247493962&idx=1&sn=af6c945d629003cfd30564698c017598&source=41#wechat_redirect\">SpringBoot项目构建Docker镜像深度调优</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/01SZo3NNf5zuAC8wAI6C-g\">还在手动部署springboot项目？不妨试试它，让你部署项目飞起来！</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/HSRIYQVKR9TGtwetd3LU5w\">Docker+Spring Boot+FastDFS搭建一套分布式文件服务器，太强了！</a></li>\n</ul>\n<h4 id=\"相关文章\"><a href=\"#相关文章\" class=\"headerlink\" title=\"相关文章\"></a>相关文章</h4><ul>\n<li><a href=\"https://mp.weixin.qq.com/s/ELZo2z4fHonoBGXQI0M9CA\">图解Docker架构，傻瓜都能看懂！</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/gmZDBuYDXnNdykEx66Y0Cw\">构建Java镜像的10个最佳实践</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/LOmqsoBJd7h1HPwf0i1uwQ\">10个冷门但又非常实用的Docker使用技巧！！</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/tTsizeLeVyvQ44GXMNqrjA\">Docker实战总结</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/t81enr-ypBxk1K4lYqWZww\">Docker从入门到干活，看这一篇足矣</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/x-M5iKvvuseIQwUdVmxSPQ\">如何编写最佳的Dockerfile</a></li>\n<li><a href=\"https://www.jianshu.com/p/658911a8cff3\">Docker：Docker Compose详解</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/fB59zXK7cPBt1asSyUpqDg\">CentOS&#x2F;Ubuntu安装Docker和Docker Compose</a></li>\n<li><a href=\"http://guide.daocloud.io/dcs/docker-9152677.html\">DaoCloud安装docker指南</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/fzlNnJe9SMA5k3TDXOfZUA\">Docker常用命令，还有谁不会？</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/PpI7_fY5ACjmtmnlqr7ZMQ\">一款吊炸天的Docker图形化工具，太强大</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/w0sFaHApOSrwgva0886ijQ\">5款顶级Docker容器GUI管理工具！免费又好用</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/rAOsia2LU2_Fl4vrjQ2tvA\">Docker轻量级编排创建工具Humpback</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/6smzsvYSbRvSPcpbfnH98A\">带着问题学Kubernetes架构！</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/B2tIs6YitA93iYxEZ_8Ovw\">为什么大家都在学习k8s</a></li>\n<li><a href=\"https://kuboard.cn/\">Kuboard-Kubernetes多集群管理界面</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/WWRp-e9QPcLg8-m-V3UU1Q\">图文详解Kubernetes，傻瓜都能看懂！</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/8UJnsx0NJyxlKXeduhg5Yw\">Kubernetes缺少的多租户功能，你可以通过这些方式实现</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/yg5ACCeeyJa0AVP1LatUhA\">IDEA使用Docker插件，实现一键自动化部署</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/KU3bpxiNbHGJQ_XVRqsedg\">Docker有几种网络模式</a></li>\n</ul>\n","categories":[{"name":"技术栈","path":"api/categories/技术栈.json"}],"tags":[{"name":"安装","path":"api/tags/安装.json"}]}