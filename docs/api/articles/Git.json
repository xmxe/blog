{"title":"Git","slug":"Git","date":"2022-09-27T08:40:56.309Z","updated":"2025-03-26T01:51:16.805Z","comments":true,"path":"api/articles/Git.json","excerpt":null,"covers":"https://pica.zhimg.com/v2-6baae9baaef9c2a3188f9fc301833fba_1440w.jpg","content":"\r\n\r\n## 常用命令\r\n\r\n### git diff\r\n\r\n```shell\r\n# 可以查看当前没有add的内容修改（不在缓冲区的文件变化）\r\ngit diff\r\n# 查看已经add但没有commit的改动（在缓冲区的文件变化）\r\ngit diff --cached\r\n# 是上面两条命令的合并\r\ngit diff HEAD\r\n# 查看文件和另一个分支的区别\r\ngit diff branch-name file-name\r\n# 查看两次提交的区别\r\ngit diff commit-id commit-id\r\ngit show commit-id\r\n```\r\n\r\n### git reset\r\n\r\n```shell\r\n# 将未commit的文件移出Staging区(撤销git add)\r\ngit reset HEAD\r\n# 撤销git add操作(已经将文件添加到暂存区)不加filename就是上一次add里面的全部撤销了\r\ngit reset HEAD filename\r\n# 重置代码和远程分支代码一样\r\ngit reset --hard origin/master\r\n# 回退到上个commit 删除工作空间改动代码，撤销commit，撤销git add\r\ngit reset --hard HEAD^\r\n# 回退到前3次提交之前，以此类推，回退到n次提交之前\r\ngit reset --hard HEAD~3\r\n# 回退到指定版本 --hard强制将暂存区和工作目录都同步到你指定的提交\r\ngit reset --hard commitid\r\n# 不删除工作空间改动代码，撤销commit，不撤销git add\r\ngit reset --soft HEAD^\r\n# 不删除工作空间改动代码，撤销commit，并且撤销git add操作。这个为默认参数,git reset --mixed HEAD^和git reset HEAD^效果是一样的。\r\ngit reset --mixed HEAD^\r\n```\r\n\r\n### git revert\r\n\r\n> 应用场景：有一天测试突然跟你说，你开发上线的功能有问题，需要马上撤回，否则会影响到系统使用。这时可能会想到用reset回退，可是你看了看分支上最新的提交还有其他同事的代码，用reset会把这部分代码也撤回了。由于情况紧急，又想不到好方法，还是任性的使用reset，然后再让同事把他的代码合一遍（同事听到想打人），于是你的技术形象在同事眼里一落千丈\r\n\r\n```shell\r\n# 回退到指定版本。与git reset --hard commitid相比区别是在我们确认了在需要回退的版本之后的提交都可以不需要的时候，我们可以直接使用git reset命令，但是当我们只是需要撤销某个版本的时候，后面的提交还需要保留，我们就可以使用git revert.revert会生成一条新的提交记录，这时会让你编辑提交信息，编辑完后:wq保存退出就好了。-n/--no edit：这个选项不会打开文本编辑器。它将直接恢复上次的提交。\r\ngit revert -n commitid\r\n# 撤销前一次commit ,此次操作之前和之后的commit都会被保留，并且会把这次撤销作为一次最新的提交\r\ngit revert HEAD\r\n# 撤销前前一次commit\r\ngit revert HEAD^\r\n```\r\n\r\n### git commit\r\n\r\n```shell\r\n# (git add -u + git commit -m \"\"组合)\r\ngit commit -am ''\r\n# 修改commit信息\r\ngit commit --amend\r\n# 使用新的一次commit，来覆盖上一次commit\r\ngit commit --amend -m \"message\"\r\n# 提交Staging中在指定文件到本地仓库区\r\ngit commit file1 file2 -m \"message\r\n# 修改上次提交的用户名和邮箱\r\ngit commit --amend --author=\"name <email>\" --no-edit\r\n```\r\n\r\n### git add\r\n\r\n```shell\r\ngit add -A # 保存所有的修改\r\ngit add . # 保存新的添加和修改，但是不包括删除\r\ngit add -u # 保存修改和删除，但是不包括新建文件。\r\n```\r\n\r\n### git branch\r\n\r\n```shell\r\n# 查看本地分支(不包括远程分支)\r\ngit branch\r\n# 查看远程分支\r\ngit branch -a\r\n# 列出本地所有分支 并显示最后一次提交的哈希值\r\ngit branch -v\r\n# 在-v的基础上 并且显示上游分支的名字\r\ngit branch -vv\r\n# 列出上游所有分支\r\ngit branch -r\r\n# 创建分支(未切换)\r\ngit branch <name>\r\n# 删除分支，不能删除当前所在分支\r\ngit branch -d <name>\r\n# 设置分支上游\r\ngit branch --set-upstream-to origin/master\r\n# 下载指定分支\r\ngit clone -b 分支名称 git地址\r\n# 为了节省磁盘空间，您可以使用以下命令克隆仅导致单个分支的历史记录,如果--single-branch未添加到命令中，则所有分支的历史记录将被克隆。大型存储库可能会出现此问题。\r\ngit clone -b <branch_name> --single-branch <url>\r\n```\r\n\r\n### git checkout\r\n\r\n```shell\r\n# 切换分支\r\ngit checkout <name>\r\n# 创建+切换分支\r\ngit checkout -b <name>\r\n# 本地没有分支的情况下拉取远程分支,此命令意思为创建本地分支并关联远程分支\r\ngit checkout -b local-branch origin/remote-branch\r\n# 丢弃某个文件工作区的修改（还原修改过的文件）\r\ngit checkout -- file\r\n# 放弃本地所有修改，没有提交的可以回到未修改前版本，不包括新增删除的文件\r\ngit checkout .\r\n# 放弃本地所有修改，包括新增删除的文件\r\ngit checkout . && git clean -df\r\n#（先切换到develop分支然后把feature分支合并到develop分支）\r\ngit checkout develop && git merge feature\r\n# 将某个文件回滚到某个版本\r\ngit checkout commitid [file]\r\n```\r\n\r\n### git switch\r\n\r\n> `git switch`命令是在Git 2.23.0版本中引入的，以解决`git checkout`命令职责过重的问题，并使得Git的命令更加直观和易于理解。在Git 2.23之前，`git checkout`既用于切换分支，也用于还原文件内容，很容易引起混淆。通过将`git checkout`的功能拆分，Git团队创建了两个新的、更专业的命令：\r\n> `git switch`：专门用于在分支之间进行切换。\r\n> `git restore`：专门用于还原文件内容。\r\n\r\n```shell\r\n# 切换到已存在的分支\r\ngit switch <branch-name>\r\n# 创建并切换到新分支\r\ngit switch -c <new-branch-name>\r\n# 从远程仓库创建并跟踪一个本地分支\r\ngit switch -c <new-branch-name> --track <remote>/<branch-name>\r\n# 返回到上一个分支\r\ngit switch -\r\n```\r\n\r\n### git restore\r\n\r\n```shell\r\n# git restore命令在工作区是不会起作用的\r\n# 取消暂存区的更改（类似于git reset HEAD <file>）.此命令将暂存区中的文件恢复到最后一次提交的状态，并将其从暂存区中移除，但保留工作目录中的修改。这意味着该文件的修改将不会包含在下一次的提交\r\ngit restore --staged file\r\n# 此命令将工作目录中的文件恢复到最后一次提交的状态，并且不会对暂存区进行任何操作。它将丢弃工作目录中对文件的修改，恢复到最后提交的版本。\r\ngit restore file\r\n# 从指定的提交中恢复文件到工作目录\r\ngit restore --source=<commit> <file>\r\n# 恢复所有文件到指定的提交状态\r\ngit restore --source=<commit> .\r\n# 恢复所有已删除的文件\r\ngit restore -w -- *\r\n# 丢弃暂存区和工作目录中的更改（即恢复到指定的提交状态）\r\ngit restore --staged --worktree <file>\r\n```\r\n\r\n### git worktree\r\n\r\n> `git worktree`命令是在Git 2.5版本中引入的，它允许在同一个仓库中创建多个工作目录（worktrees），每个工作目录可以检出不同的分支或提交。这为开发者提供了同时处理多个任务的能力，比如在不同的分支上进行开发、测试，而不需要来回切换分支\r\n\r\n```shell\r\n# 添加一个新的工作目录，并检出指定分支\r\ngit worktree add <path> [<branch>]\r\n# 列出所有的工作目录\r\ngit worktree list\r\n# 移除一个工作目录（必须先确保该目录没有未提交的更改）\r\ngit worktree remove <path>\r\n# 移动一个工作目录到新的位置\r\ngit worktree move <current-path> <new-path>\r\n# 例如，如果想要添加一个新的工作目录来检出名为feature-branch的分支，可以这样做：\r\ngit worktree add ../my-feature-worktree feature-branch\r\n# 这将在../my-feature-worktree目录下创建一个新的工作目录，并检出feature-branch分支。\r\n```\r\n\r\n### git sparse-checkout\r\n\r\n> `git sparse-checkout`是在Git 2.25.0版本中引入的，这个功能是对之前存在的稀疏检出机制的一个重大改进。通过`git sparse-checkout`，开发者可以更高效地克隆大型仓库，只检出部分文件或目录，而不是整个项目\r\n\r\n```shell\r\n# 要启用sparse-checkout，首先需要设置仓库以使用稀疏检出模式：\r\n# 启用sparse-checkout模式\r\ngit sparse-checkout init\r\n# 设置你想要包括的模式或路径\r\ngit sparse-checkout set <pattern>...\r\n# 例如，如果只想检出src目录及其子目录中的文件，可以这样做：\r\ngit sparse-checkout set src/\r\n# 如果想添加多个模式或路径，可以在set命令后列出所有路径，或者分多次调用该命令。除了set命令，还可以使用add和list来管理稀疏检出模式：\r\n# 添加额外的路径到稀疏检出模式\r\ngit sparse-checkout add <pattern>...\r\n# 列出现有的稀疏检出模式\r\ngit sparse-checkout list\r\n# 如果不再需要稀疏检出模式，可以通过以下命令禁用它，并恢复完整的检出状态：\r\n# 禁用sparse-checkout模式并恢复完整检出\r\ngit sparse-checkout disable\r\n```\r\n\r\n### git range-diff\r\n\r\n> `git range-diff`是在Git 2.19.0版本中引入的，用于比较两个提交范围之间的差异。它可以帮助开发者理解在一次变基（rebase）、合并（merge）或历史改写操作后，一系列提交发生了哪些变化\r\n\r\n```shell\r\n# 比较两个分支上的最近n个提交\r\ngit range-diff A~n..A B~n..B\r\n# 或者更常见的用法是直接指定两个范围\r\ngit range-diff A..B C..D\r\n# 假设origin/feature是变基之前的远程分支状态,而feature是变基之后的本地分支状态\r\ngit range-diff origin/feature..feature~n feature~n..feature\r\n```\r\n\r\n### git maintenance\r\n\r\n> `git maintenance`是在Git 2.30.0版本中引入的，用于管理和自动化各种维护任务的命令。这个命令旨在简化和优化仓库的维护工作，通过提供一组预定义的任务来帮助保持仓库的健康状态和高效性能。常见的维护任务包括：\r\n> gc：运行完整的垃圾收集，包括压缩对象数据库。\r\n> commit-graph：构建或更新提交图文件以加速提交历史查询。\r\n> loose-objects：清理松散对象并将其打包。\r\n> incremental-repack：逐步重新打包对象以优化存储。\r\n> prefetch：预先获取远程分支的新数据，以加速未来的克隆和拉取操作。\r\n\r\n```shell\r\n# 启用自动维护\r\ngit maintenance start\r\n# 禁用自动维护\r\ngit maintenance stop\r\n# 执行所有配置的维护任务\r\ngit maintenance run\r\n# 执行特定类型的维护任务\r\ngit maintenance run --task=<task>\r\n```\r\n配置自动维护计划：可以通过配置文件设置哪些任务应该被定期执行以及它们的执行频率。例如，在`.git/config`文件中添加如下内容：\r\n\r\n```config\r\n[maintenance \"daily\"]\r\n    task = prefetch\r\n    task = loose-objects\r\n[maintenance \"hourly\"]\r\n    task = commit-graph\r\n[maintenance \"weekly\"]\r\n    task = incremental-repack\r\n[maintenance \"monthly\"]\r\n    task = gc\r\n```\r\n然后启用这些计划：\r\n\r\n```shell\r\ngit maintenance start --schedule=daily\r\ngit maintenance start --schedule=hourly\r\ngit maintenance start --schedule=weekly\r\ngit maintenance start --schedule=monthly\r\n```\r\n\r\n### git merge & git rebase\r\n```shell\r\n# 合并指定分支到当前分支\r\ngit merge <name>\r\n# 将指定分支合并到当前分支\r\ngit rebase branch-name\r\n# 执行commit id将rebase停留在指定commit处\r\ngit rebase -i commit-id\r\n# 执行commit id将rebase停留在 项目首次commit处\r\ngit rebase -i --root\r\n```\r\n\r\n> **git rebase和git merge区别**\r\n> 采用merge和rebase后，git log的区别，merge命令不会保留merge的分支的commit，rebase会保留所有的commit：rebase会把你当前分支的commit放到公共分支的最后面,所以叫变基。就好像你从公共分支又重新拉出来这个分支一样。举例:如果你从master拉了个feature分支出来,然后你提交了几个commit,这个时候刚好有人把他开发的东西合并到master了,这个时候master就比你拉分支的时候多了几个commit,如果这个时候你rebase master的话，就会把你当前的几个commit，放到那个人commit的后面。merge会把公共分支和你当前的commit合并在一起，形成一个新的commit提交\r\n> 处理冲突的方式：（一股脑）使用merge命令合并分支，解决完冲突，执行git add .和git commit -m 'fix conflict'。这个时候会产生一个commit。（交互式）使用rebase命令合并分支，解决完冲突，执行git add .和git rebase --continue，不会产生额外的commit。这样的好处是干净，分支上不会有无意义的解决分支的commit；坏处，如果合并的分支中存在多个commit，需要重复处理多次冲突。\r\n\r\n> **git pull和git pull --rebase区别**\r\n> git pull做了两个操作分别是‘获取’和合并。所以加了rebase就是以rebase的方式进行合并分支得到一条干净的分支流。\r\n\r\n> **git merge和git merge --no-ff的区别**\r\n> 自己尝试merge命令后，发现merge时并没有产生一个commit。不是说merge时会产生一个merge commit吗？注意：只有在冲突的时候，解决完冲突才会自动产生一个commit。如果想在没有冲突的情况下也自动生成一个commit，记录此次合并就可以用：git merge --no-ff命令,如果不加--no-ff则被合并的分支之前的commit都会被抹去，只会保留一个解决冲突后的merge commit。\r\n\r\n> [合并代码还在用git merge？我们都用git rebase！](https://mp.weixin.qq.com/s/T_8bkWI-JSP5ixdVIvVAGQ)\r\n> [新来个技术总监，禁止我们用Git的rebase](https://mp.weixin.qq.com/s/CBz0ea6m623GtuTX5UkeQQ)\r\n\r\n### git tag\r\n\r\n```shell\r\n# 查看所有标签，可以知道历史版本的tag\r\ngit tag\r\n# 打标签，默认为HEAD。比如git tag v1.0\r\ngit tag <tagName>\r\n# 根据版本号打上标签\r\ngit tag <tagName> commit_id\r\n# 创建带说明的标签。-a指定标签名，-m指定说明文字\r\ngit tag -a <tagName> -m \"<说明>\"\r\n# 查看标签信息\r\ngit show <tagName>\r\n# 删除标签\r\ngit tag -d <tagName>\r\n# 推送某个标签到远程\r\ngit push origin <tagname>\r\n# 一次性推送全部尚未推送到远程的本地标签\r\ngit push origin --tags\r\n# 这会将空引用推送到远程仓库，从而删除名为<tag-name>的远程标签。\r\ngit push origin :refs/tags/<tag-name>\r\n```\r\n\r\n### git stash\r\n\r\n> 应用场景：某一天你正在feature分支开发新需求，突然产品经理跑过来说线上有bug，必须马上修复。而此时你的功能开发到一半，于是你急忙想切到master分支，然后你就会看到以下报错：Your local changes to the following...因为当前有文件更改了，需要提交commit保持工作区干净才能切分支。由于情况紧急，你只有急忙commit上去，commit信息也随便写了个“暂存代码”，于是该分支提交记录就留了一条黑历史，如果你学会stash，就不用那么狼狈了。你只需要：git stash就这么简单，代码就被存起来了。当你修复完线上问题，切回feature分支，想恢复代码也只需要：git stash apply,但是恢复后，stash内容并不删除，需要用git stash drop来删除\r\n\r\n```shell\r\n# 保存当前未commit的代码\r\ngit stash\r\n# 保存当前未commit的代码并添加备注\r\ngit stash save \"备注的内容\"\r\n# 列出stash的所有记录\r\ngit stash list\r\n# 删除stash的所有记录\r\ngit stash clear\r\n# 应用最近一次的stash\r\ngit stash apply\r\n# 应用最近一次的stash，随后删除该记录\r\ngit stash pop\r\n# 删除最近的一次stash\r\ngit stash drop\r\n\r\n# 当有多条stash，可以指定操作stash，首先使用stash list列出所有记录：\r\ngit stash list \r\n# stash@{0}: WIP on ...\r\n# stash@{1}: WIP on ...\r\n# stash@{2}: On ...\r\n\r\n# 应用第二条记录：\r\ngit stash apply stash@{1}\r\n# 删除stash@{1}存储的内容\r\ngit stash drop stash@{1}\r\n# pop，drop同理。\r\n```\r\n\r\n### git config\r\n\r\n```shell\r\ngit config --gloabl http.postBuffer 524288000\r\ngit config --gloabl http.sslVerify \"false\"\r\ngit config --global user.name \"your name\"\r\ngit config --global user.email \"your email\"\r\n# 保存密码\r\ngit config --global credential.helper store\r\n# 配置git图形界面编码为utf-8\r\ngit config --global gui.encoding=utf-8\r\n# 设置当前项目提交代码的用户名 \r\ngit config user.name name\r\n```\r\n\r\n### git cherry-pick\r\n\r\n```shell\r\n# 把a分支的一个提交复制到b分支\r\n# 首先复制a分支的commitid然后切换到b分支执行\r\ngit cherry-pick commitid\r\n# 一次转移多个提交：将commit1和commit2两个提交应用到当前分支。\r\ngit cherry-pick commit1 commit2\r\n# 多个连续的commit，也可区间复制：将commit1到commit2这个区间的commit都应用到当前分支（包含commit1、commit2），commit1是最早的提交。\r\ngit cherry-pick commit1^..commit2\r\n# 在cherry-pick多个commit时，可能会遇到代码冲突，这时cherry-pick会停下来，让用户决定如何继续操作,这时需要解决代码冲突，重新提交到暂存区,然后使用cherry-pick --continue让cherry-pick继续进行下去。\r\ngit cherry-pick --continue\r\n# 但有时候可能需要在代码冲突后，放弃或者退出流程：放弃cherry-pick：\r\ngit cherry-pick --abort\r\n# 回到操作前的样子，就像什么都没发生过。\r\ngit cherry-pick --quit\r\n```\r\n\r\n### git push\r\n\r\n```shell\r\n# 删除远程分支\r\ngit push origin :beanch-name\r\n# 使用git push命令并加上--delete 选项来删除指定的远程分支\r\ngit push origin --delete branch-name\r\n#  删除远程标签\r\ngit push origin --delete tag-name\r\n# 删除远程标签（需要先删除本地标签）\r\ngit push origin :refs/tags/tag-name\r\n# 上传本地仓库到远程分支\r\ngit push remote branch-name\r\n# 强行推送当前分支到远程分支\r\ngit push remote branch-name --force\r\n# 推送所有分支到远程仓库\r\ngit push remote --all\r\n# 推送所有标签\r\ngit push --tags\r\n# 推送指定标签\r\ngit push origin tag-name\r\n# 将本地dev分支push到远程master分支\r\ngit push origin dev:master\r\n```\r\n\r\n### git fetch\r\n\r\n```shell\r\n# 更新所有跟踪的远程分支,这将会从默认的远程仓库(通常是origin)拉取所有新的数据\r\ngit fetch\r\n# 指定一个不同的远程仓库\r\ngit fetch <远程仓库名>\r\n# 只获取某个特定的分支而不是所有分支的更新\r\ngit fetch <远程仓库名> <分支名>\r\n# 当你在远程删除了某些分支后，本地仍然可能保留着对这些已删除分支的引用。使用`--prune` 选项可以在获取最新数据的同时移除那些不再存在于远程仓库中的本地远程跟踪分支\r\ngit fetch --prune\r\n# 或者针对特定远程仓库\r\ngit fetch <远程仓库名> --prune\r\n# 获取更新后，你可以选择将这些更改合并到你的当前分支中，使用`git merge`或者`git rebase`。例如，假设你已经从origin拉取了更新，现在想要将这些更新合并到当前分支\r\ngit merge origin/目标分支 || git rebase origin/目标分支\r\n```\r\n\r\n## 常用操作\r\n\r\n### 删除全部历史提交记录\r\n\r\n```shell\r\n# 创建孤立分支,没有以前的提交记录\r\ngit checkout --orphan <name>\r\n# 切换到一个脱离主分支的另外一条全新主分支，不用太在意叫什么，因为后面还会修改分支名称\r\ngit checkout --orphan latest_branch\r\n# 暂存所有改动过的文件，内容为当前旧分支的最新版本所有文件\r\ngit add -A\r\n#提交更改\r\ngit commit -am \"commit message\"\r\n#删除原始主分支\r\ngit branch -D main\r\n#将当前分支重命名为 main\r\ngit branch -m main\r\n#最后，强制更新您的存储库\r\ngit push -f origin main\r\n```\r\n\r\n### 删除部分历史提交记录\r\n\r\n1. 运行`git log`来查找你要删除的提交记录的hash值(commit id)，记录下来。\r\n2. 执行交互式rebase命令：`git rebase -i commit_id`\r\n    > 如果想要删除最近3次历史提交: `git rebase -i HEAD~3`\r\n3. 进入编辑模式，将要删除的commit_id前的pick修改为drop。保存并退出编辑模式。\r\n4. 推送更新到远程仓库：`git push --force(或git p)`\r\n\r\n### 远程分支重命名\r\n\r\n假设你当前已经将该分支推送到远程了，这种情况修改起来要稍微多几步\r\n\r\n```shell\r\n# 方案1:先重命名本地分支，然后推送到远程分支\r\n# 1.先重命名本地分支\r\ngit branch -m 旧分支名称 新分支名称\r\n# 2.删除远程分支(如果删除的是默认分支的话会失败，需要先更改默认分支)\r\ngit push --delete origin 旧分支名称\r\n# 3.上传新修改名称的本地分支\r\ngit push origin 新分支名称\r\n# 4.修改后的本地分支关联远程分支\r\ngit branch --set-upstream-to origin/新分支名称\r\n\r\n# 方案2(未测试):先修改远程仓库分支，然后与本地仓库同步\r\ngit branch -m master 2021.x\r\n# 获取源分支\r\ngit fetch origin\r\n# 切换源分支为远程分支\r\ngit branch -u origin/2021.x 2021.x\r\n# 设置远程分支\r\ngit remote set-head origin -a\r\n# 方案2另一种实现(未测试):先修改远程仓库分支，然后与本地仓库同步\r\n# 首先，在本地仓库中切换到需要同步的分支上：这里<branch-name>是需要同步的分支名称\r\ngit checkout <branch-name>\r\n# 接下来，从远程仓库中获取最新的分支列表和分支状态信息：这会更新本地仓库中的远程分支信息。\r\ngit fetch\r\n# 然后，使用以下命令来重置本地分支到远程分支的最新状态：这将强制将本地分支指向远程分支的最新状态。\r\ngit reset --hard origin/<branch-name>\r\n```\r\n\r\n### 下载所有分支\r\n\r\n```shell\r\n# git clone下载的是默认分支,分支较少的话可以使用git branch -a查看所有远程分支然后使用'git checkout 分支名'来下载其他分支。如果分支较多的话使用--bare,裸仓库(bare repository)指的是除了git仓库不包含其他工作文件的仓库，可以通过git clone --bare来生成。\r\ngit clone --bare https://github.com/xx/project.git .git\r\n# 或者git config --unset core.bare\r\ngit config --bool core.bare false\r\n# 上面的命令执行完,再执行该命令,就可以看到仓库里面的内容了\r\ngit reset --hard\r\n# 或者切换到指定分支\r\ngit checkout 指定分支名\r\n```\r\n\r\n### 上传git仓库\r\n\r\n```shell\r\n# 创建.git目录\r\ngit init\r\ngit add -A\r\ngit commit -m \"init\"\r\ngit remote add origin https://github.com/xmxe/project.git\r\n# 断开连接\r\ngit remote remove origin\r\n# 增加一个新的远程仓库\r\ngit remote add name url\r\n# 获取指定远程仓库的详细信息\r\ngit remote show origin\r\n\r\ngit pull --rebase origin master\r\n# git push --set-upstream origin master可以简写成git push -u\r\ngit push -u origin master\r\n\r\n# 本地生成ssh密钥\r\nssh-keygen -t rsa -C \"你的邮箱\"生成sshkey\r\ngit remote set-url origin git@github.com:xmxe/springcloud.git\r\n```\r\n\r\n### git删除github文件夹但不删除本地的 以.idea为例\r\n\r\n```shell\r\ngit rm -r --cached .idea # --cached不会把本地的.idea删除\r\ngit commit -m 'delete .idea dir'\r\ngit push -u origin master\r\n```\r\n\r\n### git删除大文件\r\n\r\n```shell\r\n# 显示10个最大的文件id列表\r\ngit verify-pack -v .git/objects/pack/pack-*.idx | sort -k 3 -n | tail -10\r\n# 根据文件id查询文件路径\r\ngit rev-list --objects --all | grep 08a7475\r\n# 删除文件的历史记录\r\ngit filter-branch --force --index-filter 'git rm --cached --ignore-unmatch 文件名' --prune-empty --tag-name-filter cat -- --all\r\n\r\ngit filter-branch --index-filter # 让每个提交的文件都复制到索引(.git/index)中 然后运行过滤器命令：git rm --cached --ignore-unmatch文件名，让每个提交都删除掉“文件名”文件,然后--prune-empty 把空的提交“修剪”掉,然后--tag-name-filter cat把每个tag保持原名字，指向修改后的对应提交,最后-- --all将所有ref（包括branch、tag）都执行上面的重写\r\n\r\n# 删除缓存下来的ref和git操作记录\r\ngit for-each-ref --format='delete %(refname)' refs/original | git update-ref --stdin\r\ngit reflog expire --expire=now --all\r\n\r\n# 垃圾回收\r\n# 上面2步把大文件的索引都切断了，这个时候进行垃圾回收，就可以很明显看到效果了\r\ngit gc --prune=now\r\n# 把.git里面的修改推上去,这个时候普通的push是不行的，需要强推\r\ngit push --force\r\n\r\n```\r\n\r\n### 忽略已经纳入git版本控制的文件更改\r\n\r\n```shell\r\n# 忽略单个文件的更改\r\ngit update-index --assume-unchanged <file>\r\n# 恢复跟踪更改\r\ngit update-index --no-assume-unchanged <file>\r\n# 更彻底的忽略\r\ngit update-index --skip-worktree <file>\r\ngit update-index --no-skip-worktree <file>\r\n# Linux查看被忽略更改的文件\r\ngit ls-files -v | grep '^[a-z]'\r\n# 小写字母表示被--assume-unchanged忽略的文件，S表示被--skip-worktree忽略的文件。选择哪种方法取决于你的具体需求，--skip-worktree通常比--assume-unchanged更可靠。\r\n# PowerShell版\r\n# 查看所有被assume-unchanged的文件（小写标记）\r\ngit ls-files -v | Where-Object { $_ -match '^[a-z]' }\r\n# 查看所有被skip-worktree的文件（S标记）\r\ngit ls-files -v | Where-Object { $_ -match '^S' }\r\n\r\n# --assume-unchanged：告诉Git假设文件未更改，性能优化用\r\n# --skip-worktree：告诉Git完全忽略文件的更改，即使文件确实有变化\r\n# .gitignore:只对未跟踪文件有效，对已跟踪文件需要先git rm --cached.或对于目录：git rm --cached -r <directory>\r\n```\r\n\r\n### 设置Git短命令\r\n\r\n```shell\r\n# 方式一\r\ngit config --global alias.ps push\r\n# 方式二 打开全局配置文件\r\nvim ~/.gitconfig\r\n# 写入内容\r\n[alias] \r\n        co = checkout\r\n        ps = push\r\n        pl = pull\r\n        mer = merge --no-ff\r\n        cp = cherry-pick\r\n# 使用\r\n# 等同于 git cherry-pick <commitHash>\r\ngit cp <commitHash>\r\n```\r\n\r\n## 相关文章\r\n\r\n| [Git不要只会pull和push，试试这5条提高效率的命令](https://mp.weixin.qq.com/s/ct6GWiE_hzoXUNeriLAnng) | [Git各指令的本质，真是通俗易懂啊！](https://mp.weixin.qq.com/s/MM7sQiFPh2vIuGvg1-813Q) | [Git科普文，Git基本原理&各种骚操作](https://mp.weixin.qq.com/s/csEgAjJwH75_IvAnFBIuvw) |\r\n| :----------------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |\r\n| [一文快速掌握Git用法](https://mp.weixin.qq.com/s/xoyQ4TzVKLQb2VjZJLUqFQ) | [精心整理：Git从入门到精通、包教包会、收藏一下、随时学习](https://mp.weixin.qq.com/s/wtPizZ3RlwY3Ex1Lc3Pf4A) | [大牛总结的Git使用技巧，写得太好了！](https://mp.weixin.qq.com/s/OchvVMGoBzSFWhou4WhrWw) |\r\n| [通过.git目录深入理解Git！](https://mp.weixin.qq.com/s/q6tI0qctvciJhNz_5KLx-w) | [Git命令全方位学习](https://mp.weixin.qq.com/s/KwTsWyFh07iYdfINqo9UTg) | [图解Git，一目了然！](https://mp.weixin.qq.com/s/TW_qUWRVEnberle5q0ws9Q) |\r\n| [Git代码防丢指南，再也不怕丢失代码了！](https://mp.weixin.qq.com/s/dYiWQQ5PsSS7F7z7cDLEuw) | [20个最常用的Git命令，你都会用吗？](https://mp.weixin.qq.com/s/XB_G7TZqBX8r3CJlvqA0Cg) | [45个GIT经典操作场景，专治不会合代码](https://mp.weixin.qq.com/s/Fa8mmQpNZ1S80Kg9Oyocbw) |\r\n|  [Git的奇技淫巧](https://github.com/521xueweihan/git-tips)   | [如何配置SSH管理多个Git仓库和以及多个Github账号](https://mp.weixin.qq.com/s/ADzad6e6uTF0vpZ903SJ-A) | [那些年我们错过的Git指南](https://mp.weixin.qq.com/s/L5NEAOgoee8TQ0bOpp6PgQ) |\r\n","categories":[{"name":"技术栈","path":"api/categories/技术栈.json"}],"tags":[]}