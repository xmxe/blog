{"title":"Java反射","slug":"Java反射","date":"2023-03-21T01:22:35.330Z","updated":"2023-07-04T06:37:11.767Z","comments":true,"path":"api/articles/Java反射.json","excerpt":null,"covers":"https://pica.zhimg.com/v2-710586d41488c451dd9dd70bc33eb121_1440w.jpg","content":"\r\n\r\n\r\n## 何为反射\r\n\r\n如果说大家研究过框架的底层原理或者咱们自己写过框架的话，一定对反射这个概念不陌生。反射之所以被称为框架的灵魂，主要是因为它赋予了我们在运行时分析类以及执行类中方法的能力。通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。\r\n\r\n## 反射的应用场景\r\n\r\n像咱们平时大部分时候都是在写业务代码，很少会接触到直接使用反射机制的场景。但是，这并不代表反射没有用。相反，正是因为反射，你才能这么轻松地使用各种框架。像Spring/SpringBoot、MyBatis等等框架中都大量使用了反射机制。这些框架中也大量使用了动态代理，而动态代理的实现也依赖反射。比如下面是通过JDK实现动态代理的示例代码，其中就使用了反射类`Method`来调用指定的方法。\r\n\r\n\r\n```java\r\npublic class DebugInvocationHandler implements InvocationHandler {\r\n    /**\r\n     * 代理类中的真实对象\r\n     */\r\n    private final Object target;\r\n\r\n    public DebugInvocationHandler(Object target) {\r\n        this.target = target;\r\n    }\r\n\r\n\r\n    public Object invoke(Object proxy, Method method, Object[] args) throws InvocationTargetException, IllegalAccessException {\r\n        System.out.println(\"before method \" + method.getName());\r\n        Object result = method.invoke(target, args);\r\n        System.out.println(\"after method \" + method.getName());\r\n        return result;\r\n    }\r\n}\r\n```\r\n\r\n另外，像Java中的一大利器注解的实现也用到了反射。为什么你使用Spring的时候，一个@Component注解就声明了一个类为Spring Bean呢？为什么你通过一个@Value注解就读取到配置文件中的值呢？究竟是怎么起作用的呢？\r\n\r\n这些都是因为你可以基于反射分析类，然后获取到类/属性/方法/方法的参数上的注解。你获取到注解之后，就可以做进一步的处理。\r\n\r\n## 反射机制的优缺点\r\n\r\n**优点**：可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利\r\n\r\n**缺点**：让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。\r\n\r\n> 相关阅读：[Java Reflection:Why is it so slow?](https://stackoverflow.com/questions/1392351/java-reflection-why-is-it-so-slow)\r\n\r\n## 反射实战\r\n\r\n### 获取Class对象的四种方式\r\n\r\n如果我们动态获取到这些信息，我们需要依靠Class对象。Class类对象将一个类的方法、变量等信息告诉运行的程序。Java提供了四种方式获取Class对象:\r\n\r\n**1. 知道具体类的情况下可以使用**：\r\n\r\n```java\r\nClass alunbarClass = TargetObject.class;\r\n```\r\n\r\n但是我们一般是不知道具体类的，基本都是通过遍历包下面的类来获取Class对象，通过此方式获取Class对象不会进行初始化\r\n\r\n**2. 通过Class.forName()传入类的全路径获取**：\r\n\r\n```java\r\nClass alunbarClass1 = Class.forName(\"cn.javaguide.TargetObject\");\r\n```\r\n\r\n**3. 通过对象实例instance.getClass()获取**：\r\n\r\n```java\r\nTargetObject o = new TargetObject();\r\nClass alunbarClass2 = o.getClass();\r\n```\r\n\r\n**4. 通过类加载器xxxClassLoader.loadClass()传入类路径获取**：\r\n\r\n```java\r\nClassLoader.getSystemClassLoader().loadClass(\"cn.javaguide.TargetObject\");\r\n```\r\n\r\n通过类加载器获取Class对象不会进行初始化，意味着不进行包括初始化等一系列步骤，静态代码块和静态对象不会得到执行\r\n\r\n### 反射的一些基本操作\r\n\r\n1. 创建一个我们要使用反射操作的类TargetObject。\r\n\r\n```java\r\npackage cn.javaguide;\r\n\r\npublic class TargetObject {\r\n    private String value;\r\n\r\n    public TargetObject() {\r\n        value = \"JavaGuide\";\r\n    }\r\n\r\n    public void publicMethod(String s) {\r\n        System.out.println(\"I love \" + s);\r\n    }\r\n\r\n    private void privateMethod() {\r\n        System.out.println(\"value is \" + value);\r\n    }\r\n}\r\n```\r\n\r\n2. 使用反射操作这个类的方法以及参数\r\n\r\n```java\r\npackage cn.javaguide;\r\n\r\nimport java.lang.reflect.Field;\r\nimport java.lang.reflect.InvocationTargetException;\r\nimport java.lang.reflect.Method;\r\n\r\npublic class Main {\r\n    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException, NoSuchFieldException {\r\n        /**\r\n         * 获取TargetObject类的Class对象并且创建TargetObject类实例\r\n         */\r\n        Class<?> targetClass = Class.forName(\"cn.javaguide.TargetObject\");\r\n        TargetObject targetObject = (TargetObject) targetClass.newInstance();\r\n        /**\r\n         * 获取TargetObject类中定义的所有方法\r\n         */\r\n        Method[] methods = targetClass.getDeclaredMethods();\r\n        for (Method method : methods) {\r\n            System.out.println(method.getName());\r\n        }\r\n        /**\r\n         * 获取指定方法并调用\r\n         */\r\n        Method publicMethod = targetClass.getDeclaredMethod(\"publicMethod\",String.class);\r\n        publicMethod.invoke(targetObject, \"JavaGuide\");\r\n        /**\r\n         * 获取指定参数并对参数进行修改\r\n         */\r\n        Field field = targetClass.getDeclaredField(\"value\");\r\n        //为了对类中的参数进行修改我们取消安全检查\r\n        field.setAccessible(true);\r\n        field.set(targetObject, \"JavaGuide\");\r\n        /**\r\n         * 调用private方法\r\n         */\r\n        Method privateMethod = targetClass.getDeclaredMethod(\"privateMethod\");\r\n        //为了调用private方法我们取消安全检查\r\n        privateMethod.setAccessible(true);\r\n        privateMethod.invoke(targetObject);\r\n    }\r\n}\r\n```\r\n\r\n输出内容：\r\n\r\n```text\r\npublicMethod\r\nprivateMethod\r\nI love JavaGuide\r\nvalue is JavaGuide\r\n```\r\n\r\n**注意**:有读者提到上面代码运行会抛出ClassNotFoundException异常,具体原因是你没有下面把这段代码的包名替换成自己创建的TargetObject所在的包。\r\n\r\n```java\r\nClass<?> targetClass = Class.forName(\"cn.javaguide.TargetObject\");\r\n```\r\n> [原文链接](https://javaguide.cn/java/basis/reflection.html)\r\n\r\n### 其他\r\n\r\n```java\r\npublic class ReflectTest {\r\n    public static void main(String[] args) throws Exception{\r\n        Class<?> clazz = Class.forName(\"com.xmxe.study_demo.entity.Student\");\r\n\r\n        // 获取所有pubic修饰的成员变量\r\n        Field[] fields = clazz.getFields();\r\n        for (Field field : fields) {\r\n            System.out.println(\"获取所有pubic修饰的成员变量===\"+field);\r\n        }\r\n        // 获取指定的pulic成员变量\r\n        Field field = clazz.getField(\"name\");\r\n        System.out.println(\"获取指定的pulic成员变量name===\" + field);\r\n        // 获取所有成员变量\r\n        Field[] fields2 =  clazz.getDeclaredFields();\r\n        for (Field field1 : fields2) {\r\n            System.out.println(\"获取所有成员变量===\"+field1);\r\n        }\r\n        // 获取指定成员变量，不考虑修饰符\r\n        Field field3 = clazz.getDeclaredField(\"age\");\r\n        System.out.println(\"获取指定成员变量，不考虑修饰符===\"+field3);\r\n\r\n        // 获取所有public 修饰的构造方法，返回一个含有所有public修饰的构造函数对象的数组。\r\n        Constructor<?>[] constructors = clazz.getConstructors();\r\n        for(Constructor<?> constructor : constructors){\r\n            System.out.println(\"获取所有public 修饰的构造方法===\"+constructor);\r\n        }\r\n        // 获取所有构造函数，不考虑修饰符，参数是构造器中参数类型对应的Class对象。\r\n        Constructor<?> con =  clazz.getDeclaredConstructor(String.class, Integer.class);\r\n        System.out.println(\"获取所有构造函数，不考虑修饰符，参数是构造器中参数类型对应的Class对象===\"+con);\r\n\r\n        // 获取所有方法，不考虑修饰符\r\n        Method[] methods = clazz.getDeclaredMethods();\r\n        for(Method method : methods){\r\n            System.out.println(\"获取所有方法，不考虑修饰符===\"+method);\r\n        }\r\n        // 根据方法名获取\r\n        Method method = clazz.getMethod(\"method1\", String.class,Integer.class);\r\n        System.out.println(\"根据方法名获取===\"+method);\r\n\r\n        // 获取类的全路径名\r\n        String getName = clazz.getName();\r\n        System.out.println(\"获取类的全路径名===\"+getName);\r\n\r\n        // 获取方法注解\r\n        Annotation[] annotations = method.getAnnotations();\r\n        for(Annotation annotation : annotations){\r\n            System.out.println(\"获取方法注解===\"+annotation);\r\n        }\r\n\r\n        OrderHandlerTypeAnnotation orderHandlerType = method.getAnnotation(OrderHandlerTypeAnnotation.class);\r\n        System.out.println(orderHandlerType.source()+\"---\"+orderHandlerType.annotationType());\r\n    }\r\n\r\n}\r\n```\r\n\r\n## 相关文章\r\n\r\n- [Java反射机制你还不会？那怎么看Spring源码？](https://mp.weixin.qq.com/s/jV9kE2ajB40f3fOU_lT9ng)\r\n- [Java反射是什么？看这篇绝对会了！](https://mp.weixin.qq.com/s/QbacsQwTyvBJi12LYPNKJw)\r\n- [学会这篇反射，我就可以去吹牛逼了。](https://mp.weixin.qq.com/s/Dyg4qSqiyjSJTne8yvUYpQ)\r\n- [深入理解Java：类加载机制及反射](https://mp.weixin.qq.com/s/kTYLjg_FlKBdAAQQvSAF9g)\r\n","categories":[{"name":"Java","path":"api/categories/Java.json"}],"tags":[{"name":"代码实战","path":"api/tags/代码实战.json"}]}