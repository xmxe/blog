{"title":"Spring Security介绍","slug":"Spring Security介绍","date":"2022-11-16T02:39:56.339Z","updated":"2023-05-05T01:02:49.827Z","comments":true,"path":"api/articles/Spring Security介绍.json","excerpt":null,"covers":"https://picd.zhimg.com/v2-f9c4c6b8a4b0f096032990926e1f0a1a_1440w.jpg","content":"<blockquote>\n<p><a href=\"https://github.com/xmxe/spring-security\">github地址</a></p>\n</blockquote>\n<h3 id=\"HttpSecurity常用方法\"><a href=\"#HttpSecurity常用方法\" class=\"headerlink\" title=\"HttpSecurity常用方法\"></a>HttpSecurity常用方法</h3><table>\n<thead>\n<tr>\n<th><a href=\"https://blog.csdn.net/qq_52006948/article/details/122729236\">HttpSecurity常用方法</a></th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>openidLogin()</td>\n<td>用于基于OpenId的验证</td>\n</tr>\n<tr>\n<td>headers()</td>\n<td>将安全标头添加到响应</td>\n</tr>\n<tr>\n<td>cors()</td>\n<td>配置跨域资源共享（CORS）</td>\n</tr>\n<tr>\n<td>sessionManagement()</td>\n<td>允许配置会话管理</td>\n</tr>\n<tr>\n<td>portMapper()</td>\n<td>允许配置一个PortMapper(HttpSecurity#(getSharedObject(class)))，其他提供SecurityConfigurer的对象使用PortMapper从HTTP重定向到HTTPS或者从HTTPS重定向到HTTP。默认情况下，Spring Security使用一个PortMapperImpl映射HTTP端口8080到HTTPS端口8443，HTTP端口80到HTTPS端口443</td>\n</tr>\n<tr>\n<td>jee()</td>\n<td>配置基于容器的预认证。在这种情况下，认证由Servlet容器管理</td>\n</tr>\n<tr>\n<td>x509()</td>\n<td>配置基于x509的认证</td>\n</tr>\n<tr>\n<td>rememberMe</td>\n<td>允许配置“记住我”的验证</td>\n</tr>\n<tr>\n<td>authorizeRequests()</td>\n<td>允许基于使用HttpServletRequest限制访问</td>\n</tr>\n<tr>\n<td>requestCache()</td>\n<td>允许配置请求缓存</td>\n</tr>\n<tr>\n<td>exceptionHandling()</td>\n<td>允许配置错误处理</td>\n</tr>\n<tr>\n<td>securityContext()</td>\n<td>在HttpServletRequests之间的SecurityContextHolder上设置SecurityContext的管理。当使用WebSecurityConfigurerAdapter时，这将自动应用</td>\n</tr>\n<tr>\n<td>servletApi()</td>\n<td>将HttpServletRequest方法与在其上找到的值集成到SecurityContext中。当使用WebSecurityConfigurerAdapter时，这将自动应用</td>\n</tr>\n<tr>\n<td>csrf()</td>\n<td>添加CSRF支持，使用WebSecurityConfigurerAdapter时，默认启用</td>\n</tr>\n<tr>\n<td>logout()</td>\n<td>添加退出登录支持。当使用WebSecurityConfigurerAdapter时，这将自动应用。默认情况是，访问URL”&#x2F;logout”，使HTTP Session无效来清除用户，清除已配置的任何#rememberMe()身份验证，清除SecurityContextHolder，然后重定向到”&#x2F;login?success”</td>\n</tr>\n<tr>\n<td>anonymous()</td>\n<td>允许配置匿名用户的表示方法。当与WebSecurityConfigurerAdapter结合使用时，这将自动应用。默认情况下，匿名用户将使用org.springframework.security.authentication.AnonymousAuthenticationToken表示，并包含角色“ROLE_ANONYMOUS”</td>\n</tr>\n<tr>\n<td>formLogin()</td>\n<td>指定支持基于表单的身份验证。如果未指定FormLoginConfigurer#loginPage(String)，则将生成默认登录页面</td>\n</tr>\n<tr>\n<td>oauth2Login()</td>\n<td>根据外部OAuth 2.0或OpenID Connect1.0提供程序配置身份验证</td>\n</tr>\n<tr>\n<td>requiresChannel()</td>\n<td>配置通道安全。为了使该配置有用，必须提供至少一个到所需信道的映射</td>\n</tr>\n<tr>\n<td>httpBasic()</td>\n<td>配置Http Basic验证</td>\n</tr>\n<tr>\n<td>addFilterAt()</td>\n<td>在指定的Filter类的位置添加过滤器</td>\n</tr>\n</tbody></table>\n<hr>\n<h3 id=\"Spring-Security认证流程\"><a href=\"#Spring-Security认证流程\" class=\"headerlink\" title=\"Spring Security认证流程\"></a>Spring Security认证流程</h3><ol>\n<li>Spring Security支持多种用户认证的方式，最常用的是基于用户名和密码的用户认证方式，其认证流程如下图所示：</li>\n</ol>\n<p><img src=\"/blog/images/rzlc.png\"></p>\n<ol start=\"2\">\n<li>“记住我”功能的认证流程如下图所示：</li>\n</ol>\n<p><img src=\"/blog/images/rememberme.png\"></p>\n<ol start=\"3\">\n<li>Spring Security的用户认证流程是由一系列的过滤器链来实现的，默认的关于用户认证的过滤器链大致如下图所示：</li>\n</ol>\n<p><img src=\"/blog/images/filterchain.png\"></p>\n<table>\n<thead>\n<tr>\n<th>SpringSecurity采用的是责任链的设计模式，</th>\n<th>它有一条很长的过滤器链。</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>WebAsyncManagerIntegrationFilter</td>\n<td>将Security上下文与Spring Web中用于处理异步请求映射的WebAsyncManager进行集成。</td>\n</tr>\n<tr>\n<td>SecurityContextPersistenceFilter</td>\n<td>在每次请求处理之前将该请求相关的安全上下文信息加载到SecurityContextHolder中，然后在该次请求处理完成之后，将SecurityContextHolder中关于这次请求的信息存储到一个“仓储”中，然后将SecurityContextHolder中的信息清除，例如在Session中维护一个用户的安全信息就是这个过滤器处理的。</td>\n</tr>\n<tr>\n<td>HeaderWriterFilter</td>\n<td>用于将头信息加入响应中</td>\n</tr>\n<tr>\n<td>CsrfFilter</td>\n<td>用于处理跨站请求伪造</td>\n</tr>\n<tr>\n<td>LogoutFilter</td>\n<td>用于处理退出登录</td>\n</tr>\n<tr>\n<td>UsernamePasswordAuthenticationFilter</td>\n<td>用于处理基于表单的登录请求，从表单中获取用户名和密码。默认情况下处理来自&#x2F;login的请求。从表单中获取用户名和密码时，默认使用的表单name值为username和password，这两个值可以通过设置这个过滤器的usernameParameter和passwordParameter两个参数的值进行修改</td>\n</tr>\n<tr>\n<td>DefaultLoginPageGeneratingFilter</td>\n<td>如果没有配置登录页面，那系统初始化时就会配置这个过滤器，并且用于在需要进行登录时生成一个登录表单页面。</td>\n</tr>\n<tr>\n<td>BasicAuthenticationFilter</td>\n<td>检测和处理http basic认证</td>\n</tr>\n<tr>\n<td>RequestCacheAwareFilter</td>\n<td>用来处理请求的缓存</td>\n</tr>\n<tr>\n<td>SecurityContextHolderAwareRequestFilter</td>\n<td>主要是包装请求对象request</td>\n</tr>\n<tr>\n<td>AnonymousAuthenticationFilter</td>\n<td>检测SecurityContextHolder中是否存在Authentication对象，如果不存在为其提供一个匿名Authentication</td>\n</tr>\n<tr>\n<td>SessionManagementFilter</td>\n<td>管理session的过滤器</td>\n</tr>\n<tr>\n<td>ExceptionTranslationFilter</td>\n<td>处理AccessDeniedException和AuthenticationException异常。</td>\n</tr>\n<tr>\n<td>FilterSecurityInterceptor</td>\n<td>可以看做过滤器链的出口</td>\n</tr>\n<tr>\n<td>RememberMeAuthenticationFilter</td>\n<td>当用户没有登录而直接访问资源时,从cookie里找出用户的信息,如果Spring Security能够识别出用户提供的remember me cookie,用户将不必填写用户名和密码,而是直接登录进入系统，该过滤器默认不开启。</td>\n</tr>\n</tbody></table>\n<ul>\n<li><a href=\"https://blog.csdn.net/u011066470/article/details/119086893\">spring security的认证和授权流程</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/502290821\">一文带你搞懂Spring Security认证授权流程</a></li>\n</ul>\n<hr>\n<h3 id=\"Spring-Security登录流程\"><a href=\"#Spring-Security登录流程\" class=\"headerlink\" title=\"Spring Security登录流程\"></a>Spring Security登录流程</h3><ol>\n<li>用户在页面输入账户密码并提交。</li>\n<li>UsernamePasswordAuthenticationFilter拦截认证请求并获取用户输入的账号和密码，<br>然后创建一个未认证的Authentication对象并交给AuthenticationManager进行认证。</li>\n<li>AuthenticationManager调用相应的AuthenticationProvider对象对未认证的Authentication对象进行认证。</li>\n<li>AuthenticationProvider从未认证的Authentication对象中获取用户输入的账号，并调用UserDetailsService对象查询该账号的正确信息，然后检查用户输入的账号信息与正确的账号信息是否相同–(UserDetailsService查询用户所输入的账号所对应的正确的密码和角色等信息并封装成UserDetails对象，然后返回给AuthenticationProvider进行认证)，如果不相同则认证失败并返回，如果相同认证成功并创建一个已认证的Authentication对象。<br>调用链<br>AuthenticationManager.authenticate()–&gt;ProviderManager.authenticate()–&gt;DaoAuthenticationProvider(AbstractUserDetailsAuthenticationProvider).authenticate()处理。<br>在最后的authenticate()⽅法中，调⽤了UserDetailsService.loadUserByUsername()并进⾏了密码校验，校验成功就构造⼀个认证过的UsernamePasswordAuthenticationToken对象放⼊SecurityContext。</li>\n<li>SecurityContext将已认证的Authentication对象保存在Spring Security上下文环境中表示用户已认证。</li>\n</ol>\n<hr>\n<h3 id=\"相关文章\"><a href=\"#相关文章\" class=\"headerlink\" title=\"相关文章\"></a>相关文章</h3><blockquote>\n<p>Spring Security系列～</p>\n<ul>\n<li><a href=\"https://github.com/lenve/spring-security-samples\">文章案例地址</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/2sVZxZDXP_dq-YgS86u4DQ\">Spring Security系列文章</a></li>\n<li><a href=\"https://pan.baidu.com/s/1PQPSWZONgo3_4TYOSjV8Vw?pwd=6p63\">离线 PDF 地址</a>提取码: 6p63</li>\n<li><a href=\"http://www.javaboy.org/springsecurity/\">Spring Security5.x教程合集(江南一点雨)</a></li>\n</ul>\n</blockquote>\n<ul>\n<li><a href=\"https://docs.spring.io/spring-security/reference/\">官方文档</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/67519928\">SpringBoot安全认证Security</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&mid=2247488278&idx=1&sn=b21345a1daa86dd48ea89cdb9138def8&scene=21#wechat_redirect\">单点登陆注解@EnableOAuth2Sso</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/TaPlws-ZLTDUnffuiw-r1Q\">Spring Security中的权限注解很神奇吗?(@PreAuthorize)</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/1NlWRwiBs8dl3Lu40haz5Q\">想要控制好权限，这八个注解你必须知道</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/WFbcvzqIM2muK3Ha4B0a3w\">进入SpringBoot2.7，有一个重要的类过期了</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/KKdhQNrNfALzcHxyMFsqAw\">新版SpringSecurity如何自定义JSON登录</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/2Ci_Xg8wTrRcEnjgt18CDw\">Spring Security中，想在权限中使用通配符，怎么做？</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/NTyYPGOSF9NobwtHas97sA\">如何在项目中自定义权限表达式</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/g_8UprUi6cX70q4kTv4W9g\">权限想要细化到按钮，怎么做？</a></li>\n<li><a href=\"https://blog.csdn.net/weixin_44516305/article/details/87860966\">Spring Security用户认证和权限控制（默认实现）</a></li>\n<li><a href=\"https://blog.csdn.net/weixin_44516305/article/details/88868791\">Spring Security用户认证和权限控制（自定义实现）</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/Bau8poOA4fMh3DNb9GaR1A\">Spring Security动态权限实现方案！</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/rJqXpL7Zy9q_TU5B_E7nSw\">Spring Security最佳实践，看了必懂！※</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/kB2SViBlcKwl2cV91FbidQ\">认证和授权：前后端分离状态下使用Spring Security实现安全访问控制</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/ZWwlheacryW5Zmo-Xw269g\">Spring Security中的RememberMe登录</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/3L-RTpvB9Q248_g7fBtDVA\">一文带你搞懂Spring Security</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/xZrsy7bp8xN3EJblz7TLHw\">盘点Spring Security框架中的八大经典设计模式</a></li>\n</ul>\n","more":"<blockquote>\n<p><a href=\"https://github.com/xmxe/spring-security\">github地址</a></p>\n</blockquote>\n<h3 id=\"HttpSecurity常用方法\"><a href=\"#HttpSecurity常用方法\" class=\"headerlink\" title=\"HttpSecurity常用方法\"></a>HttpSecurity常用方法</h3><table>\n<thead>\n<tr>\n<th><a href=\"https://blog.csdn.net/qq_52006948/article/details/122729236\">HttpSecurity常用方法</a></th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>openidLogin()</td>\n<td>用于基于OpenId的验证</td>\n</tr>\n<tr>\n<td>headers()</td>\n<td>将安全标头添加到响应</td>\n</tr>\n<tr>\n<td>cors()</td>\n<td>配置跨域资源共享（CORS）</td>\n</tr>\n<tr>\n<td>sessionManagement()</td>\n<td>允许配置会话管理</td>\n</tr>\n<tr>\n<td>portMapper()</td>\n<td>允许配置一个PortMapper(HttpSecurity#(getSharedObject(class)))，其他提供SecurityConfigurer的对象使用PortMapper从HTTP重定向到HTTPS或者从HTTPS重定向到HTTP。默认情况下，Spring Security使用一个PortMapperImpl映射HTTP端口8080到HTTPS端口8443，HTTP端口80到HTTPS端口443</td>\n</tr>\n<tr>\n<td>jee()</td>\n<td>配置基于容器的预认证。在这种情况下，认证由Servlet容器管理</td>\n</tr>\n<tr>\n<td>x509()</td>\n<td>配置基于x509的认证</td>\n</tr>\n<tr>\n<td>rememberMe</td>\n<td>允许配置“记住我”的验证</td>\n</tr>\n<tr>\n<td>authorizeRequests()</td>\n<td>允许基于使用HttpServletRequest限制访问</td>\n</tr>\n<tr>\n<td>requestCache()</td>\n<td>允许配置请求缓存</td>\n</tr>\n<tr>\n<td>exceptionHandling()</td>\n<td>允许配置错误处理</td>\n</tr>\n<tr>\n<td>securityContext()</td>\n<td>在HttpServletRequests之间的SecurityContextHolder上设置SecurityContext的管理。当使用WebSecurityConfigurerAdapter时，这将自动应用</td>\n</tr>\n<tr>\n<td>servletApi()</td>\n<td>将HttpServletRequest方法与在其上找到的值集成到SecurityContext中。当使用WebSecurityConfigurerAdapter时，这将自动应用</td>\n</tr>\n<tr>\n<td>csrf()</td>\n<td>添加CSRF支持，使用WebSecurityConfigurerAdapter时，默认启用</td>\n</tr>\n<tr>\n<td>logout()</td>\n<td>添加退出登录支持。当使用WebSecurityConfigurerAdapter时，这将自动应用。默认情况是，访问URL”&#x2F;logout”，使HTTP Session无效来清除用户，清除已配置的任何#rememberMe()身份验证，清除SecurityContextHolder，然后重定向到”&#x2F;login?success”</td>\n</tr>\n<tr>\n<td>anonymous()</td>\n<td>允许配置匿名用户的表示方法。当与WebSecurityConfigurerAdapter结合使用时，这将自动应用。默认情况下，匿名用户将使用org.springframework.security.authentication.AnonymousAuthenticationToken表示，并包含角色“ROLE_ANONYMOUS”</td>\n</tr>\n<tr>\n<td>formLogin()</td>\n<td>指定支持基于表单的身份验证。如果未指定FormLoginConfigurer#loginPage(String)，则将生成默认登录页面</td>\n</tr>\n<tr>\n<td>oauth2Login()</td>\n<td>根据外部OAuth 2.0或OpenID Connect1.0提供程序配置身份验证</td>\n</tr>\n<tr>\n<td>requiresChannel()</td>\n<td>配置通道安全。为了使该配置有用，必须提供至少一个到所需信道的映射</td>\n</tr>\n<tr>\n<td>httpBasic()</td>\n<td>配置Http Basic验证</td>\n</tr>\n<tr>\n<td>addFilterAt()</td>\n<td>在指定的Filter类的位置添加过滤器</td>\n</tr>\n</tbody></table>\n<hr>\n<h3 id=\"Spring-Security认证流程\"><a href=\"#Spring-Security认证流程\" class=\"headerlink\" title=\"Spring Security认证流程\"></a>Spring Security认证流程</h3><ol>\n<li>Spring Security支持多种用户认证的方式，最常用的是基于用户名和密码的用户认证方式，其认证流程如下图所示：</li>\n</ol>\n<p><img src=\"/blog/images/rzlc.png\"></p>\n<ol start=\"2\">\n<li>“记住我”功能的认证流程如下图所示：</li>\n</ol>\n<p><img src=\"/blog/images/rememberme.png\"></p>\n<ol start=\"3\">\n<li>Spring Security的用户认证流程是由一系列的过滤器链来实现的，默认的关于用户认证的过滤器链大致如下图所示：</li>\n</ol>\n<p><img src=\"/blog/images/filterchain.png\"></p>\n<table>\n<thead>\n<tr>\n<th>SpringSecurity采用的是责任链的设计模式，</th>\n<th>它有一条很长的过滤器链。</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>WebAsyncManagerIntegrationFilter</td>\n<td>将Security上下文与Spring Web中用于处理异步请求映射的WebAsyncManager进行集成。</td>\n</tr>\n<tr>\n<td>SecurityContextPersistenceFilter</td>\n<td>在每次请求处理之前将该请求相关的安全上下文信息加载到SecurityContextHolder中，然后在该次请求处理完成之后，将SecurityContextHolder中关于这次请求的信息存储到一个“仓储”中，然后将SecurityContextHolder中的信息清除，例如在Session中维护一个用户的安全信息就是这个过滤器处理的。</td>\n</tr>\n<tr>\n<td>HeaderWriterFilter</td>\n<td>用于将头信息加入响应中</td>\n</tr>\n<tr>\n<td>CsrfFilter</td>\n<td>用于处理跨站请求伪造</td>\n</tr>\n<tr>\n<td>LogoutFilter</td>\n<td>用于处理退出登录</td>\n</tr>\n<tr>\n<td>UsernamePasswordAuthenticationFilter</td>\n<td>用于处理基于表单的登录请求，从表单中获取用户名和密码。默认情况下处理来自&#x2F;login的请求。从表单中获取用户名和密码时，默认使用的表单name值为username和password，这两个值可以通过设置这个过滤器的usernameParameter和passwordParameter两个参数的值进行修改</td>\n</tr>\n<tr>\n<td>DefaultLoginPageGeneratingFilter</td>\n<td>如果没有配置登录页面，那系统初始化时就会配置这个过滤器，并且用于在需要进行登录时生成一个登录表单页面。</td>\n</tr>\n<tr>\n<td>BasicAuthenticationFilter</td>\n<td>检测和处理http basic认证</td>\n</tr>\n<tr>\n<td>RequestCacheAwareFilter</td>\n<td>用来处理请求的缓存</td>\n</tr>\n<tr>\n<td>SecurityContextHolderAwareRequestFilter</td>\n<td>主要是包装请求对象request</td>\n</tr>\n<tr>\n<td>AnonymousAuthenticationFilter</td>\n<td>检测SecurityContextHolder中是否存在Authentication对象，如果不存在为其提供一个匿名Authentication</td>\n</tr>\n<tr>\n<td>SessionManagementFilter</td>\n<td>管理session的过滤器</td>\n</tr>\n<tr>\n<td>ExceptionTranslationFilter</td>\n<td>处理AccessDeniedException和AuthenticationException异常。</td>\n</tr>\n<tr>\n<td>FilterSecurityInterceptor</td>\n<td>可以看做过滤器链的出口</td>\n</tr>\n<tr>\n<td>RememberMeAuthenticationFilter</td>\n<td>当用户没有登录而直接访问资源时,从cookie里找出用户的信息,如果Spring Security能够识别出用户提供的remember me cookie,用户将不必填写用户名和密码,而是直接登录进入系统，该过滤器默认不开启。</td>\n</tr>\n</tbody></table>\n<ul>\n<li><a href=\"https://blog.csdn.net/u011066470/article/details/119086893\">spring security的认证和授权流程</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/502290821\">一文带你搞懂Spring Security认证授权流程</a></li>\n</ul>\n<hr>\n<h3 id=\"Spring-Security登录流程\"><a href=\"#Spring-Security登录流程\" class=\"headerlink\" title=\"Spring Security登录流程\"></a>Spring Security登录流程</h3><ol>\n<li>用户在页面输入账户密码并提交。</li>\n<li>UsernamePasswordAuthenticationFilter拦截认证请求并获取用户输入的账号和密码，<br>然后创建一个未认证的Authentication对象并交给AuthenticationManager进行认证。</li>\n<li>AuthenticationManager调用相应的AuthenticationProvider对象对未认证的Authentication对象进行认证。</li>\n<li>AuthenticationProvider从未认证的Authentication对象中获取用户输入的账号，并调用UserDetailsService对象查询该账号的正确信息，然后检查用户输入的账号信息与正确的账号信息是否相同–(UserDetailsService查询用户所输入的账号所对应的正确的密码和角色等信息并封装成UserDetails对象，然后返回给AuthenticationProvider进行认证)，如果不相同则认证失败并返回，如果相同认证成功并创建一个已认证的Authentication对象。<br>调用链<br>AuthenticationManager.authenticate()–&gt;ProviderManager.authenticate()–&gt;DaoAuthenticationProvider(AbstractUserDetailsAuthenticationProvider).authenticate()处理。<br>在最后的authenticate()⽅法中，调⽤了UserDetailsService.loadUserByUsername()并进⾏了密码校验，校验成功就构造⼀个认证过的UsernamePasswordAuthenticationToken对象放⼊SecurityContext。</li>\n<li>SecurityContext将已认证的Authentication对象保存在Spring Security上下文环境中表示用户已认证。</li>\n</ol>\n<hr>\n<h3 id=\"相关文章\"><a href=\"#相关文章\" class=\"headerlink\" title=\"相关文章\"></a>相关文章</h3><blockquote>\n<p>Spring Security系列～</p>\n<ul>\n<li><a href=\"https://github.com/lenve/spring-security-samples\">文章案例地址</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/2sVZxZDXP_dq-YgS86u4DQ\">Spring Security系列文章</a></li>\n<li><a href=\"https://pan.baidu.com/s/1PQPSWZONgo3_4TYOSjV8Vw?pwd=6p63\">离线 PDF 地址</a>提取码: 6p63</li>\n<li><a href=\"http://www.javaboy.org/springsecurity/\">Spring Security5.x教程合集(江南一点雨)</a></li>\n</ul>\n</blockquote>\n<ul>\n<li><a href=\"https://docs.spring.io/spring-security/reference/\">官方文档</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/67519928\">SpringBoot安全认证Security</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&mid=2247488278&idx=1&sn=b21345a1daa86dd48ea89cdb9138def8&scene=21#wechat_redirect\">单点登陆注解@EnableOAuth2Sso</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/TaPlws-ZLTDUnffuiw-r1Q\">Spring Security中的权限注解很神奇吗?(@PreAuthorize)</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/1NlWRwiBs8dl3Lu40haz5Q\">想要控制好权限，这八个注解你必须知道</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/WFbcvzqIM2muK3Ha4B0a3w\">进入SpringBoot2.7，有一个重要的类过期了</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/KKdhQNrNfALzcHxyMFsqAw\">新版SpringSecurity如何自定义JSON登录</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/2Ci_Xg8wTrRcEnjgt18CDw\">Spring Security中，想在权限中使用通配符，怎么做？</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/NTyYPGOSF9NobwtHas97sA\">如何在项目中自定义权限表达式</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/g_8UprUi6cX70q4kTv4W9g\">权限想要细化到按钮，怎么做？</a></li>\n<li><a href=\"https://blog.csdn.net/weixin_44516305/article/details/87860966\">Spring Security用户认证和权限控制（默认实现）</a></li>\n<li><a href=\"https://blog.csdn.net/weixin_44516305/article/details/88868791\">Spring Security用户认证和权限控制（自定义实现）</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/Bau8poOA4fMh3DNb9GaR1A\">Spring Security动态权限实现方案！</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/rJqXpL7Zy9q_TU5B_E7nSw\">Spring Security最佳实践，看了必懂！※</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/kB2SViBlcKwl2cV91FbidQ\">认证和授权：前后端分离状态下使用Spring Security实现安全访问控制</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/ZWwlheacryW5Zmo-Xw269g\">Spring Security中的RememberMe登录</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/3L-RTpvB9Q248_g7fBtDVA\">一文带你搞懂Spring Security</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/xZrsy7bp8xN3EJblz7TLHw\">盘点Spring Security框架中的八大经典设计模式</a></li>\n</ul>\n","categories":[{"name":"Spring","path":"api/categories/Spring.json"}],"tags":[]}