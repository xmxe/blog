{"title":"数据库相关知识点","slug":"数据库相关知识点","date":"2022-09-28T08:22:51.972Z","updated":"2023-03-22T07:08:49.096Z","comments":true,"path":"api/articles/数据库相关知识点.json","excerpt":null,"covers":"https://img1.baidu.com/it/u=3919466326,3051780283&fm=253&fmt=auto&app=138&f=PNG?w=751&h=sq","content":"<h2 id=\"SQL查询慢的原因\"><a href=\"#SQL查询慢的原因\" class=\"headerlink\" title=\"SQL查询慢的原因\"></a>SQL查询慢的原因</h2><ol>\n<li>sql没加索引</li>\n<li>sql索引不生效:<br>隐式的类型转换，索引失效,<br>查询条件包含or，可能导致索引失效,<br>like通配符可能导致索引失效,<br>查询条件不满足联合索引的最左匹配原则,<br>在索引列上使用mysql的内置函数,<br>对索引进行列运算（如，+、-、*、&#x2F;）,索引不生效,<br>索引字段上使用（!&#x3D;或者&lt;&gt;），索引可能失效,<br>索引字段上使用is null,is not null，索引可能失效,<br>左右连接，关联的字段编码格式不一样,<br>优化器选错了索引</li>\n<li>limit深分页问题</li>\n<li>单表数据量太大</li>\n<li>join或者子查询过多</li>\n<li>in元素过多</li>\n<li>数据库在刷脏页</li>\n<li>order by文件排序</li>\n<li>拿不到锁</li>\n<li>delete + in子查询不走索引！</li>\n<li>group by使用临时表</li>\n<li>系统硬件或网络资源<br><a href=\"https://mp.weixin.qq.com/s/qCA7hICMktxeYO7Jc0oVVg\">盘点MySQL慢查询的12个原因</a></li>\n</ol>\n<h2 id=\"SQL优化\"><a href=\"#SQL优化\" class=\"headerlink\" title=\"SQL优化\"></a>SQL优化</h2><ol>\n<li>查询SQL尽量不要使用select *，而是select具体字段。<br><a href=\"https://mp.weixin.qq.com/s/2ActOr3bivQSMdyIZA5mbw\">为啥不建议使用Select *？</a></li>\n<li>如果知道查询结果只有一条或者只要最大&#x2F;最小一条记录，建议用limit 1</li>\n<li>应尽量避免在where子句中使用or来连接条件</li>\n<li>优化limit分页</li>\n<li>优化你的like语句</li>\n<li>使用where条件限定要查询的数据，避免返回多余的行</li>\n<li>尽量避免在索引列上使用mysql的内置函数</li>\n<li>应尽量避免在where子句中对字段进行表达式操作，这将导致系统放弃使用索引而进行全表扫</li>\n<li>Inner join 、left join、right join，优先使用Inner join，如果是left join，左边表结果尽量小</li>\n<li>应尽量避免在where子句中使用!&#x3D;或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。</li>\n<li>使用联合索引时，注意索引列的顺序，一般遵循最左匹配原则。</li>\n<li>对查询进行优化，应考虑在where及order by涉及的列上建立索引，尽量避免全表扫描。</li>\n<li>如果插入数据过多，考虑批量插入。</li>\n<li>在适当的时候，使用覆盖索引。</li>\n<li>慎用distinct关键字</li>\n<li>删除冗余和重复索引</li>\n<li>如果数据量较大，优化你的修改&#x2F;删除语句。</li>\n<li>where子句中考虑使用默认值代替null。</li>\n<li>不要有超过5个以上的表连接</li>\n<li>exist&amp;in的合理利用</li>\n<li>尽量用union all替换union</li>\n<li>索引不宜太多，一般5个以内。</li>\n<li>尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型</li>\n<li>索引不适合建在有大量重复数据的字段上，如性别这类型数据库字段。</li>\n<li>尽量避免向客户端返回过多数据量。</li>\n<li>当在SQL语句中连接多个表时,请使用表的别名，并把别名前缀于每一列上，这样语义更加清晰</li>\n<li>尽可能使用varchar&#x2F;nvarchar代替char&#x2F;nchar。</li>\n<li>为了提高group by语句的效率，可以在执行到该语句前，把不需要的记录过滤掉。</li>\n<li>如果字段类型是字符串，where时一定用引号括起来，否则索引失效</li>\n<li>使用explain分析你SQL的计划</li>\n</ol>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/5zsHr2tKOOkRN6mFa65tvw\">SQL优化的N种方法</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/4ByWZVc5jVmuVcFqkkIC_A\">吐血整理！书写高质量SQL的30条建议</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/Ky_jak-u7vCX4vXkAONN_w\">MySQL数据量太大优化方案</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/qJkEgNRlUwBAe41IdtJ_hQ\">Mysql数据库查询好慢，除了索引，还能因为什么？</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/eoKViDLmAB3ZaPuGgsk_zQ\">MySQL常用优化指南，面试再也不怕了！</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/Q9yb1Aa-PQCW1DguRzLUdg\">深入理解为什么MySQL全表扫描很慢？</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/Ow1vuBST7YUh5J5SYHT6dg\">专业解决MySQL查询速度慢与性能差！</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/VmAD31GYPV8HcE-m2aIrnA\">记一次神奇的SQL查询经历，group by慢查询优化</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/9RJxCqpKt0LTaSG0SHIttA\">SQL子查询怎么优化？写的很深！</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/NS2trUx9nVN5gNquVVbruw\">SQL优化极简法则，还有谁不会？</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/Z1OOMWBqeF_QQBvhbwo-sw\">如何写出一手好SQL？很有必要！</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/9LIn8H78gNyYnKZrIHLbgA\">每个后端都应该知道的八个提升SQL性能的Tips</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/BgOFpBBVvvlx-Jq0ZQg3AQ\">10个经典场景带你玩转SQL优化</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/Cirhr8SmBzyllAI3nQTXag\">聊聊sql优化的15个小技巧</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/ERpnzP4UvS-RUS2cmGmxKg\">阿里一面：SQL优化有哪些技巧？</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/w5oy8tg8sQ3GB8hw4esVDw\">如何让JOIN跑得更快？</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/wjDNsGFYxfgK5oAn9kdN9Q\">SQL优化万能公式：5大步骤+10个案例</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/A8OM449_JhKPIZa4P3w08Q\">SQL优化21连击+思维导图</a></li>\n</ul>\n<h2 id=\"水平拆分、垂直拆分\"><a href=\"#水平拆分、垂直拆分\" class=\"headerlink\" title=\"水平拆分、垂直拆分\"></a>水平拆分、垂直拆分</h2><ul>\n<li>水平拆分，就是把一个表的数据给弄到多个库的多个表里去，但是每个库的表结构都一样，只不过每个库表放的数据是不同的，所有库表的数据加起来就是全部数据。水平拆分的意义，就是将数据均匀放更多的库里，然后用多个库来扛更高的并发，还有就是用多个库的存储容量来进行扩容。</li>\n<li>垂直拆分，就是把一个有很多字段的表给拆分成多个表，或者是多个库上去。每个库表的结构都不一样，每个库表都包含部分字段。一般来说，会将较少的访问频率很高的字段放到一个表里去，然后将较多的访问频率很低的字段放到另外一个表里去。因为数据库是有缓存的，你访问频率高的行字段越少，就可以在缓存里缓存更多的行，性能就越好。这个一般在表层面做的较多一些。</li>\n<li><a href=\"https://mp.weixin.qq.com/s/_wDGx0UfG2hXo80JvvpBAw\">分库分表的四个面时连环炮问题</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/jqry9LnCVBt64d_DdpRXJg\">这四种情况下，才是考虑分库分表的时候！</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/fbZ8SpHh8ScV8Xt50PGb6A\">分库分表？如何做到永不迁移数据和避免热点？</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/4eII2YyVA_snLn4kswtNcQ\">这应该是最详尽的MySQL分库分表文章了</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/Q6VbgQaz0NVFG-8L4GC7bQ\">好好的系统，为什么要分库分表？</a></li>\n</ul>\n<h2 id=\"主键、外键\"><a href=\"#主键、外键\" class=\"headerlink\" title=\"主键、外键\"></a>主键、外键</h2><ul>\n<li>**主键(主码)**：主键用于唯一标识一个元组，不能有重复，不允许为空。一个表只能有一个主键。</li>\n<li>**外键(外码)**：外键用来和其他表建立联系用，外键是另一表的主键，外键是可以有重复的，可以是空值。一个表可以有多个外键。</li>\n</ul>\n<h3 id=\"为什么不推荐使用外键与级联？\"><a href=\"#为什么不推荐使用外键与级联？\" class=\"headerlink\" title=\"为什么不推荐使用外键与级联？\"></a>为什么不推荐使用外键与级联？</h3><p>对于外键和级联，阿里巴巴开发手册这样说到：</p>\n<blockquote>\n<p>【强制】不得使用外键与级联，一切外键概念必须在应用层解决。</p>\n<p>说明:以学生和成绩的关系为例，学生表中的student_id是主键，那么成绩表中的student_id则为外键。如果更新学生表中的student_id，同时触发成绩表中的student_id更新，即为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群;级联更新是强阻塞，存在数据库更新风暴的风险;外键影响数据库的插入速度</p>\n</blockquote>\n<p>为什么不要用外键呢？大部分人可能会这样回答：</p>\n<ol>\n<li><strong>增加了复杂性：</strong>a.每次做DELETE或者UPDATE都必须考虑外键约束，会导致开发的时候很痛苦,测试数据极为不方便;b.外键的主从关系是定的，假如那天需求有变化，数据库中的这个字段根本不需要和其他表有关联的话就会增加很多麻烦。</li>\n<li><strong>增加了额外工作</strong>：数据库需要增加维护外键的工作，比如当我们做一些涉及外键字段的增，删，更新操作之后，需要触发相关操作去检查，保证数据的的一致性和正确性，这样会不得不消耗资源；（个人觉得这个不是不用外键的原因，因为即使你不使用外键，你在应用层面也还是要保证的。所以，我觉得这个影响可以忽略不计。）</li>\n<li><strong>对分库分表不友好</strong>：因为分库分表下外键是无法生效的。</li>\n<li>……</li>\n</ol>\n<p>我个人觉得上面这种回答不是特别的全面，只是说了外键存在的一个常见的问题。实际上，我们知道外键也是有很多好处的，比如：</p>\n<ol>\n<li>保证了数据库数据的一致性和完整性；</li>\n<li>级联操作方便，减轻了程序代码量；</li>\n<li>……</li>\n</ol>\n<p>所以说，不要一股脑的就抛弃了外键这个概念，既然它存在就有它存在的道理，如果系统不涉及分库分表，并发量不是很高的情况还是可以考虑使用外键的。</p>\n<h3 id=\"关于数据库外键是否应该使用\"><a href=\"#关于数据库外键是否应该使用\" class=\"headerlink\" title=\"关于数据库外键是否应该使用\"></a>关于数据库外键是否应该使用</h3><p>外键提供的几种在更新和删除时的不同行为都可以帮助我们保证数据库中数据的一致性和引用合法性，但是外键的使用也需要数据库承担额外的开销，在大多数服务都可以水平扩容的今天，高并发场景中使用外键确实会影响服务的吞吐量上限。在数据库之外手动实现外键的功能是可能的，但是却会带来很多维护上的成本或者需要我们在数据一致性上做出一些妥协。我们可以从可用性、一致性几个方面分析使用外键、模拟外键以及不使用外键的差异：不使用外键牺牲了数据库中数据的一致性，但是却能够减少数据库的负载；模拟外键将一部分工作移到了数据库之外，我们可能需要放弃一部分一致性以获得更高的可用性，但是为了这部分可用性，我们会付出更多的研发与维护成本，也增加了与数据库之间的网络通信次数；使用外键保证了数据库中数据的一致性，也将全部的计算任务全部交给了数据库；在大多数不需要高并发或者对一致性有较强要求的系统中，我们可以直接使用数据库提供的外键帮助我们对数据进行校验，但是在对一致性要求不高的、复杂的场景或者大规模的团队中，不使用外键也确实可以为数据库减负，而大团队也有更多的时间和精力去设计其他的方案，例如：分布式的关系型数据库。当我们考虑应不应该在数据库中使用外键时，需要关注的核心我们的数据库承担这部分计算任务后会不会影响系统的可用性，在使用时也不应该一刀切的决定用或者不用外键，应该根据具体的场景做决策，我们在这里介绍了两个使用外键时可能遇到的问题：RESTRICT外键会在更新和删除关系表中的数据时对外键约束的合法性进行检查，保证外键不会引用到不存在的记录；CASCADE外键会在更新和删除关系表中的数据时触发对关联记录的更新和删除，在数据量较大的数据库中可能会有数量级的放大效果</p>\n<h2 id=\"数据库三大范式\"><a href=\"#数据库三大范式\" class=\"headerlink\" title=\"数据库三大范式\"></a>数据库三大范式</h2><p>数据库范式有3种：</p>\n<ul>\n<li>1NF(第一范式)：属性不可再分。</li>\n<li>2NF(第二范式)：1NF的基础之上，消除了非主属性对于码的部分函数依赖。</li>\n<li>3NF(第三范式)：3NF在2NF的基础之上，消除了非主属性对于码的传递函数依赖。</li>\n</ul>\n<h3 id=\"1NF-第一范式\"><a href=\"#1NF-第一范式\" class=\"headerlink\" title=\"1NF(第一范式)\"></a>1NF(第一范式)</h3><p>属性（对应于表中的字段）不能再被分割，也就是这个字段只能是一个值，不能再分为多个其他的字段了。<strong>1NF是所有关系型数据库的最基本要求</strong>，也就是说关系型数据库中创建的表一定满足第一范式。</p>\n<h3 id=\"2NF-第二范式\"><a href=\"#2NF-第二范式\" class=\"headerlink\" title=\"2NF(第二范式)\"></a>2NF(第二范式)</h3><p>2NF在1NF的基础之上，消除了非主属性对于码的部分函数依赖。如下图所示，展示了第一范式到第二范式的过渡。第二范式在第一范式的基础上增加了一个列，这个列称为主键，非主属性都依赖于主键。</p>\n<p><img src=\"https://oss.javaguide.cn/github/javaguide/csdn/bd1d31be3779342427fc9e462bf7f05c.png\" alt=\"第二范式\"></p>\n<p>一些重要的概念：</p>\n<ul>\n<li><strong>函数依赖（functionaldependency）</strong>：若在一张表中，在属性（或属性组）X的值确定的情况下，必定能确定属性Y的值，那么就可以说Y函数依赖于X，写作X→Y。</li>\n<li><strong>部分函数依赖（partialfunctionaldependency）</strong>：如果X→Y，并且存在X的一个真子集X0，使得X0→Y，则称Y对X部分函数依赖。比如学生基本信息表R中（学号，身份证号，姓名）当然学号属性取值是唯一的，在R关系中，（学号，身份证号）-&gt;（姓名），（学号）-&gt;（姓名），（身份证号）-&gt;（姓名）；所以姓名部分函数依赖与（学号，身份证号）；</li>\n<li>**完全函数依赖(Fullfunctionaldependency)**：在一个关系中，若某个非主属性数据项依赖于全部关键字称之为完全函数依赖。比如学生基本信息表R（学号，班级，姓名）假设不同的班级学号有相同的，班级内学号不能相同，在R关系中，（学号，班级）-&gt;（姓名），但是（学号）-&gt;(姓名)不成立，（班级）-&gt;(姓名)不成立，所以姓名完全函数依赖与（学号，班级）；</li>\n<li><strong>传递函数依赖</strong>：在关系模式R(U)中，设X，Y，Z是U的不同的属性子集，如果X确定Y、Y确定Z，且有X不包含Y，Y不确定X，（X∪Y）∩Z&#x3D;空集合，则称Z传递函数依赖(transitivefunctionaldependency)于X。传递函数依赖会导致数据冗余和异常。传递函数依赖的Y和Z子集往往同属于某一个事物，因此可将其合并放到一个表中。比如在关系R(学号,姓名,系名，系主任)中，学号→系名，系名→系主任，所以存在非主属性系主任对于学号的传递函数依赖。。</li>\n</ul>\n<h3 id=\"3NF-第三范式\"><a href=\"#3NF-第三范式\" class=\"headerlink\" title=\"3NF(第三范式)\"></a>3NF(第三范式)</h3><p>3NF在2NF的基础之上，消除了非主属性对于码的传递函数依赖。符合3NF要求的数据库设计，<strong>基本</strong>上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。比如在关系R(学号,姓名,系名，系主任)中，学号→系名，系名→系主任，所以存在非主属性系主任对于学号的传递函数依赖，所以该表的设计，不符合3NF的要求。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li>1NF：数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，不能在一列中存放多个属性。例如员工信息表，不能在信息一列中放入电话，住址等信息，应该单独设计成电话、住址各一列</li>\n<li>2NF：每个表必须有主键(Primary key),其他数据元素与主键一一对应。通常称这种关系为函数依赖(Functional dependence)关系，即表中其他数据元素都依赖于主键,或称该数据元素惟一地被主键所标识,例如学生表（学生id，姓名，成绩，合格状态），其中合格状态这一列不依赖于学生信息，而依赖于成绩，所以不符合第二范式</li>\n<li>3NF:要求一个数据库表中不包含已在其它表中已包含的非主关键字信息,例如学生表（学生id，姓名，班级id，班级位置）班级表(班级id，班级名，班级位置)，学生表里已经有了班级的id，可以推断出班级位置，无需在学生表里存入班级位置信息<br>BCNF:所有非主属性对每一个候选键都是完全函数依赖；所有的主属性对每一个不包含它的候选键，也是完全函数依赖；没有任何属性完全函数依赖于非候选键的任何一组属性</li>\n</ul>\n<p>注意事项：</p>\n<ol>\n<li>第二范式与第三范式的本质区别：在于有没有分出两张表。<br>第二范式是说一张表中包含了多种不同实体的属性，那么必须要分成多张表，第三范式是要求已经分好了多张表的话，一张表中只能有另一张标的ID，而不能有其他任何信息，（其他任何信息，一律用主键在另一张表中查询）。</li>\n<li>必须先满足第一范式才能满足第二范式，必须同时满足第一第二范式才能满足第三范式。<br>三大范式只是一般设计数据库的基本理念，可以建立冗余较小、结构合理的数据库。如果有特殊情况，当然要特殊对待，数据库设计最重要的是看需求跟性能，需求&gt;性能&gt;表结构。所以不能一味的去追求范式建立数据库。</li>\n</ol>\n<h2 id=\"五大约束\"><a href=\"#五大约束\" class=\"headerlink\" title=\"五大约束\"></a>五大约束</h2><p>数据库中的五大约束包括：</p>\n<ol>\n<li>主键约束（Primay Key Coustraint）唯一性，非空性；</li>\n<li>唯一约束 （Unique Counstraint）唯一性，可以空，但只能有一个</li>\n<li>默认约束 (Default Counstraint)该数据的默认值；</li>\n<li>外键约束 (Foreign Key Counstraint)需要建立两表间的关系；</li>\n<li>非空约束（Not Null Counstraint）:设置非空约束，该字段不能为空。</li>\n</ol>\n<h2 id=\"相关文章\"><a href=\"#相关文章\" class=\"headerlink\" title=\"相关文章\"></a>相关文章</h2><ul>\n<li><a href=\"https://mp.weixin.qq.com/s/gCT048J16KO3ucNtzvAWxA\">数据库面试题（函数和存储过程区别）</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/zx2PY8A_L5wnVc7goMY5WQ\">吊打面试官？2020年数据库高频面试题|原力计划</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=Mzg2MDYzODI5Nw==&mid=2247494238&idx=1&sn=e44bf7e2ba678a562246e8831d5d8dc4&source=41#wechat_redirect\">JDBC查询各种姿势（普通、流式、游标）</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/AUXNm2LyVl4NtKGEzBaWFg\">1.2W字的SQL语法速成手册</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/BhMjFRqlDYKQNaCKj2tnkQ\">使用uuid作为数据库主键，被技术总监怼了一顿！</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/zdxkbtHxdgGtgck1zjZmWw\">一直认为count(1)比count(*)效果高，被同事鄙视了。</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/7ipMLtkeJhCAtxKlEvOFzw\">我说用count(*)统计行数，面试官让我回去等消息..</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/Siyd8kkZEsSV5g0D2qsCHg\">8种常见SQL错误用法</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/SZnwP5Guu4RraxBI6l6nFg\">常见的SQL面试题：经典50例</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/NbZnNOZTUZaavEAKD-CSYw\">一文搞定关系数据库设计要领，值得收藏！</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/hd7-IjhRW5DyWZi9MdEG0w\">常用数据库SQL命令详解（上）</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/gidYvMFQGM8VaiQkP_9IjQ\">常用数据库SQL命令详解（下）</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/jhej5m8qs0isEzJC-SpLfA\">输入SQL到返回数据，到底发生了什么？</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/M9PmFMmXToJOMyzVWj0Z5g\">一条SQL查询语句是如何执行的？</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/Xu_SfM-DzKarybGpspwIHA\">数据库主键一定要自增吗？有哪些场景不建议自增？</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/2ea_no_oonNb58OqInRn5g\">慢SQL，压垮团队的最后一根稻草</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/03lD4P0rE909Kkvm_7vLNg\">聊聊数据库建表的15个小技巧</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/FPdl_-jqgeIXSGOh-MQNFQ\">百亿级数据分库分表后怎么分页查询？</a></li>\n</ul>\n","more":"<h2 id=\"SQL查询慢的原因\"><a href=\"#SQL查询慢的原因\" class=\"headerlink\" title=\"SQL查询慢的原因\"></a>SQL查询慢的原因</h2><ol>\n<li>sql没加索引</li>\n<li>sql索引不生效:<br>隐式的类型转换，索引失效,<br>查询条件包含or，可能导致索引失效,<br>like通配符可能导致索引失效,<br>查询条件不满足联合索引的最左匹配原则,<br>在索引列上使用mysql的内置函数,<br>对索引进行列运算（如，+、-、*、&#x2F;）,索引不生效,<br>索引字段上使用（!&#x3D;或者&lt;&gt;），索引可能失效,<br>索引字段上使用is null,is not null，索引可能失效,<br>左右连接，关联的字段编码格式不一样,<br>优化器选错了索引</li>\n<li>limit深分页问题</li>\n<li>单表数据量太大</li>\n<li>join或者子查询过多</li>\n<li>in元素过多</li>\n<li>数据库在刷脏页</li>\n<li>order by文件排序</li>\n<li>拿不到锁</li>\n<li>delete + in子查询不走索引！</li>\n<li>group by使用临时表</li>\n<li>系统硬件或网络资源<br><a href=\"https://mp.weixin.qq.com/s/qCA7hICMktxeYO7Jc0oVVg\">盘点MySQL慢查询的12个原因</a></li>\n</ol>\n<h2 id=\"SQL优化\"><a href=\"#SQL优化\" class=\"headerlink\" title=\"SQL优化\"></a>SQL优化</h2><ol>\n<li>查询SQL尽量不要使用select *，而是select具体字段。<br><a href=\"https://mp.weixin.qq.com/s/2ActOr3bivQSMdyIZA5mbw\">为啥不建议使用Select *？</a></li>\n<li>如果知道查询结果只有一条或者只要最大&#x2F;最小一条记录，建议用limit 1</li>\n<li>应尽量避免在where子句中使用or来连接条件</li>\n<li>优化limit分页</li>\n<li>优化你的like语句</li>\n<li>使用where条件限定要查询的数据，避免返回多余的行</li>\n<li>尽量避免在索引列上使用mysql的内置函数</li>\n<li>应尽量避免在where子句中对字段进行表达式操作，这将导致系统放弃使用索引而进行全表扫</li>\n<li>Inner join 、left join、right join，优先使用Inner join，如果是left join，左边表结果尽量小</li>\n<li>应尽量避免在where子句中使用!&#x3D;或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。</li>\n<li>使用联合索引时，注意索引列的顺序，一般遵循最左匹配原则。</li>\n<li>对查询进行优化，应考虑在where及order by涉及的列上建立索引，尽量避免全表扫描。</li>\n<li>如果插入数据过多，考虑批量插入。</li>\n<li>在适当的时候，使用覆盖索引。</li>\n<li>慎用distinct关键字</li>\n<li>删除冗余和重复索引</li>\n<li>如果数据量较大，优化你的修改&#x2F;删除语句。</li>\n<li>where子句中考虑使用默认值代替null。</li>\n<li>不要有超过5个以上的表连接</li>\n<li>exist&amp;in的合理利用</li>\n<li>尽量用union all替换union</li>\n<li>索引不宜太多，一般5个以内。</li>\n<li>尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型</li>\n<li>索引不适合建在有大量重复数据的字段上，如性别这类型数据库字段。</li>\n<li>尽量避免向客户端返回过多数据量。</li>\n<li>当在SQL语句中连接多个表时,请使用表的别名，并把别名前缀于每一列上，这样语义更加清晰</li>\n<li>尽可能使用varchar&#x2F;nvarchar代替char&#x2F;nchar。</li>\n<li>为了提高group by语句的效率，可以在执行到该语句前，把不需要的记录过滤掉。</li>\n<li>如果字段类型是字符串，where时一定用引号括起来，否则索引失效</li>\n<li>使用explain分析你SQL的计划</li>\n</ol>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/5zsHr2tKOOkRN6mFa65tvw\">SQL优化的N种方法</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/4ByWZVc5jVmuVcFqkkIC_A\">吐血整理！书写高质量SQL的30条建议</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/Ky_jak-u7vCX4vXkAONN_w\">MySQL数据量太大优化方案</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/qJkEgNRlUwBAe41IdtJ_hQ\">Mysql数据库查询好慢，除了索引，还能因为什么？</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/eoKViDLmAB3ZaPuGgsk_zQ\">MySQL常用优化指南，面试再也不怕了！</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/Q9yb1Aa-PQCW1DguRzLUdg\">深入理解为什么MySQL全表扫描很慢？</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/Ow1vuBST7YUh5J5SYHT6dg\">专业解决MySQL查询速度慢与性能差！</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/VmAD31GYPV8HcE-m2aIrnA\">记一次神奇的SQL查询经历，group by慢查询优化</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/9RJxCqpKt0LTaSG0SHIttA\">SQL子查询怎么优化？写的很深！</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/NS2trUx9nVN5gNquVVbruw\">SQL优化极简法则，还有谁不会？</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/Z1OOMWBqeF_QQBvhbwo-sw\">如何写出一手好SQL？很有必要！</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/9LIn8H78gNyYnKZrIHLbgA\">每个后端都应该知道的八个提升SQL性能的Tips</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/BgOFpBBVvvlx-Jq0ZQg3AQ\">10个经典场景带你玩转SQL优化</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/Cirhr8SmBzyllAI3nQTXag\">聊聊sql优化的15个小技巧</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/ERpnzP4UvS-RUS2cmGmxKg\">阿里一面：SQL优化有哪些技巧？</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/w5oy8tg8sQ3GB8hw4esVDw\">如何让JOIN跑得更快？</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/wjDNsGFYxfgK5oAn9kdN9Q\">SQL优化万能公式：5大步骤+10个案例</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/A8OM449_JhKPIZa4P3w08Q\">SQL优化21连击+思维导图</a></li>\n</ul>\n<h2 id=\"水平拆分、垂直拆分\"><a href=\"#水平拆分、垂直拆分\" class=\"headerlink\" title=\"水平拆分、垂直拆分\"></a>水平拆分、垂直拆分</h2><ul>\n<li>水平拆分，就是把一个表的数据给弄到多个库的多个表里去，但是每个库的表结构都一样，只不过每个库表放的数据是不同的，所有库表的数据加起来就是全部数据。水平拆分的意义，就是将数据均匀放更多的库里，然后用多个库来扛更高的并发，还有就是用多个库的存储容量来进行扩容。</li>\n<li>垂直拆分，就是把一个有很多字段的表给拆分成多个表，或者是多个库上去。每个库表的结构都不一样，每个库表都包含部分字段。一般来说，会将较少的访问频率很高的字段放到一个表里去，然后将较多的访问频率很低的字段放到另外一个表里去。因为数据库是有缓存的，你访问频率高的行字段越少，就可以在缓存里缓存更多的行，性能就越好。这个一般在表层面做的较多一些。</li>\n<li><a href=\"https://mp.weixin.qq.com/s/_wDGx0UfG2hXo80JvvpBAw\">分库分表的四个面时连环炮问题</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/jqry9LnCVBt64d_DdpRXJg\">这四种情况下，才是考虑分库分表的时候！</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/fbZ8SpHh8ScV8Xt50PGb6A\">分库分表？如何做到永不迁移数据和避免热点？</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/4eII2YyVA_snLn4kswtNcQ\">这应该是最详尽的MySQL分库分表文章了</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/Q6VbgQaz0NVFG-8L4GC7bQ\">好好的系统，为什么要分库分表？</a></li>\n</ul>\n<h2 id=\"主键、外键\"><a href=\"#主键、外键\" class=\"headerlink\" title=\"主键、外键\"></a>主键、外键</h2><ul>\n<li>**主键(主码)**：主键用于唯一标识一个元组，不能有重复，不允许为空。一个表只能有一个主键。</li>\n<li>**外键(外码)**：外键用来和其他表建立联系用，外键是另一表的主键，外键是可以有重复的，可以是空值。一个表可以有多个外键。</li>\n</ul>\n<h3 id=\"为什么不推荐使用外键与级联？\"><a href=\"#为什么不推荐使用外键与级联？\" class=\"headerlink\" title=\"为什么不推荐使用外键与级联？\"></a>为什么不推荐使用外键与级联？</h3><p>对于外键和级联，阿里巴巴开发手册这样说到：</p>\n<blockquote>\n<p>【强制】不得使用外键与级联，一切外键概念必须在应用层解决。</p>\n<p>说明:以学生和成绩的关系为例，学生表中的student_id是主键，那么成绩表中的student_id则为外键。如果更新学生表中的student_id，同时触发成绩表中的student_id更新，即为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群;级联更新是强阻塞，存在数据库更新风暴的风险;外键影响数据库的插入速度</p>\n</blockquote>\n<p>为什么不要用外键呢？大部分人可能会这样回答：</p>\n<ol>\n<li><strong>增加了复杂性：</strong>a.每次做DELETE或者UPDATE都必须考虑外键约束，会导致开发的时候很痛苦,测试数据极为不方便;b.外键的主从关系是定的，假如那天需求有变化，数据库中的这个字段根本不需要和其他表有关联的话就会增加很多麻烦。</li>\n<li><strong>增加了额外工作</strong>：数据库需要增加维护外键的工作，比如当我们做一些涉及外键字段的增，删，更新操作之后，需要触发相关操作去检查，保证数据的的一致性和正确性，这样会不得不消耗资源；（个人觉得这个不是不用外键的原因，因为即使你不使用外键，你在应用层面也还是要保证的。所以，我觉得这个影响可以忽略不计。）</li>\n<li><strong>对分库分表不友好</strong>：因为分库分表下外键是无法生效的。</li>\n<li>……</li>\n</ol>\n<p>我个人觉得上面这种回答不是特别的全面，只是说了外键存在的一个常见的问题。实际上，我们知道外键也是有很多好处的，比如：</p>\n<ol>\n<li>保证了数据库数据的一致性和完整性；</li>\n<li>级联操作方便，减轻了程序代码量；</li>\n<li>……</li>\n</ol>\n<p>所以说，不要一股脑的就抛弃了外键这个概念，既然它存在就有它存在的道理，如果系统不涉及分库分表，并发量不是很高的情况还是可以考虑使用外键的。</p>\n<h3 id=\"关于数据库外键是否应该使用\"><a href=\"#关于数据库外键是否应该使用\" class=\"headerlink\" title=\"关于数据库外键是否应该使用\"></a>关于数据库外键是否应该使用</h3><p>外键提供的几种在更新和删除时的不同行为都可以帮助我们保证数据库中数据的一致性和引用合法性，但是外键的使用也需要数据库承担额外的开销，在大多数服务都可以水平扩容的今天，高并发场景中使用外键确实会影响服务的吞吐量上限。在数据库之外手动实现外键的功能是可能的，但是却会带来很多维护上的成本或者需要我们在数据一致性上做出一些妥协。我们可以从可用性、一致性几个方面分析使用外键、模拟外键以及不使用外键的差异：不使用外键牺牲了数据库中数据的一致性，但是却能够减少数据库的负载；模拟外键将一部分工作移到了数据库之外，我们可能需要放弃一部分一致性以获得更高的可用性，但是为了这部分可用性，我们会付出更多的研发与维护成本，也增加了与数据库之间的网络通信次数；使用外键保证了数据库中数据的一致性，也将全部的计算任务全部交给了数据库；在大多数不需要高并发或者对一致性有较强要求的系统中，我们可以直接使用数据库提供的外键帮助我们对数据进行校验，但是在对一致性要求不高的、复杂的场景或者大规模的团队中，不使用外键也确实可以为数据库减负，而大团队也有更多的时间和精力去设计其他的方案，例如：分布式的关系型数据库。当我们考虑应不应该在数据库中使用外键时，需要关注的核心我们的数据库承担这部分计算任务后会不会影响系统的可用性，在使用时也不应该一刀切的决定用或者不用外键，应该根据具体的场景做决策，我们在这里介绍了两个使用外键时可能遇到的问题：RESTRICT外键会在更新和删除关系表中的数据时对外键约束的合法性进行检查，保证外键不会引用到不存在的记录；CASCADE外键会在更新和删除关系表中的数据时触发对关联记录的更新和删除，在数据量较大的数据库中可能会有数量级的放大效果</p>\n<h2 id=\"数据库三大范式\"><a href=\"#数据库三大范式\" class=\"headerlink\" title=\"数据库三大范式\"></a>数据库三大范式</h2><p>数据库范式有3种：</p>\n<ul>\n<li>1NF(第一范式)：属性不可再分。</li>\n<li>2NF(第二范式)：1NF的基础之上，消除了非主属性对于码的部分函数依赖。</li>\n<li>3NF(第三范式)：3NF在2NF的基础之上，消除了非主属性对于码的传递函数依赖。</li>\n</ul>\n<h3 id=\"1NF-第一范式\"><a href=\"#1NF-第一范式\" class=\"headerlink\" title=\"1NF(第一范式)\"></a>1NF(第一范式)</h3><p>属性（对应于表中的字段）不能再被分割，也就是这个字段只能是一个值，不能再分为多个其他的字段了。<strong>1NF是所有关系型数据库的最基本要求</strong>，也就是说关系型数据库中创建的表一定满足第一范式。</p>\n<h3 id=\"2NF-第二范式\"><a href=\"#2NF-第二范式\" class=\"headerlink\" title=\"2NF(第二范式)\"></a>2NF(第二范式)</h3><p>2NF在1NF的基础之上，消除了非主属性对于码的部分函数依赖。如下图所示，展示了第一范式到第二范式的过渡。第二范式在第一范式的基础上增加了一个列，这个列称为主键，非主属性都依赖于主键。</p>\n<p><img src=\"https://oss.javaguide.cn/github/javaguide/csdn/bd1d31be3779342427fc9e462bf7f05c.png\" alt=\"第二范式\"></p>\n<p>一些重要的概念：</p>\n<ul>\n<li><strong>函数依赖（functionaldependency）</strong>：若在一张表中，在属性（或属性组）X的值确定的情况下，必定能确定属性Y的值，那么就可以说Y函数依赖于X，写作X→Y。</li>\n<li><strong>部分函数依赖（partialfunctionaldependency）</strong>：如果X→Y，并且存在X的一个真子集X0，使得X0→Y，则称Y对X部分函数依赖。比如学生基本信息表R中（学号，身份证号，姓名）当然学号属性取值是唯一的，在R关系中，（学号，身份证号）-&gt;（姓名），（学号）-&gt;（姓名），（身份证号）-&gt;（姓名）；所以姓名部分函数依赖与（学号，身份证号）；</li>\n<li>**完全函数依赖(Fullfunctionaldependency)**：在一个关系中，若某个非主属性数据项依赖于全部关键字称之为完全函数依赖。比如学生基本信息表R（学号，班级，姓名）假设不同的班级学号有相同的，班级内学号不能相同，在R关系中，（学号，班级）-&gt;（姓名），但是（学号）-&gt;(姓名)不成立，（班级）-&gt;(姓名)不成立，所以姓名完全函数依赖与（学号，班级）；</li>\n<li><strong>传递函数依赖</strong>：在关系模式R(U)中，设X，Y，Z是U的不同的属性子集，如果X确定Y、Y确定Z，且有X不包含Y，Y不确定X，（X∪Y）∩Z&#x3D;空集合，则称Z传递函数依赖(transitivefunctionaldependency)于X。传递函数依赖会导致数据冗余和异常。传递函数依赖的Y和Z子集往往同属于某一个事物，因此可将其合并放到一个表中。比如在关系R(学号,姓名,系名，系主任)中，学号→系名，系名→系主任，所以存在非主属性系主任对于学号的传递函数依赖。。</li>\n</ul>\n<h3 id=\"3NF-第三范式\"><a href=\"#3NF-第三范式\" class=\"headerlink\" title=\"3NF(第三范式)\"></a>3NF(第三范式)</h3><p>3NF在2NF的基础之上，消除了非主属性对于码的传递函数依赖。符合3NF要求的数据库设计，<strong>基本</strong>上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。比如在关系R(学号,姓名,系名，系主任)中，学号→系名，系名→系主任，所以存在非主属性系主任对于学号的传递函数依赖，所以该表的设计，不符合3NF的要求。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li>1NF：数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，不能在一列中存放多个属性。例如员工信息表，不能在信息一列中放入电话，住址等信息，应该单独设计成电话、住址各一列</li>\n<li>2NF：每个表必须有主键(Primary key),其他数据元素与主键一一对应。通常称这种关系为函数依赖(Functional dependence)关系，即表中其他数据元素都依赖于主键,或称该数据元素惟一地被主键所标识,例如学生表（学生id，姓名，成绩，合格状态），其中合格状态这一列不依赖于学生信息，而依赖于成绩，所以不符合第二范式</li>\n<li>3NF:要求一个数据库表中不包含已在其它表中已包含的非主关键字信息,例如学生表（学生id，姓名，班级id，班级位置）班级表(班级id，班级名，班级位置)，学生表里已经有了班级的id，可以推断出班级位置，无需在学生表里存入班级位置信息<br>BCNF:所有非主属性对每一个候选键都是完全函数依赖；所有的主属性对每一个不包含它的候选键，也是完全函数依赖；没有任何属性完全函数依赖于非候选键的任何一组属性</li>\n</ul>\n<p>注意事项：</p>\n<ol>\n<li>第二范式与第三范式的本质区别：在于有没有分出两张表。<br>第二范式是说一张表中包含了多种不同实体的属性，那么必须要分成多张表，第三范式是要求已经分好了多张表的话，一张表中只能有另一张标的ID，而不能有其他任何信息，（其他任何信息，一律用主键在另一张表中查询）。</li>\n<li>必须先满足第一范式才能满足第二范式，必须同时满足第一第二范式才能满足第三范式。<br>三大范式只是一般设计数据库的基本理念，可以建立冗余较小、结构合理的数据库。如果有特殊情况，当然要特殊对待，数据库设计最重要的是看需求跟性能，需求&gt;性能&gt;表结构。所以不能一味的去追求范式建立数据库。</li>\n</ol>\n<h2 id=\"五大约束\"><a href=\"#五大约束\" class=\"headerlink\" title=\"五大约束\"></a>五大约束</h2><p>数据库中的五大约束包括：</p>\n<ol>\n<li>主键约束（Primay Key Coustraint）唯一性，非空性；</li>\n<li>唯一约束 （Unique Counstraint）唯一性，可以空，但只能有一个</li>\n<li>默认约束 (Default Counstraint)该数据的默认值；</li>\n<li>外键约束 (Foreign Key Counstraint)需要建立两表间的关系；</li>\n<li>非空约束（Not Null Counstraint）:设置非空约束，该字段不能为空。</li>\n</ol>\n<h2 id=\"相关文章\"><a href=\"#相关文章\" class=\"headerlink\" title=\"相关文章\"></a>相关文章</h2><ul>\n<li><a href=\"https://mp.weixin.qq.com/s/gCT048J16KO3ucNtzvAWxA\">数据库面试题（函数和存储过程区别）</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/zx2PY8A_L5wnVc7goMY5WQ\">吊打面试官？2020年数据库高频面试题|原力计划</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=Mzg2MDYzODI5Nw==&mid=2247494238&idx=1&sn=e44bf7e2ba678a562246e8831d5d8dc4&source=41#wechat_redirect\">JDBC查询各种姿势（普通、流式、游标）</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/AUXNm2LyVl4NtKGEzBaWFg\">1.2W字的SQL语法速成手册</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/BhMjFRqlDYKQNaCKj2tnkQ\">使用uuid作为数据库主键，被技术总监怼了一顿！</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/zdxkbtHxdgGtgck1zjZmWw\">一直认为count(1)比count(*)效果高，被同事鄙视了。</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/7ipMLtkeJhCAtxKlEvOFzw\">我说用count(*)统计行数，面试官让我回去等消息..</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/Siyd8kkZEsSV5g0D2qsCHg\">8种常见SQL错误用法</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/SZnwP5Guu4RraxBI6l6nFg\">常见的SQL面试题：经典50例</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/NbZnNOZTUZaavEAKD-CSYw\">一文搞定关系数据库设计要领，值得收藏！</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/hd7-IjhRW5DyWZi9MdEG0w\">常用数据库SQL命令详解（上）</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/gidYvMFQGM8VaiQkP_9IjQ\">常用数据库SQL命令详解（下）</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/jhej5m8qs0isEzJC-SpLfA\">输入SQL到返回数据，到底发生了什么？</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/M9PmFMmXToJOMyzVWj0Z5g\">一条SQL查询语句是如何执行的？</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/Xu_SfM-DzKarybGpspwIHA\">数据库主键一定要自增吗？有哪些场景不建议自增？</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/2ea_no_oonNb58OqInRn5g\">慢SQL，压垮团队的最后一根稻草</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/03lD4P0rE909Kkvm_7vLNg\">聊聊数据库建表的15个小技巧</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/FPdl_-jqgeIXSGOh-MQNFQ\">百亿级数据分库分表后怎么分页查询？</a></li>\n</ul>\n","categories":[{"name":"数据库","path":"api/categories/数据库.json"}],"tags":[]}