{"title":"编写JavaScript代码的小技巧","slug":"编写JavaScript代码的小技巧","date":"2023-05-17T05:54:40.434Z","updated":"2023-05-18T02:05:54.647Z","comments":true,"path":"api/articles/编写JavaScript代码的小技巧.json","excerpt":null,"covers":"https://pic1.zhimg.com/v2-6ef93db4040b0eb0b4524d06e372ad0f.jpg","content":"\r\n\r\n### 生成随机颜色/随机数/Boolean值\r\n\r\n```js\r\n// 生成随机颜色\r\nconst generateRandomHexColor = () => Math.floor(Math.random() * 0xffffff).toString(16)\r\nconsole.log(generateRandomHexColor())\r\n\r\n// 获取随机颜色\r\n// 日常我们经常会需要获取一个随机颜色，通过随机数即可完成\r\nfunction getRandomColor(){\r\n    return `#${Math.floor(Math.random() * 0xffffff) .toString(16)}`;\r\n}\r\n\r\n// 带有范围的随机数生成器\r\nfunction randomNumber(max = 1, min = 0) {\r\n  if (min >= max) {\r\n    return max;\r\n  }\r\n  return Math.floor(Math.random() * (max - min) + min);\r\n}\r\n\r\n// 随机ID生成器\r\n// create unique id starting from current time in milliseconds\r\n// incrementing it by 1 everytime requested\r\nconst uniqueId = (() => {\r\n  const id = (function* () {\r\n    let mil = new Date().getTime();\r\n\r\n    while (true) yield (mil += 1);\r\n  })();\r\n\r\n  return () => id.next().value;\r\n})();\r\n// create unique incrementing id starting from provided value or zero\r\n// good for temporary things or things that id resets\r\nconst uniqueIncrementingId = ((lastId = 0) => {\r\n  const id = (function* () {\r\n    let numb = lastId;\r\n\r\n    while (true) yield (numb += 1);\r\n  })();\r\n\r\n  return (length = 12) => `${id.next().value}`.padStart(length, \"0\");\r\n})();\r\n// create unique id from letters and numbers\r\nconst uniqueAlphaNumericId = (() => {\r\n  const heyStack = \"0123456789abcdefghijklmnopqrstuvwxyz\";\r\n  const randomInt = () =>\r\n    Math.floor(Math.random() * Math.floor(heyStack.length));\r\n\r\n  return (length = 24) =>\r\n    Array.from({ length }, () => heyStack[randomInt()]).join(\"\");\r\n})();\r\n\r\n// 创建一个范围内的数字\r\nfunction range(maxOrStart, end = null, step = null) {\r\n  if (!end) {\r\n    return Array.from({ length: maxOrStart }, (_, i) => i);\r\n  }\r\n  if (end <= maxOrStart) {\r\n    return [];\r\n  }\r\n  if (step !== null) {\r\n    return Array.from(\r\n      { length: Math.ceil((end - maxOrStart) / step) },\r\n      (_, i) => i * step + maxOrStart\r\n    );\r\n  }\r\n  return Array.from(\r\n    { length: Math.ceil(end - maxOrStart) },\r\n    (_, i) => i + maxOrStart\r\n  );\r\n}\r\n\r\n// 随机获取一个Boolean值\r\n// 通过随机数获取，Math.random()的区间是0-0.99，用0.5在中间百分之五十的概率\r\nfunction randomBool() {\r\n    return 0.5 - Math.random()\r\n}\r\n\r\n// uuid\r\nexport const uuid = () => {\r\n    const temp_url = URL.createObjectURL(new Blob())\r\n    const uuid = temp_url.toString()\r\n    URL.revokeObjectURL(temp_url) //释放这个url\r\n    return uuid.substring(uuid.lastIndexOf('/') + 1)\r\n}\r\n// 示例：\r\nuuid() // a640be34-689f-4b98-be77-e3972f9bffdd\r\n\r\n/**\r\n * 生成随机数\r\n * @param {*} min \r\n * @param {*} max \r\n */\r\n\r\nfunction randomNum(min, max) {\r\n  switch (arguments.length) {\r\n    case 1:\r\n      return parseInt(Math.random() * min + 1, 10);\r\n    case 2:\r\n      return parseInt(Math.random() * (max - min + 1) + min, 10);\r\n    default:\r\n      return 0;\r\n  }\r\n}\r\nrandomNum(1,10)\r\n```\r\n\r\n### 其他操作\r\n\r\n```js\r\n// 复制到剪切板\r\nconst copyToClipboard = (text) => navigator.clipboard && navigator.clipboard.writeText && navigator.clipboard.writeText(text)\r\ncopyToClipboard(\"Hello World!\")\r\n\r\n// 将下标转为中文零一二三...\r\n// 日常可能有的列表我们需要将对应的012345转为中文的一、二、三、四、五...，在老的项目看到还有通过自己手动定义很多行这样的写法，于是写了一个这样的方法转换\r\nexport function transfromNumber(number){\r\n  const  INDEX_MAP = ['零'，'一'.....]\r\n  if(!number) return\r\n  if(number === 10) return INDEX_MAP[number]\r\n  return [...number.toString()].reduce( (pre, cur) => pre  + INDEX_MAP[cur] , '' )\r\n}\r\n\r\n// Boolean转换\r\n// 一些场景下我们会将boolean值定义为场景，但是在js中非空的字符串都会被认为是true\r\nfunction toBoolean(value, truthyValues = ['true']){\r\n  const normalizedValue = String(value).toLowerCase().trim();\r\n  return truthyValues.includes(normalizedValue);\r\n}\r\ntoBoolean('TRUE'); // true\r\ntoBoolean('FALSE'); // false\r\ntoBoolean('YES', ['yes']); // true\r\n\r\n// 计算两个坐标之间的距离\r\nfunction distance(p1, p2){\r\n    return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));\r\n}\r\n\r\n// 获取列表最后一项\r\nfunction lastItem(list) {\r\n  if (Array.isArray(list)) {\r\n    return list.slice(-1)[0];\r\n  }\r\n  if (list instanceof Set) {\r\n    return Array.from(list).slice(-1)[0];\r\n  }\r\n  if (list instanceof Map) {\r\n    return Array.from(list.values()).slice(-1)[0];\r\n  }\r\n}\r\n\r\n// 格式化JSON字符串，stringify任何内容\r\nconst stringify = (() => {\r\n  const replacer = (key, val) => {\r\n    if (typeof val === \"symbol\") {\r\n      return val.toString();\r\n    }\r\n    if (val instanceof Set) {\r\n      return Array.from(val);\r\n    }\r\n    if (val instanceof Map) {\r\n      return Array.from(val.entries());\r\n    }\r\n    if (typeof val === \"function\") {\r\n      return val.toString();\r\n    }\r\n    return val;\r\n  };\r\n\r\n  return (obj, spaces = 0) => JSON.stringify(obj, replacer, spaces);\r\n})();\r\n\r\n// 轮询数据\r\nasync function poll(fn, validate, interval = 2500) {\r\n  const resolver = async (resolve, reject) => {\r\n    try {\r\n      // catch any error thrown by the \"fn\" function\r\n      const result = await fn(); // fn does not need to be asynchronous or return promise\r\n      // call validator to see if the data is at the state to stop the polling\r\n      const valid = validate(result);\r\n      if (valid === true) {\r\n        resolve(result);\r\n      } else if (valid === false) {\r\n        setTimeout(resolver, interval, resolve, reject);\r\n      } // if validator returns anything other than \"true\" or \"false\" it stops polling\r\n    } catch (e) {\r\n      reject(e);\r\n    }\r\n  };\r\n  return new Promise(resolver);\r\n}\r\n\r\n// 使用别名和默认值来销毁\r\nfunction demo1({ dt: data }) {\r\n  // rename \"dt\" to \"data\"\r\n  console.log(data); // prints {name: 'sample', id: 50}\r\n}\r\nfunction demo2({ dt: { name, id = 10 } }) {\r\n  // deep destruct \"dt\" and if no \"id\" use 10 as default\r\n  console.log(name, id); // prints 'sample', '10'\r\n}\r\ndemo1({\r\n  dt: { name: \"sample\", id: 50 },\r\n});\r\n\r\ndemo2({\r\n  dt: { name: \"sample\" },\r\n});\r\n\r\n// 循环任何内容\r\nfunction forEach(list, callback) {\r\n  const entries = Object.entries(list);\r\n  let i = 0;\r\n  const len = entries.length;\r\n\r\n  for (; i < len; i++) {\r\n    const res = callback(entries[i][1], entries[i][0], list);\r\n    if (res === true) break;\r\n  }\r\n}\r\n\r\n// 使函数参数为required\r\nfunction required(argName = \"param\") {\r\n  throw new Error(`\"${argName}\" is required`);\r\n}\r\nfunction iHaveRequiredOptions(arg1 = required(\"arg1\"), arg2 = 10) {\r\n  console.log(arg1, arg2);\r\n}\r\niHaveRequiredOptions(); // throws \"arg1\" is required\r\niHaveRequiredOptions(12); // prints 12, 10\r\niHaveRequiredOptions(12, 24); // prints 12, 24\r\niHaveRequiredOptions(undefined, 24); // throws \"arg1\" is required\r\n\r\n// Replace All\r\nvar example = \"potato potato\";\r\nconsole.log(example.replace(/pot/, \"tom\"));// \"tomato potato\"\r\nconsole.log(example.replace(/pot/g, \"tom\"));// \"tomato tomato\"\r\n\r\n// 防抖\r\nexport const debounce = (() => {\r\n    let timer = null\r\n    return (callback, wait = 800) => {\r\n        timer&&clearTimeout(timer)\r\n        timer = setTimeout(callback, wait)\r\n    }\r\n})()\r\n// 示例：如vue中使用\r\nmethods: {\r\n    loadList() {\r\n        debounce(() => {\r\n            console.log('加载数据')\r\n        }, 500)\r\n    }\r\n}\r\n\r\n// 节流\r\nexport const throttle = (() => {\r\n    let last = 0\r\n    return (callback, wait = 800) => {\r\n        let now = +new Date()\r\n        if (now - last > wait) {\r\n            callback()\r\n            last = now\r\n        }\r\n    }\r\n})()\r\n\r\n// 手机号脱敏\r\nexport const hideMobile = (mobile) => {\r\n  return mobile.replace(/^(\\d{3})\\d{4}(\\d{4})$/, \"$1****$2\")\r\n}\r\n// 大小写转换\r\n// 参数：str:待转换的字符串 type:1-全大写 2-全小写 3-首字母大写\r\nexport const turnCase = (str, type) => {\r\n    switch (type) {\r\n        case 1:\r\n            return str.toUpperCase()\r\n        case 2:\r\n            return str.toLowerCase()\r\n        case 3:\r\n            //return str[0].toUpperCase() + str.substr(1).toLowerCase() // substr 已不推荐使用\r\n            return str[0].toUpperCase() + str.substring(1).toLowerCase()\r\n        default:\r\n            return str\r\n    }\r\n}\r\n// 示例：\r\nturnCase('vue', 1) // VUE\r\nturnCase('REACT', 2) // react\r\nturnCase('vue', 3) // Vue\r\n\r\n// 金额格式化\r\n/*参数：\r\n{number} number：要格式化的数字\r\n{number} decimals：保留几位小数\r\n{string} dec_point：小数点符号\r\n{string} thousands_sep：千分位符号\r\n*/\r\nexport const moneyFormat = (number, decimals, dec_point, thousands_sep) => {\r\n    number = (number + '').replace(/[^0-9+-Ee.]/g, '')\r\n    const n = !isFinite(+number) ? 0 : +number\r\n    const prec = !isFinite(+decimals) ? 2 : Math.abs(decimals)\r\n    const sep = typeof thousands_sep === 'undefined' ? ',' : thousands_sep\r\n    const dec = typeof dec_point === 'undefined' ? '.' : dec_point\r\n    let s = ''\r\n    const toFixedFix = function(n, prec) {\r\n        const k = Math.pow(10, prec)\r\n        return '' + Math.ceil(n * k) / k\r\n    }\r\n    s = (prec ? toFixedFix(n, prec) : '' + Math.round(n)).split('.')\r\n    const re = /(-?\\d+)(\\d{3})/\r\n    while (re.test(s[0])) {\r\n        s[0] = s[0].replace(re, '$1' + sep + '$2')\r\n    }\r\n\r\n    if ((s[1] || '').length < prec) {\r\n        s[1] = s[1] || ''\r\n        s[1] += new Array(prec - s[1].length + 1).join('0')\r\n    }\r\n    return s.join(dec)\r\n}\r\n// 示例：\r\nmoneyFormat(10000000) // 10,000,000.00\r\nmoneyFormat(10000000, 3, '.', '-') // 10-000-000.000\r\n\r\n// 存储操作\r\nclass MyCache {\r\n    constructor(isLocal = true) {\r\n        this.storage = isLocal ? localStorage : sessionStorage\r\n    }\r\n    setItem(key, value) {\r\n        if (typeof (value) === 'object') value = JSON.stringify(value)\r\n        this.storage.setItem(key, value)\r\n    }\r\n    getItem(key) {\r\n        try {\r\n            return JSON.parse(this.storage.getItem(key))\r\n        } catch (err) {\r\n            return this.storage.getItem(key)\r\n        }\r\n    }\r\n    removeItem(key) {\r\n        this.storage.removeItem(key)\r\n    }\r\n    clear() {\r\n        this.storage.clear()\r\n    }\r\n    key(index) {\r\n        return this.storage.key(index)\r\n    }\r\n    length() {\r\n        return this.storage.length\r\n    }\r\n}\r\nconst localCache = new MyCache()\r\nconst sessionCache = new MyCache(false)\r\nexport { localCache, sessionCache }\r\n// 示例：\r\nlocalCache.getItem('user')\r\nsessionCache.setItem('name','树哥')\r\nsessionCache.getItem('token')\r\nlocalCache.clear()\r\n\r\n// 下载文件\r\n/*参数：\r\napi 接口\r\nparams 请求参数\r\nfileName 文件名\r\n*/\r\nconst downloadFile = (api, params, fileName, type = 'get') => {\r\n    axios({\r\n        method: type,\r\n        url: api,\r\n        responseType: 'blob', \r\n        params: params\r\n    }).then((res) => {\r\n        let str = res.headers['content-disposition']\r\n        if (!res || !str) {\r\n            return\r\n        }\r\n        let suffix = ''\r\n        // 截取文件名和文件类型\r\n        if (str.lastIndexOf('.')) {\r\n            fileName ? '' : fileName = decodeURI(str.substring(str.indexOf('=') + 1, str.lastIndexOf('.')))\r\n            suffix = str.substring(str.lastIndexOf('.'), str.length)\r\n        }\r\n        //  如果支持微软的文件下载方式(ie10+浏览器)\r\n        if (window.navigator.msSaveBlob) {\r\n            try {\r\n                const blobObject = new Blob([res.data]);\r\n                window.navigator.msSaveBlob(blobObject, fileName + suffix);\r\n            } catch (e) {\r\n                console.log(e);\r\n            }\r\n        } else {\r\n            //  其他浏览器\r\n            let url = window.URL.createObjectURL(res.data)\r\n            let link = document.createElement('a')\r\n            link.style.display = 'none'\r\n            link.href = url\r\n            link.setAttribute('download', fileName + suffix)\r\n            document.body.appendChild(link)\r\n            link.click()\r\n            document.body.removeChild(link)\r\n            window.URL.revokeObjectURL(link.href);\r\n        }\r\n    }).catch((err) => {\r\n        console.log(err.message);\r\n    })\r\n}\r\n\r\n// 使用：\r\ndownloadFile('/api/download', {id}, '文件名')\r\n```\r\n\r\n### 滚动到顶部/底部\r\n\r\n```js\r\n// 滚动到页面顶部\r\nexport const scrollToTop = () => {\r\n    const height = document.documentElement.scrollTop || document.body.scrollTop;\r\n    if (height > 0) {\r\n        window.requestAnimationFrame(scrollToTop);\r\n        window.scrollTo(0, height - height / 8);\r\n    }\r\n}\r\n// 滚动到元素位置\r\nexport const smoothScroll = element =>{\r\n    document.querySelector(element).scrollIntoView({\r\n        behavior: 'smooth'\r\n    });\r\n};\r\n// 示例：\r\nsmoothScroll('#target'); // 平滑滚动到ID为target 的元素\r\n\r\n// 滚动到顶部。将元素滚动到顶部最简单的方法是使用scrollIntoView。设置block为start可以滚动到顶部；设置behavior为smooth可以开启平滑滚动。\r\nconst scrollToTop = (element) => element.scrollIntoView({ behavior: \"smooth\", block: \"start\" });\r\n\r\n// 滚动到底部。与滚动到顶部一样，滚动到底部只需要设置block为end即可。\r\nconst scrollToBottom = (element) =>  element.scrollIntoView({ behavior: \"smooth\", block: \"end\" });\r\n\r\n// dom节点平滑滚动到可视区域，顶部，底部。原生的scrollTo方法没有动画，类似于锚点跳转，比较生硬，可以通过这个方法会自带平滑的过度效果\r\nfunction scrollTo(element) {\r\n    element.scrollIntoView({ behavior: \"smooth\", block: \"start\" }) // 顶部\r\n    element.scrollIntoView({ behavior: \"smooth\", block: \"end\" }) // 底部\r\n    element.scrollIntoView({ behavior: \"smooth\"}) // 可视区域\r\n}\r\n\r\n/**\r\n * 获取滚动条位置⬇\r\n */ \r\nfunction getScrollPosition(el = window) {\r\n  return {\r\n    x: el.pageXOffset !== undefined ? el.pageXOffset : el.scrollLeft,\r\n    y: el.pageYOffset !== undefined ? el.pageYOffset : el.scrollTop,\r\n  };\r\n}\r\n\r\n/**\r\n * 固定滚动条\r\n * 功能描述：一些业务场景，如弹框出现时，需要禁止页面滚动，这是兼容安卓和iOS禁止页面滚动的解决方案\r\n */\r\nlet scrollTop = 0;\r\n\r\nfunction preventScroll() {\r\n  // 存储当前滚动位置\r\n  scrollTop = window.scrollY;\r\n\r\n  // 将可滚动区域固定定位，可滚动区域高度为0后就不能滚动了\r\n  document.body.style[\"overflow-y\"] = \"hidden\";\r\n  document.body.style.position = \"fixed\";\r\n  document.body.style.width = \"100%\";\r\n  document.body.style.top = -scrollTop + \"px\";\r\n  // document.body.style['overscroll-behavior'] = 'none'\r\n}\r\n\r\nfunction recoverScroll() {\r\n  document.body.style[\"overflow-y\"] = \"auto\";\r\n  document.body.style.position = \"static\";\r\n  // document.querySelector('body').style['overscroll-behavior'] = 'none'\r\n\r\n  window.scrollTo(0, scrollTop);\r\n}\r\n\r\n/**\r\n * 滚动条回到顶部动画⬇\r\n */ \r\n// 方案一： c - c / 8\r\n// c没有定义\r\nfunction scrollToTop() {\r\n  const scrollTop =\r\n    document.documentElement.scrollTop || document.body.scrollTop;\r\n  if (scrollTop > 0) {\r\n    window.requestAnimationFrame(scrollToTop);\r\n    window.scrollTo(0, c - c / 8);\r\n  } else {\r\n    window.cancelAnimationFrame(scrollToTop);\r\n  }\r\n}\r\nscrollToTop();\r\n\r\n// 修正之后\r\nfunction scrollToTop() {\r\n  const scrollTop =\r\n    document.documentElement.scrollTop || document.body.scrollTop;\r\n  if (scrollTop > 0) {\r\n    window.requestAnimationFrame(scrollToTop);\r\n    window.scrollTo(0, scrollTop - scrollTop / 8);\r\n  } else {\r\n    window.cancelAnimationFrame(scrollToTop);\r\n  }\r\n}\r\nscrollToTop();\r\n\r\n// 模糊搜索\r\n/*\r\n * list 原数组\r\n * keyWord 查询的关键词\r\n * attribute 数组需要检索属性\r\n **/\r\nexport const fuzzyQuery = (list, keyWord, attribute = 'name') => {\r\n    const reg = new RegExp(keyWord)\r\n    const arr = []\r\n    for (let i = 0; i < list.length; i++) {\r\n        if (reg.test(list[i][attribute])) {\r\n            arr.push(list[i])\r\n        }\r\n    }\r\n    return arr\r\n}\r\n// 示例：\r\nconst list = [\r\n    { id: 1, name: '树哥' },\r\n    { id: 2, name: '黄老爷' },\r\n    { id: 3, name: '张麻子' },\r\n    { id: 4, name: '汤师爷' },\r\n    { id: 5, name: '胡万' },\r\n    { id: 6, name: '花姐' },\r\n    { id: 7, name: '小梅' }\r\n]\r\nfuzzyQuery(list, '树', 'name') // [{id: 1, name: '树哥'}]\r\n\r\n// 遍历树节点\r\nexport const foreachTree = (data, callback, childrenName = 'children') => {\r\n    for (let i = 0; i < data.length; i++) {\r\n        callback(data[i])\r\n        if (data[i][childrenName] && data[i][childrenName].length > 0) {\r\n            foreachTree(data[i][childrenName], callback, childrenName)\r\n        }\r\n    }\r\n}\r\n// 示例：假设我们要从树状结构数据中查找id为9的节点\r\nconst treeData = [{\r\n    id: 1,\r\n    label: '一级 1',\r\n    children: [{\r\n        id: 4,\r\n        label: '二级 1-1',\r\n        children: [{\r\n            id: 9,\r\n            label: '三级 1-1-1'\r\n        }, {\r\n            id: 10,\r\n            label: '三级 1-1-2'\r\n        }]\r\n    }]\r\n}, {\r\n    id: 2,\r\n    label: '一级 2',\r\n    children: [{\r\n        id: 5,\r\n        label: '二级 2-1'\r\n    }, {\r\n        id: 6,\r\n        label: '二级 2-2'\r\n    }]\r\n}, {\r\n    id: 3,\r\n    label: '一级 3',\r\n    children: [{\r\n        id: 7,\r\n        label: '二级 3-1'\r\n    }, {\r\n        id: 8,\r\n        label: '二级 3-2'\r\n    }]\r\n}],\r\nlet result = foreachTree(data, (item) => {\r\n          if (item.id === 9) {\r\n              result = item\r\n          }\r\n      })\r\nconsole.log('result', result)  // {id: 9,label: \"三级 1-1-1\"}   \r\n\r\n/**\r\n * 返回当前网页地址⬇\r\n */ \r\n// 方案一：location\r\nfunction currentURL() {\r\n  return window.location.href;\r\n}\r\ncurrentURL();\r\n\r\n// 方案二：a 标签\r\nfunction currentURL() {\r\n  var el = document.createElement(\"a\");\r\n  el.href = \"\";\r\n  return el.href;\r\n}\r\ncurrentURL();\r\n\r\n\r\n/**\r\n * 页面跳转，是否记录在history中⬇\r\n */ \r\n// 方案一：\r\nfunction redirect(url, asLink = true) {\r\n  asLink ? (window.location.href = url) : window.location.replace(url);\r\n}\r\n// 方案二：\r\nfunction redirect(url, asLink = true) {\r\n  asLink ? window.location.assign(url) : window.location.replace(url);\r\n}\r\n\r\n\r\n/**\r\n * 复制文本⬇\r\n */ \r\n// 方案一：\r\nfunction copy(str) {\r\n  const el = document.createElement(\"textarea\");\r\n  el.value = str;\r\n  el.setAttribute(\"readonly\", \"\");\r\n  el.style.position = \"absolute\";\r\n  el.style.left = \"-9999px\";\r\n  el.style.top = \"-9999px\";\r\n  document.body.appendChild(el);\r\n  const selected =\r\n    document.getSelection().rangeCount > 0\r\n      ? document.getSelection().getRangeAt(0)\r\n      : false;\r\n  el.select();\r\n  document.execCommand(\"copy\");\r\n  document.body.removeChild(el);\r\n  if (selected) {\r\n    document.getSelection().removeAllRanges();\r\n    document.getSelection().addRange(selected);\r\n  }\r\n}\r\n// 方案二：cliboard.js\r\n```\r\n\r\n### 判断操作\r\n```js\r\n/**\r\n * 判断当前位置是否为页面底部\r\n * 返回值为true/false\r\n */\r\nfunction bottomVisible() {\r\n  return (\r\n    document.documentElement.clientHeight + window.scrollY >=\r\n    (document.documentElement.scrollHeight ||\r\n      document.documentElement.clientHeight)\r\n  );\r\n}\r\n\r\n/**\r\n * 判断元素是否在可视范围内\r\n * partiallyVisible为是否为完全可见\r\n */\r\nfunction elementIsVisibleInViewport(el, partiallyVisible = false) {\r\n  const { top, left, bottom, right } = el.getBoundingClientRect();\r\n\r\n  return partiallyVisible\r\n    ? ((top > 0 && top < innerHeight) ||\r\n        (bottom > 0 && bottom < innerHeight)) &&\r\n        ((left > 0 && left < innerWidth) || (right > 0 && right < innerWidth))\r\n    : top >= 0 && left >= 0 && bottom <= innerHeight && right <= innerWidth;\r\n}\r\n\r\n// 判断一个参数是不是函数\r\n// 有时候我们的方法需要传入一个函数回调，但是需要检测其类型，我们可以通过Object的原型方法去检测，当然这个方法可以准确检测任何类型。\r\nfunction isFunction(v){\r\n   return ['[object Function]', '[object GeneratorFunction]', '[object AsyncFunction]', '[object Promise]'].includes(Object.prototype.toString.call(v));\r\n}\r\n\r\n// 判断是否是NodeJs环境\r\n// 前端的日常开发是离不开nodeJs的，通过判断全局环境来检测是否是nodeJs环境\r\nfunction isNode(){\r\n    return typeof process !== 'undefined' && process.versions != null && process.versions.node != null;\r\n}\r\n\r\n// 判断手机是Andoird还是IOS\r\n/** \r\n * 1: ios\r\n * 2: android\r\n * 3: 其它\r\n */\r\nexport const getOSType=() => {\r\n    let u = navigator.userAgent, app = navigator.appVersion;\r\n    let isAndroid = u.indexOf('Android') > -1 || u.indexOf('Linux') > -1;\r\n    let isIOS = !!u.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/);\r\n    if (isIOS) {\r\n        return 1;\r\n    }\r\n    if (isAndroid) {\r\n        return 2;\r\n    }\r\n    return 3;\r\n}\r\n```\r\n### 检查/检测操作\r\n```js\r\n// 检测元素是否在屏幕中\r\n// 最好的方法是使用IntersectionObserver。\r\nconst callback = (entries) => {\r\n  entries.forEach((entry) => {\r\n    if (entry.isIntersecting) {\r\n      // `entry.target` is the dom element\r\n      console.log(`${entry.target.id} is visible`);\r\n    }\r\n  });\r\n};\r\n\r\nconst options = {\r\n  threshold: 1.0,\r\n};\r\nconst observer = new IntersectionObserver(callback, options);\r\nconst btn = document.getElementById(\"btn\");\r\nconst bottomBtn = document.getElementById(\"bottom-btn\");\r\nobserver.observe(btn);\r\nobserver.observe(bottomBtn);\r\n\r\n// 检测设备\r\n// 使用navigator.userAgent来检测网站运行在哪种平台设备上。\r\nconst detectDeviceType = () =>\r\n  /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(\r\n    navigator.userAgent\r\n  ) ? \"Mobile\" : \"Desktop\";\r\nconsole.log(detectDeviceType());\r\n\r\n// 检测暗色主题\r\nconst isDarkMode = () => window.matchMedia && window.matchMedia(\"(prefers-color-scheme: dark)\").matches;\r\nconsole.log(isDarkMode())\r\n\r\n// 多个字符串检查\r\n// 通常，如果我们需要检查字符串是否等于多个值中的一个，往往很快会觉得疲惫不堪。幸运的是，JavaScript有一个内置的方法来帮助你解决这个问题\r\n// 普通写法\r\nconst isVowel = (letter) => {\r\n  if (\r\n    letter === \"a\" ||\r\n    letter === \"e\" ||\r\n    letter === \"i\" ||\r\n    letter === \"o\" ||\r\n    letter === \"u\"\r\n  ) {\r\n    return true;\r\n  }\r\n  return false;\r\n};\r\n// 简写方法\r\nconst isVowel = (letter) =>\r\n  [\"a\", \"e\", \"i\", \"o\", \"u\"].includes(letter);\r\n\r\n// 类型检查小工具\r\nconst isOfType = (() => {\r\n  // create a plain object with no prototype\r\n  const type = Object.create(null);\r\n  // check for null type\r\n  type.null = (x) => x === null;\r\n  // check for undefined type\r\n  type.undefined = (x) => x === undefined;\r\n  // check for nil type. Either null or undefined\r\n  type.nil = (x) => type.null(x) || type.undefined(x);\r\n  // check for strings and string literal type. e.g: 's', \"s\", `str`, new String()\r\n  type.string = (x) => !type.nil(x) && (typeof x === \"string\" || x instanceof String);\r\n  // check for number or number literal type. e.g: 12, 30.5, new Number()\r\n  type.number = (x) =>\r\n!type.nil(x) && // NaN & Infinity have typeof \"number\" and this excludes that\r\n    ((!isNaN(x) && isFinite(x) && typeof x === \"number\") ||\r\n      x instanceof Number);\r\n  // check for boolean or boolean literal type. e.g: true, false, new Boolean()\r\n  type.boolean = (x) =>\r\n    !type.nil(x) && (typeof x === \"boolean\" || x instanceof Boolean);\r\n  // check for array type\r\n  type.array = (x) => !type.nil(x) && Array.isArray(x);\r\n  // check for object or object literal type. e.g: {}, new Object(), Object.create(null)\r\n  type.object = (x) => ({}.toString.call(x) === \"[object Object]\");\r\n  // check for provided type instance\r\n  type.type = (x, X) => !type.nil(x) && x instanceof X;\r\n  // check for set type\r\n  type.set = (x) => type.type(x, Set);\r\n  // check for map type\r\n  type.map = (x) => type.type(x, Map);\r\n  // check for date type\r\n  type.date = (x) => type.type(x, Date);\r\n\r\n  return type;\r\n})();\r\n\r\n// 检查是否为空\r\nfunction isEmpty(x) {\r\n  if (Array.isArray(x) || typeof x === \"string\" || x instanceof String) {\r\n    return x.length === 0;\r\n  }\r\n  if (x instanceof Map || x instanceof Set) {\r\n    return x.size === 0;\r\n  }\r\n  if ({}.toString.call(x) === \"[object Object]\") {\r\n    return Object.keys(x).length === 0;\r\n  }\r\n  return false;\r\n}\r\n\r\n// 检测是否为空对象\r\n// 通过使用ES6的Reflect静态方法判断他的长度就可以判断是否是空数组了，也可以通过Object.keys()来判断\r\nfunction isEmpty(obj){\r\n    return  Reflect.ownKeys(obj).length === 0 && obj.constructor === Object;\r\n}\r\n\r\n// 检测两个dom节点是否覆盖重叠\r\n// 有些场景下我们需要判断dom是否发生碰撞了或者重叠了，我们可以通过getBoundingClientRect获取到dom的x1,y1,x2,y2坐标然后进行坐标比对即可判断出来\r\nfunction overlaps = (a, b) {\r\n   return (a.x1 < b.x2 && b.x1 < a.x2) || (a.y1 < b.y2 && b.y1 < a.y2);\r\n}\r\n\r\n/**\r\n * 检测设备类型⬇\r\n */ \r\n// 方案一： ua\r\nfunction detectDeviceType() {\r\n  return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(\r\n    navigator.userAgent\r\n  )\r\n    ? \"Mobile\"\r\n    : \"Desktop\";\r\n}\r\ndetectDeviceType();\r\n\r\n// 方案二：事件属性\r\nfunction detectDeviceType() {\r\n  return \"ontouchstart\" in window || navigator.msMaxTouchPoints\r\n    ? \"Mobile\"\r\n    : \"Desktop\";\r\n}\r\ndetectDeviceType();\r\n\r\n// Falsey（假值）检查\r\n// 如果要检查变量是null、undefined、0、false、NaN还是空string，可以使用逻辑非(!)运算符一次检查所有变量，而无需编写多个条件。这使得检查变量是否包含有效数据变得相对容易多了。\r\n// 普通写法\r\nconst isFalsey = (value) => {\r\n  if (\r\n    value === null ||\r\n    value === undefined ||\r\n    value === 0 ||\r\n    value === false ||\r\n    value === NaN ||\r\n    value === \"\"\r\n  ) {\r\n    return true;\r\n  }\r\n  return false;\r\n};\r\n// 简写方法\r\nconst isFalsey = (value) => !value;\r\n```\r\n\r\n### 从URL中获取参数\r\n\r\n```js\r\n// JavaScript中有一个URL对象，通过它可以非常方便的获取URL中的参数。\r\nconst getParamByUrl = (key) => {\r\n  const url = new URL(location.href)\r\n  return url.searchParams.get(key)\r\n}\r\n\r\nexport const getSearchParams = () => {\r\n    const searchPar = new URLSearchParams(window.location.search)\r\n    const paramsObj = {}\r\n    for (const [key, value] of searchPar.entries()) {\r\n        paramsObj[key] = value\r\n    }\r\n    return paramsObj\r\n}\r\n// 示例：\r\n// 假设目前位于 https://****com/index?id=154513&age=18;\r\ngetSearchParams(); // {id: \"154513\", age: \"18\"}\r\n\r\n/**\r\n * 获取url中的参数⬇\r\n */ \r\n// 方案一：正则 + reduce\r\nfunction getURLParameters(url) {\r\n  return url.match(/([^?=&]+)(=([^&]*))/g).reduce((a, v) => (\r\n        (a[v.slice(0, v.indexOf(\"=\"))] = v.slice(v.indexOf(\"=\") + 1)), a\r\n      ),{}\r\n    );\r\n}\r\ngetURLParameters(location.href);\r\n\r\n// 方案二：split + reduce\r\nfunction getURLParameters(url) {\r\n  return url\r\n    .split(\"?\") //取？分割\r\n    .slice(1) //不要第一部分\r\n    .join() //拼接\r\n    .split(\"&\") //&分割\r\n    .map((v) => v.split(\"=\")) //=分割\r\n    .reduce((s, n) => {\r\n      s[n[0]] = n[1];\r\n      return s;\r\n    }, {});\r\n}\r\ngetURLParameters(location.href);\r\n// getURLParameters('')\r\n\r\n// 方案三: URLSearchParams\r\n```\r\n### 对象操作\r\n\r\n```js\r\n// 深拷贝对象\r\n// 深拷贝对象非常简单，先将对象转换为字符串，再转换成对象即可。\r\nconst deepCopy = obj => JSON.parse(JSON.stringify(obj))\r\n// 除了利用JSON的API，还有更新的深拷贝对象的structuredClone API，但并不是在所有的浏览器中都支持。\r\nstructuredClone(obj)\r\n\r\n// 深拷贝\r\nexport const clone = parent => {\r\n    // 判断类型\r\n    const isType = (obj, type) => {\r\n        if (typeof obj !== \"object\") return false;\r\n        const typeString = Object.prototype.toString.call(obj);\r\n        let flag;\r\n        switch (type) {\r\n            case \"Array\":\r\n                flag = typeString === \"[object Array]\";\r\n                break;\r\n            case \"Date\":\r\n                flag = typeString === \"[object Date]\";\r\n                break;\r\n            case \"RegExp\":\r\n                flag = typeString === \"[object RegExp]\";\r\n                break;\r\n            default:\r\n                flag = false;\r\n        }\r\n        return flag;\r\n    };\r\n    // 处理正则\r\n    const getRegExp = re => {\r\n        var flags = \"\";\r\n        if (re.global) flags += \"g\";\r\n        if (re.ignoreCase) flags += \"i\";\r\n        if (re.multiline) flags += \"m\";\r\n        return flags;\r\n    };\r\n    // 维护两个储存循环引用的数组\r\n    const parents = [];\r\n    const children = [];\r\n\r\n    const _clone = parent => {\r\n        if (parent === null) return null;\r\n        if (typeof parent !== \"object\") return parent;\r\n\r\n        let child, proto;\r\n\r\n        if (isType(parent, \"Array\")) {\r\n            // 对数组做特殊处理\r\n            child = [];\r\n        } else if (isType(parent, \"RegExp\")) {\r\n            // 对正则对象做特殊处理\r\n            child = new RegExp(parent.source, getRegExp(parent));\r\n            if (parent.lastIndex) child.lastIndex = parent.lastIndex;\r\n        } else if (isType(parent, \"Date\")) {\r\n            // 对Date对象做特殊处理\r\n            child = new Date(parent.getTime());\r\n        } else {\r\n            // 处理对象原型\r\n            proto = Object.getPrototypeOf(parent);\r\n            // 利用Object.create切断原型链\r\n            child = Object.create(proto);\r\n        }\r\n\r\n        // 处理循环引用\r\n        const index = parents.indexOf(parent);\r\n\r\n        if (index != -1) {\r\n            // 如果父数组存在本对象,说明之前已经被引用过,直接返回此对象\r\n            return children[index];\r\n        }\r\n        parents.push(parent);\r\n        children.push(child);\r\n\r\n        for (let i in parent) {\r\n            // 递归\r\n            child[i] = _clone(parent[i]);\r\n        }\r\n\r\n        return child;\r\n    };\r\n    return _clone(parent);\r\n};\r\n// 此方法存在一定局限性：一些特殊情况没有处理: 例如Buffer对象、Promise、Set、Map。如果确实想要完备的深拷贝，推荐使用lodash中的cloneDeep方法。\r\n\r\n// 条件对象键\r\nlet condition = true;\r\nconst man = {\r\n  someProperty: \"some value\",\r\n  // the parenthesis will execute the ternary that will\r\n  // result in the object with the property you want to insert\r\n  // or an empty object.then its content is spreaded in the wrapper object\r\n  ...(condition === true ? { newProperty: \"value\" } : {}),\r\n};\r\n\r\n// 使用变量作为对象键\r\nlet property = \"newValidProp\";\r\nconst man2 = {\r\n  someProperty: \"some value\",\r\n  // the \"square bracket\" notation is a valid way to acces object key\r\n  // like object[prop] but it is used inside to assign a property as well\r\n  // using the 'backtick' to first change it into a string\r\n\r\n  // but it is optional\r\n[\"${property}\"]: \"value\",\r\n};\r\n\r\n// 检查对象里的键\r\nconst sample = {\r\n  prop: \"value\",\r\n};\r\n// using the \"in\" keyword will still consider proptotype keys\r\n// which makes it unsafe and one of the issues with \"for...in\" loop\r\nconsole.log(\"prop\" in sample); // prints \"true\"\r\nconsole.log(\"toString\" in sample); // prints \"true\"\r\n// using the \"hasOwnProperty\" methods is safer\r\nconsole.log(sample.hasOwnProperty(\"prop\")); // prints \"true\"\r\nconsole.log(sample.hasOwnProperty(\"toString\")); // prints \"false\"\r\n\r\n// 深度克隆对象\r\nconst deepClone = (obj) => {\r\n  let clone = obj;\r\n  if (obj && typeof obj === \"object\") {\r\n    clone = new obj.constructor();\r\n\r\n    Object.getOwnPropertyNames(obj).forEach(\r\n      (prop) => (clone[prop] = deepClone(obj[prop]))\r\n    );\r\n  }\r\n  return clone;\r\n};\r\n\r\n// 深度冻结对象\r\nconst deepClone2 = (obj) => {\r\n  let clone = obj;\r\n  if (obj && typeof obj === \"object\") {\r\n    clone = new obj.constructor();\r\n\r\n    Object.getOwnPropertyNames(obj).forEach(\r\n      (prop) => (clone[prop] = deepClone(obj[prop]))\r\n    );\r\n  }\r\n  return clone;\r\n};\r\n```\r\n### 语法操作\r\n\r\n```js\r\n// 等待函数\r\n// JavaScript提供了setTimeout函数，但是它并不返回Promise对象，所以我们没办法使用async作用在这个函数上，但是我们可以封装等待函数。\r\nconst wait = (ms) => new Promise((resolve)=> setTimeout(resolve, ms))\r\nconst asyncFn = async () => {\r\n  await wait(1000)\r\n  console.log('等待异步函数执行结束')\r\n}\r\nasyncFn()\r\n\r\n// For-of和For-in循环。For-of和For-in循环是迭代array或object的好方法，因为无需手动跟踪object键的索引。\r\n//For-of\r\nconst arr = [1, 2, 3, 4, 5];\r\n// 普通写法\r\nfor (let i = 0; i < arr.length; i++) {\r\n  const element = arr[i];\r\n  // ...\r\n}\r\n// 简写方法\r\nfor (const element of arr) {\r\n  // ...\r\n}\r\n\r\n// For-in\r\nconst obj = {\r\n  a: 1,\r\n  b: 2,\r\n  c: 3,\r\n};\r\n// 普通写法\r\nconst keys = Object.keys(obj);\r\nfor (let i = 0; i < keys.length; i++) {\r\n  const key = keys[i];\r\n  const value = obj[key];\r\n  // ...\r\n}\r\n// 简写方法\r\nfor (const key in obj) {\r\n  const value = obj[key];\r\n  // ...\r\n}\r\n\r\n// 函数调用\r\n// 在三元运算符的帮助下，你还可以根据条件确定要调用哪个函数。\r\n// 注：函数的call signature必须相同，否则可能会遇到错误。\r\nfunction f1() {\r\n  // ...\r\n}\r\nfunction f2() {\r\n  // ...\r\n}\r\n// 普通写法\r\nif (condition) {\r\n  f1();\r\n} else {\r\n  f2();\r\n}\r\n// 简写方法\r\n(condition ? f1 : f2)();\r\n\r\n// Switch简写\r\n// 通常我们可以使用以键作为switch条件并将值作为返回值的对象来优化长switch语句。\r\nconst dayNumber = new Date().getDay();\r\n// 普通写法\r\nlet day;\r\nswitch (dayNumber) {\r\n  case 0:\r\n    day = \"Sunday\";\r\n    break;\r\n  case 1:\r\n    day = \"Monday\";\r\n    break;\r\n  case 2:\r\n    day = \"Tuesday\";\r\n    break;\r\n  case 3:\r\n    day = \"Wednesday\";\r\n    break;\r\n  case 4:\r\n    day = \"Thursday\";\r\n    break;\r\n  case 5:\r\n    day = \"Friday\";\r\n    break;\r\n  case 6:\r\n    day = \"Saturday\";\r\n}\r\n// 简写方法\r\nconst days = {\r\n  0: \"Sunday\",\r\n  1: \"Monday\",\r\n  2: \"Tuesday\",\r\n  3: \"Wednesday\",\r\n  4: \"Thursday\",\r\n  5: \"Friday\",\r\n  6: \"Saturday\",\r\n};\r\nconst day = days[dayNumber];\r\n\r\n// 回退值\r\n// ||运算符可以为变量设置回退值。\r\n// 普通写法\r\nlet name;\r\nif (user?.name) {\r\n  name = user.name;\r\n} else {\r\n  name = \"Anonymous\";\r\n}\r\n// 简写方法\r\nconst name = user?.name || \"Anonymous\";\r\n\r\n// 结构加赋值\r\nlet people = { name: null, age: null };\r\nlet result = { name: '张三',  age: 16 };\r\n({ name: people.name, age: people.age} = result);\r\nconsole.log(people) // {\"name\":\"张三\",\"age\":16}\r\n\r\n// 对基础数据类型进行解构\r\nconst {length : a} = '1234';\r\nconsole.log(a) // 4\r\n\r\n// 对数组解构快速拿到最后一项值\r\nconst arr = [1, 2, 3];\r\nconst { 0: first, length, [length - 1]: last } = arr;\r\nfirst; // 1\r\nlast; // 3\r\nlength; // 3\r\n\r\n// 创建模块或单例\r\nclass Service {\r\n  name = \"service\";\r\n}\r\nconst service = (function (S) {\r\n  // do something here like preparing data that you can use to initialize service\r\n  const service = new S();\r\n  return () => service;\r\n})(Service);\r\nconst element = (function (S) {\r\n  const element = document.createElement(\"DIV\");\r\n  // do something here to grab somethin on the dom\r\n  // or create elements with javasrcipt setting it all up\r\n  // than to return it\r\n  return () => element;\r\n})();\r\n\r\n// 短路条件\r\n// available && addToCart()代替\r\n// if (available) {\r\n//     addToCart();\r\n// }\r\n\r\n// 动态属性名称\r\nconst dynamic = 'flavour';\r\nvar item = {\r\n    name: 'Coke',\r\n    [dynamic]: 'Cherry'\r\n}\r\nconsole.log(item);// { name: \"Coke\", flavour: \"Cherry\" }\r\n```\r\n\r\n### 数值操作\r\n\r\n```js\r\n// 判断整数的不同方法\r\n/* 1.任何整数都会被1整除，即余数是0。利用这个规则来判断是否是整数。但是对字符串不准确 */\r\nfunction isInteger(obj) {\r\n return obj%1 === 0\r\n}\r\n/* 2. 添加一个是数字的判断 */\r\nfunction isInteger(obj) {\r\n return typeof obj === 'number' && obj%1 === 0\r\n}\r\n/* 3. 使用Math.round、Math.ceil、Math.floor判断整数取整后还是等于自己。利用这个特性来判断是否是整数*/\r\nfunction isInteger(obj) {\r\n return Math.floor(obj) === obj\r\n}\r\n/* 4. 通过parseInt判断 某些场景不准确 */\r\nfunction isInteger(obj) {\r\n return parseInt(obj, 10) === obj\r\n}\r\n/* 5. 通过位运算符*/\r\nfunction isInteger(obj) {\r\n return (obj | 0) === obj\r\n}\r\n\r\n// 参数求和\r\n// 之前看到有通过函数柯理化形式来求和的，通过reduce一行即可\r\nfunction sum(...args){\r\n    args.reduce((a, b) => a + b);\r\n}\r\n\r\n// ----数字Number-----\r\n/**\r\n * 数字千分位分割\r\n * @param {*} num \r\n */\r\nfunction commafy(num) {\r\n  return num.toString().indexOf(\".\") !== -1\r\n    ? num.toLocaleString()\r\n    : num.toString().replace(/(\\d)(?=(?:\\d{3})+$)/g, \"$1,\");\r\n}\r\ncommafy(1000)\r\n\r\n// 将数字转换为字符串\r\nvar converted_number = 5 + \"\";\r\nconsole.log(converted_number);// 5\r\nconsole.log(typeof converted_number);// string\r\n\r\n// 将字符串转换为数字 请注意这里的用法，因为它只适用于“字符串数字”。\r\nvar the_string = \"123\";\r\nconsole.log(+the_string);// 123\r\nthe_string = \"hello\";\r\nconsole.log(+the_string);// NaN\r\n```\r\n\r\n### 时间操作\r\n\r\n关于时间操作，没必要自己再写一大串代码了，强烈推荐使用day.js\r\nDay.js是一个仅2kb大小的轻量级JavaScript时间日期处理库，下载、解析和执行的JavaScript更少，为代码留下更多的时间。\r\n\r\n```js\r\n// 比较两个时间大小,通过调用getTime获取时间戳比较就可以了\r\nfunction compare(a, b){\r\n    return a.getTime() > b.getTime();\r\n}\r\n\r\n// 计算两个时间之间的月份差异\r\nfunction monthDiff(startDate, endDate){\r\n    return  Math.max(0, (endDate.getFullYear() - startDate.getFullYear()) * 12 - startDate.getMonth() + endDate.getMonth());\r\n}\r\n\r\n// 一步从时间中提取年月日时分秒.时间格式化轻松解决，一步获取到年月日时分秒毫秒，由于toISOString会丢失时区，导致时间差八小时，所以在格式化之前我们加上八个小时时间即可\r\nfunction extract(date){\r\n   const d = new Date(new Date(date).getTime() + 8*3600*1000);\r\n  return new Date(d).toISOString().split(/[^0-9]/).slice(0, -1);\r\n}\r\nconsole.log(extract(new Date())) // ['2022', '09', '19', '18', '06', '11', '187']\r\n\r\n// Date\r\n// ---------日期 Date------------\r\n\r\n/**\r\n * 获取当前时间戳⬇\r\n */ \r\n// 方案一：精确到秒\r\nconsole.log(Date.parse(new Date())) \r\n// 方案二：精确到毫秒\r\nconsole.log(Date.now()) \r\n// 方案三：精确到毫秒\r\nconsole.log(+new Date()) \r\n// 方案四：精确到毫秒\r\nconsole.log(new Date().getTime()) \r\n// 方案五：精确到毫秒\r\nconsole.log((new Date()).valueOf())\r\n\r\n/**\r\n * js字符串转时间戳⬇\r\n * mytime是待转换时间字符串，格式：'2018-9-12 9:11:23'\r\n * 为了兼容IOS，需先将字符串转换为'2018/9/11 9:11:23'\r\n */\r\nlet mytime = '2018-9-12 9:11:23';\r\nlet dateTmp = mytime.replace(/-/g, \"/\");\r\nconsole.log(new Date(dateTmp).getTime());\r\nconsole.log(Date.parse(dateTmp));\r\n\r\n/**\r\n * 时间戳转字符串\r\n */ \r\nvar dateFormat = function (timestamp) {\r\n  //先将时间戳转为Date对象，然后才能使用Date的方法\r\n  var time = new Date(timestamp);\r\n  var year = time.getFullYear(),\r\n    month = time.getMonth() + 1, //月份是从0开始的\r\n    day = time.getDate(),\r\n    hour = time.getHours(),\r\n    minute = time.getMinutes(),\r\n    second = time.getSeconds();\r\n  //add0()方法在后面定义\r\n  return (\r\n    year +\r\n    \"-\" +\r\n    this.add0(month) +\r\n    \"-\" +\r\n    this.add0(day) +\r\n    \"\" +\r\n    this.add0(hour) +\r\n    \":\" +\r\n    this.add0(minute) +\r\n    \":\" +\r\n    this.add0(second)\r\n  );\r\n};\r\nvar add0 = function (m) {\r\n  return m < 10 ? \"0\" + m : m;\r\n};\r\n/**\r\n * 格式化字符串\r\n */\r\nDate.prototype.format = function (fmt) { //author: meizz \r\n  var o = {\r\n      \"M+\": this.getMonth() + 1, //月份 \r\n      \"d+\": this.getDate(), //日 \r\n      \"h+\": this.getHours(), //小时 \r\n      \"m+\": this.getMinutes(), //分 \r\n      \"s+\": this.getSeconds(), //秒 \r\n      \"q+\": Math.floor((this.getMonth() + 3) / 3), //季度 \r\n      \"S\": this.getMilliseconds() //毫秒 \r\n  };\r\n  if (/(y+)/.test(fmt)) fmt = fmt.replace(RegExp.$1, (this.getFullYear() + \"\").substr(4 - RegExp.$1.length));\r\n  for (var k in o)\r\n  if (new RegExp(\"(\" + k + \")\").test(fmt)) fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : ((\"00\" + o[k]).substr((\"\" + o[k]).length)));\r\n  return fmt;\r\n}\r\nconsole.log(new Date().format('yyyy-MM-dd hh:mm:ss'));\r\n/**\r\n * JavaScript Date对象(https://www.w3school.com.cn/js/jsref_obj_date.asp)\r\n */\r\n\r\n```\r\n\r\n### Promise\r\n\r\n```js\r\n// 顺序执行promise\r\nconst asyncSequentializer = (() => {\r\n  const toPromise = (x) => {\r\n    if (x instanceof Promise) {\r\n      // if promise just return it\r\n      return x;\r\n    }\r\n\r\n    if (typeof x === \"function\") {\r\n      // if function is not async this will turn its result into a promise\r\n      // if it is async this will await for the result\r\n      return (async () => await x())();\r\n    }\r\n    \r\n    return Promise.resolve(x);\r\n  };\r\n\r\n  return (list) => {\r\n    const results = [];\r\n\r\n    return (\r\n      list.reduce((lastPromise, currentPromise) => {\r\n          return lastPromise.then((res) => {\r\n            results.push(res); // collect the results\r\n            return toPromise(currentPromise);\r\n          });\r\n        }, toPromise(list.shift()))\r\n        // collect the final result and return the array of results as resolved promise\r\n        .then((res) => Promise.resolve([...results, res]))\r\n    );\r\n  };\r\n})();\r\n\r\n// 等待所有promise完成\r\nconst prom1 = Promise.reject(12);\r\nconst prom2 = Promise.resolve(24);\r\nconst prom3 = Promise.resolve(48);\r\nconst prom4 = Promise.resolve(\"error\");\r\n// completes when all promises resolve or at least one fail\r\n// if all resolve it will return an array of results in the same order of each promise\r\n// if fail it will return the error in catch\r\n\r\nPromise.all([prom1, prom2, prom3, prom4])\r\n  .then((res) => console.log(\"all\", res))\r\n  .catch((err) => console.log(\"all failed\", err));\r\n\r\n// completes with an array of objects with \"status\" and \"value\" or \"reason\" of each promise\r\n// status can be \"fullfilled\" or \"rejected\"\r\n// if fullfilled it will contain a \"value\" property\r\n\r\n// if failed it will contain a \"reasor property\r\nPromise.allSettled([prom1, prom2, prom3, prom4])\r\n  .then((res) => console.log(\"allSettled\", res))\r\n  .catch((err) => console.log(\"allSettled failed\", err));\r\n\r\n// completes with the first promise that resolves\r\n// fails if all promises fail\r\nPromise.any([prom1, prom2, prom3, prom4])\r\n  .then((res) => console.log(\"any\", res))\r\n  .catch((err) => console.log(\"any failed\", err));\r\n\r\n// completes with the first promise that either resolve or fail\r\n// whichever comes first\r\nPromise.race([prom1, prom2, prom3, prom4])\r\n  .then((res) => console.log(\"race\", res))\r\n  .catch((err) => console.log(\"race failed\", err));\r\n```\r\n\r\n### 全屏操作\r\n```js\r\n// 开启全屏\r\nexport const launchFullscreen = (element) => {\r\n    if (element.requestFullscreen) {\r\n        element.requestFullscreen()\r\n    } else if (element.mozRequestFullScreen) {\r\n        element.mozRequestFullScreen()\r\n    } else if (element.msRequestFullscreen) {\r\n        element.msRequestFullscreen()\r\n    } else if (element.webkitRequestFullscreen) {\r\n        element.webkitRequestFullScreen()\r\n    }\r\n}\r\n// 关闭全屏\r\nexport const exitFullscreen = () => {\r\n    if (document.exitFullscreen) {\r\n        document.exitFullscreen()\r\n    } else if (document.msExitFullscreen) {\r\n        document.msExitFullscreen()\r\n    } else if (document.mozCancelFullScreen) {\r\n        document.mozCancelFullScreen()\r\n    } else if (document.webkitExitFullscreen) {\r\n        document.webkitExitFullscreen()\r\n    }\r\n}\r\n/**\r\n * 进入全屏\r\n */\r\nfunction launchFullscreen(element) {\r\n    if (element.requestFullscreen) {\r\n        element.requestFullscreen();\r\n    } else if (element.mozRequestFullScreen) {\r\n        element.mozRequestFullScreen();\r\n    } else if (element.msRequestFullscreen) {\r\n        element.msRequestFullscreen();\r\n    } else if (element.webkitRequestFullscreen) {\r\n        element.webkitRequestFullScreen();\r\n    }\r\n}\r\n\r\nlaunchFullscreen(document.documentElement);\r\nlaunchFullscreen(document.getElementById(\"id\")); //某个元素进入全屏\r\n\r\n/**\r\n * 退出全屏\r\n */\r\nfunction exitFullscreen() {\r\n    if (document.exitFullscreen) {\r\n        document.exitFullscreen();\r\n    } else if (document.msExitFullscreen) {\r\n        document.msExitFullscreen();\r\n    } else if (document.mozCancelFullScreen) {\r\n        document.mozCancelFullScreen();\r\n    } else if (document.webkitExitFullscreen) {\r\n        document.webkitExitFullscreen();\r\n    }\r\n}\r\n\r\nexitFullscreen();\r\n\r\n/**\r\n * 全屏事件\r\n */\r\ndocument.addEventListener(\"fullscreenchange\", function (e) {\r\n    if (document.fullscreenElement) {\r\n        console.log(\"进入全屏\");\r\n    } else {\r\n        console.log(\"退出全屏\");\r\n    }\r\n});\r\n```\r\n\r\n### Cookie\r\n\r\n```js\r\n// -------cookie-------\r\n/**\r\n *\r\n * @param {*} key\r\n * @param {*} value\r\n * @param {*} expiredays 过期时间\r\n */\r\nfunction setCookie(key, value, expiredays) {\r\n  var exdate = new Date();\r\n  exdate.setDate(exdate.getDate() + expiredays);\r\n  document.cookie =\r\n    key +\r\n    \"=\" +\r\n    escape(value) +\r\n    (expiredays == null ? \"\" : \";expires=\" + exdate.toGMTString());\r\n}\r\n/**\r\n *\r\n * @param {*} name cookie key\r\n */\r\nfunction delCookie(name) {\r\n  var exp = new Date();\r\n  exp.setTime(exp.getTime() - 1);\r\n  var cval = getCookie(name);\r\n  if (cval != null) {\r\n    document.cookie = name + \"=\" + cval + \";expires=\" + exp.toGMTString();\r\n  }\r\n}\r\n/**\r\n *\r\n * @param {*} name cookie key\r\n */\r\nfunction getCookie(name) {\r\n  var arr,\r\n    reg = new RegExp(\"(^| )\" + name + \"=([^;]*)(;|$)\");\r\n  if ((arr = document.cookie.match(reg))) {\r\n    return arr[2];\r\n  } else {\r\n    return null;\r\n  }\r\n}\r\n// 清空\r\n// 有时候我们想清空，但是又无法获取到所有的cookie。\r\n// 这个时候我们可以了利用写满，然后再清空的办法。\r\n\r\n```\r\n\r\n### CSS操作\r\n```js\r\n// 获取元素css样式\r\nfunction getStyle(el, ruleName) {\r\n  return getComputedStyle(el, null).getPropertyValue(ruleName);\r\n}\r\n\r\n// 隐藏元素\r\n// 我们可以将元素的style.visibility设置为hidden，隐藏元素的可见性，但元素的空间仍然会被占用。如果设置元素的style.display为none，会将元素从渲染流中删除。\r\nconst hideElement = (el, removeFromFlow = false) => {\r\n  removeFromFlow ? (el.style.display = 'none')\r\n  : (el.style.visibility = 'hidden')\r\n}\r\n\r\n// 通过css检测系统的主题色从而全局修改样式\r\n// @media的属性prefers-color-scheme就可以知道当前的系统主题，当然使用前需要查查兼容性\r\n// ```css\r\n// @media (prefers-color-scheme: dark) { //... } \r\n// @media (prefers-color-scheme: light) { //... }\r\n// ```\r\n// javascript也可以轻松做到\r\n\r\nwindow.addEventListener('theme-mode', event =>{ \r\n    if(event.mode == 'dark'){}\r\n   if(event.mode == 'light'){} \r\n})\r\nwindow.matchMedia('(prefers-color-scheme: dark)') .addEventListener('change', event => { \r\n    if (event.matches) {} // dark mode\r\n})\r\n\r\n\r\n// -------浏览器对象 BOM-------\r\n/**\r\n * 告知浏览器支持的指定css属性情况\r\n * @param {String} key - css属性，是属性的名字，不需要加前缀\r\n * @returns {String} - 支持的属性情况\r\n */\r\nfunction validateCssKey(key) {\r\n  const jsKey = toCamelCase(key); // 有些css属性是连字符号形成\r\n  if (jsKey in document.documentElement.style) {\r\n    return key;\r\n  }\r\n  let validKey = \"\";\r\n  // 属性名为前缀在js中的形式，属性值是前缀在css中的形式\r\n  // 经尝试，Webkit也可是首字母小写webkit\r\n  const prefixMap = {\r\n    Webkit: \"-webkit-\",\r\n    Moz: \"-moz-\",\r\n    ms: \"-ms-\",\r\n    O: \"-o-\",\r\n  };\r\n  for (const jsPrefix in prefixMap) {\r\n    const styleKey = toCamelCase(`${jsPrefix}-${jsKey}`);\r\n    if (styleKey in document.documentElement.style) {\r\n      validKey = prefixMap[jsPrefix] + key;\r\n      break;\r\n    }\r\n  }\r\n  return validKey;\r\n}\r\n\r\n/**\r\n * 把有连字符号的字符串转化为驼峰命名法的字符串\r\n */\r\nfunction toCamelCase(value) {\r\n  return value.replace(/-(\\w)/g, (matched, letter) => {\r\n    return letter.toUpperCase();\r\n  });\r\n}\r\n\r\n// 检查浏览器是否支持某个css属性值（es6版）\r\n/**\r\n * 检查浏览器是否支持某个css属性值（es6版）\r\n * @param {String} key - 检查的属性值所属的css属性名\r\n * @param {String} value - 要检查的css属性值（不要带前缀）\r\n * @returns {String} - 返回浏览器支持的属性值\r\n */\r\nfunction valiateCssValue(key, value) {\r\n  const prefix = [\"-o-\", \"-ms-\", \"-moz-\", \"-webkit-\", \"\"];\r\n  const prefixValue = prefix.map((item) => {\r\n    return item + value;\r\n  });\r\n  const element = document.createElement(\"div\");\r\n  const eleStyle = element.style;\r\n  // 应用每个前缀的情况，且最后也要应用上没有前缀的情况，看最后浏览器起效的何种情况\r\n  // 这就是最好在prefix里的最后一个元素是''\r\n  prefixValue.forEach((item) => {\r\n    eleStyle[key] = item;\r\n  });\r\n  return eleStyle[key];\r\n}\r\n\r\n/**\r\n * 检查浏览器是否支持某个css属性值\r\n * @param {String} key - 检查的属性值所属的css属性名\r\n * @param {String} value - 要检查的css属性值（不要带前缀）\r\n * @returns {String} - 返回浏览器支持的属性值\r\n */\r\nfunction valiateCssValue(key, value) {\r\n  var prefix = [\"-o-\", \"-ms-\", \"-moz-\", \"-webkit-\", \"\"];\r\n  var prefixValue = [];\r\n  for (var i = 0; i < prefix.length; i++) {\r\n    prefixValue.push(prefix[i] + value);\r\n  }\r\n  var element = document.createElement(\"div\");\r\n  var eleStyle = element.style;\r\n  for (var j = 0; j < prefixValue.length; j++) {\r\n    eleStyle[key] = prefixValue[j];\r\n  }\r\n  return eleStyle[key];\r\n}\r\n\r\nfunction validCss(key, value) {\r\n  const validCss = validateCssKey(key);\r\n  if (validCss) {\r\n    return validCss;\r\n  }\r\n  return valiateCssValue(key, value);\r\n}\r\n```\r\n\r\n### HTML实用技巧\r\n```html\r\n<!-- 使用capture属性打开设备摄像头,user用于前置摄像头,environment用于后置摄像头-->\r\n<input type=\"file\" capture=\"user\" accept=\"image/*\">\r\n<!-- 网站自动刷新,实现每10秒刷新一次网站 -->\r\n<head>\r\n    <meta http-equiv=\"refresh\" content=\"10\">\r\n</head>\r\n<!-- 激活拼写检查,使用spellcheck属性并将其设置为true以激活拼写检查。使用lang属性指定待检查的语言。-->\r\n<input type=\"text\" spellcheck=\"true\" lang=\"en\">\r\n<!-- 指定要上传的文件类型,使用accept属性在input标签中指定允许用户上传的文件类型。-->\r\n<input type=\"file\" accept=\".jpeg,.png\">\r\n<!-- 阻止浏览器翻译,将translate属性设置为no会阻止浏览器翻译该内容 -->\r\n<p translate=\"no\">Brand name</p>\r\n<!-- 在input标签中输入多个项目,适用于文件和电子邮件。如果是电子邮件，则可以用逗号分隔 -->\r\n<input type=\"file\" multiple>\r\n<!-- 为视频创建海报（缩略图）使用poster属性，我们可以在视频加载时，或者在用户点击播放按钮之前，显示指定的缩略图。如果不指定图片，则默认使用视频的第一帧作为缩略图 -->\r\n<video poster=\"picture.png\"></video>\r\n<!-- 点击链接自动下载 -->\r\n<a href=\"image.png\" download>\r\n\r\n```","categories":[{"name":"JS","path":"api/categories/JS.json"}],"tags":[{"name":"代码实战","path":"api/tags/代码实战.json"}]}