{"title":"JavaScript相关","slug":"JavaScript相关","date":"2022-09-29T07:09:47.468Z","updated":"2023-11-10T02:36:16.898Z","comments":true,"path":"api/articles/JavaScript相关.json","excerpt":null,"covers":"https://picx1.zhimg.com/v2-ff627d205bd26ab15e4bdefd5daf1dda_1440w.jpg","content":"\r\n\r\n## Note\r\n\r\n### JQuery、JS常用方法\r\n\r\n```js\r\n// json字符串\r\nvar str1 = '{\"name\":\"cxh\",\"sex\":\"man\"}';\r\n// json对象\r\nvar str2 = {name:\"cxh\",sex:\"man\"};\r\n```\r\n**obj.toJSONString()** :将JSON对象转化为JSON字符。\r\n\r\n> 要引入https://github.com/douglascrockford/JSON-js/blob/master/json.js\r\n\r\n**JSON.stringify()** :将一个JavaScript值(对象或者数组)转换为一个JSON字符串,用于从一个对象解析出字符串\r\n\r\n```js\r\nvar a = {a:1,b:2}\r\nJSON.stringify(a)  // 结果：{\"a\":1,\"b\":2}\r\n```\r\n当使用ajax作为参数提交的时候需要将contentType设置为\"application/json\",将提交请求格式设置为post后台使用@RequestBody接收\r\n\r\n> [差点因为JSON.stringify丢了奖金..](https://mp.weixin.qq.com/s/JDah47ariZY3aerQ97RFKw)\r\n\r\n**JSON.parse()** :用来解析JSON字符串,转换成json对象.相似于$.parseJSON()/jQuery.parseJSON()\r\n\r\n```js\r\nvar str = '{\"name\":\"huangxiaojian\",\"age\":\"23\"}'\r\nJSON.parse(str)\r\n\r\n// {age: \"23\",name: \"huangxiaojian\",__proto__: Object}\r\n```\r\n注意：单引号写在{}外，每个属性名都必须用双引号，否则会抛出异常。\r\n\r\n**Object.assign(target1,target2,...,targetn)** ：合并对象，对象合并到第一个对象中，注意目标对象target1也会改变\r\n\r\n**join(separator)** :用于把数组中的所有元素放入一个字符串。separator可选，指定要使用的分隔符。如果省略该参数，则使用逗号作为分隔符。\r\n\r\n**split(separator,howmany)** :用于把一个字符串分割成字符串数组。separator必需。字符串或正则表达式，从该参数指定的地方分割。howmany可选。该参数可指定返回的数组的最大长度。如果设置了该参数，返回的子串不会多于这个参数指定的数组。如果没有设置该参数，整个字符串都会被分割，不考虑它的长度。\r\n\r\n**splice(index,howmany,item1,.....,itemX)** :向/从数组中删除项目，然后返回被删除的项目。index必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。howmany必需。要删除的项目数量。如果设置为0，则不会删除项目。item1,...,itemX可选。向数组添加的新项目，在原位置添加。\r\n\r\n```js\r\nvar fruits = [\"Banana\", \"Orange\", \"Apple\", \"Mango\"];\r\nfruits.splice(2,0,\"Lemon\",\"Kiwi\");\r\n// fruits 输出结果： Banana,Orange,Lemon,Kiwi,Apple,Mango\r\n```\r\n**unshift(newelement1,newelement2,....,newelementX)** :可向数组的开头添加一个或更多元素，并返回新的长度。newelement1必需。向数组添加的第一个元素。newelement2可选。向数组添加的第二个元素。newelementX可选。可添加若干个元素\r\n\r\n**pop()** :删除原数组最后一项，并返回删除元素的值；如果数组为空则返回undefined\r\n\r\n**shift()** :用于把数组的第一个元素从其中删除，并返回第一个元素的值\r\n\r\n**push(newelement1,newelement2,....,newelementX)** :可向数组的末尾添加一个或多个元素，并返回新的长度。\r\n\r\n**instanceof Array  typeof()** :判断是否为数组\r\n\r\n**concat()** :返回一个新数组，是将参数添加到原数组中构成的\r\n\r\n**reverse()** :将数组反序\r\n\r\n**sort(orderfunction)** :按指定的参数对数组进行排序\r\n\r\n**slice(start,end)** :返回从原数组中指定开始下标到结束下标之间的项组成的新数组。start-必填；设定新数组的起始位置；如果是负数，则表示从数组尾部开始算起（-1指最后一个元素，-2指倒数第二个元素，以此类推）。end-可选；设定新数组的结束位置；如果不填写该参数，默认到数组结尾；如果是负数，则表示从数组尾部开始算起（-1指最后一个元素，-2指倒数第二个元素，以此类推）\r\n\r\n**siblings()** :方法返回被选元素的所有同胞元素。\r\n\r\n**prev()** :查找上一个兄弟节点，不是所有的兄弟节点\r\n\r\n**prevAll()** :查找所有之前的兄弟节点\r\n\r\n**next()** :方法返回被选元素的下一个同胞元素。\r\n\r\n**nextAll()** :方法返回被选元素的所有跟随的同胞元素。\r\n\r\n**nextUntil()** :方法返回介于两个给定参数之间的所有跟随的同胞元素\r\n\r\n**parent(expr)** :找父元素\r\n\r\n**parents(expr)** :找到所有祖先元素，不限于父元素\r\n\r\n**children(expr)** :查找所有子元素，只会找到直接的孩子节点，不会返回所有子孙\r\n\r\n**contents()** :查找下面的所有内容，包括节点和文本。\r\n\r\n**slideToggle()** :方法通过使用滑动效果（高度变化）来切换元素的可见状态。如果被选元素是可见的，则隐藏这些元素，如果被选元素是隐藏的，则显示这些元素\r\n\r\n**slideUp()** :方法用于向上滑动元素。\r\n\r\n**slideDown()** :方法用于向下滑动元素\r\n\r\n**first()** :方法返回被选元素的首个元素。\r\n\r\n**last()** :方法返回被选元素的最后一个元素。\r\n\r\n**filter()** :方法允许您规定一个标准。不匹配这个标准的元素会被从集合中删除，匹配的元素会被返回。\r\n\r\n**not()** :方法返回不匹配标准的所有元素\r\n\r\n**after()** :方法在被选元素后插入指定的内容\r\n\r\n**clone()** :方法生成被选元素的副本，包含子节点、文本和属性\r\n\r\n**toFixed(num)** :规定小数的位数，是0~20之间的值，包括0和20，有些实现可以支持更大的数值范围。如果省略了该参数，将用0代替。\r\n\r\n**substring(start,end)** :索引从0开始。start必需。一个非负的整数，规定要提取的子串的第一个字符在stringObject中的位置。end可选。一个非负的整数，比要提取的子串的最后一个字符在stringObject中的位置多1。如果省略该参数，那么返回的子串会一直到字符串的结尾。\r\n\r\n**substr(start,length)** :start必需。要抽取的子串的起始下标。必须是数值。如果是负数，那么该参数声明从字符串的尾部开始算起的位置。也就是说，-1指字符串中最后一个字符，-2指倒数第二个字符，以此类推。length可选。子串中的字符数。必须是数值。如果省略了该参数，那么返回从stringObject的开始位置到结尾的字串。\r\n\r\n**every()** :是对数组中每一项运行给定函数，如果该函数对每一项返回true,则返回true。\r\n\r\n**some()** :是对数组中每一项运行给定函数，如果该函数对任一项返回true,则返回true。\r\n\r\n```js\r\nvar arr = [ 1, 2, 3, 4, 5, 6 ];\r\nconsole.log( arr.some( function( item,index,array){\r\n  console.log( 'item=' + item + ',index='+index+',array='+array );\r\n  return item > 3;\r\n\r\n})); // true\r\nconsole.log( arr.every( function( item, index, array ){\r\n  console.log( 'item=' + item + ',index='+index+',array='+array);\r\n  return item > 3;\r\n\r\n})); // false\r\n```\r\n\r\n**find(selector)** :获得当前元素集合中每个元素的后代，通过选择器、jQuery对象或元素来筛选。\r\n\r\n**padStart(maxLength,fillString)** :填充字符串例:2000-1-1变成2000-01-01\r\n\r\n**padEnd(maxLength,fillString)**\r\n\r\n**setInterval()** :方法可按照指定的周期（以毫秒计）来调用函数或计算表达式。\r\nsetInterval()方法会不停地调用函数，直到**clearInterval()** 被调用或窗口被关闭。由setInterval()返回的ID值可用作clearInterval()方法的参数。\r\n\r\n**setTimeout()** :方法用于在指定的毫秒数后调用函数或计算表达式。\r\n\r\n**jQuery.extend()** :函数用于将一个或多个对象的内容合并到目标对象。\r\n\r\n1. 如果只为$.extend()指定了一个参数，则意味着参数target被省略。此时，target就是jQuery对象本身。通过这种方式，我们可以为全局对象jQuery添加新的函数。\r\n2. 如果多个对象具有相同的属性，则后者会覆盖前者的属性值。\r\n```js\r\njQuery.extend({\r\n  min: function(a, b) {\r\n\treturn a < b ? a : b;\r\n  },\r\n  max: function(a, b) {\r\n\treturn a > b ? a : b;\r\n  }\r\n});\r\n\r\njQuery.min(2, 3); // 2\r\njQuery.max(4, 5); // 5\r\n\r\n$.fn.extend({\r\n  alertWhileClick: function() {\r\n\t$(this).click(function() {\r\n\t\talert($(this).val());\r\n\t});\r\n  }\r\n});\r\n$(\"#input1\").alertWhileClick();\r\n```\r\njquery.extend()将两个或更多对象的内容合并到第一个对象\r\njquery.extend(target,object1,...,objectN)\r\n\r\n**replaceAll**\r\n\r\n```js\r\nvar str = \"dogdogdog\";\r\nvar str2 = str.replace(/dog/g,\"cat\");\r\n// 去除字符串内所有的空格：\r\nstr = str.replace(/\\s*/g,\"\");\r\n// 去除字符串内两头的空格：\r\nstr = str.replace(/^\\s*|\\s*$/g,\"\");\r\n// 去除字符串内左侧的空格：\r\nstr = str.replace(/^\\s*/,\"\");\r\n// 去除字符串内右侧的空格：\r\nstr = str.replace(/(\\s*$)/g,\"\");\r\n```\r\n\r\n**JS阻止原生态提交事件**\r\n\r\n```js\r\nevent.preventDefault();\r\n```\r\n\r\n**执行函数!function(){}()**\r\n\r\n```js\r\n//!function(){}()写法和(function(){})()是相同的,函数意义相同，叫做立即运行的匿名函bai数(也叫立即调用函数)。\r\n//js中可以这样创建一个匿名函数：\r\n(function(){do something...})()\r\n//或\r\n(function(){do something...}())\r\n//而匿名函数后面的小括号()是为了让匿名函数立即执行，其实就是一个函数调用。\r\n\r\nalert((new Function(\"x\",\"y\",\"return x*y;\"))(2,3));// \"6\"\r\n```\r\n\r\n### JQuery选择器\r\n\r\n> [jQuery选择器](https://tool.oschina.net/uploads/apidocs/jquery/)\r\n\r\n```js\r\n// >: 选择某元素后面的第一代子元素div>p选择其父元素是<div>元素的所有<p>元素。\r\n// ~: 选取某个元素之后的所有同级元素,.box~h2这句就是选取.box后面所有的h2,.box和h2同级,并且不需要紧邻\r\n// 空格: 选择某元素后面的所有子元素.不一定是直接子元素.孙子元素也可以\r\n// +: 可选择紧接在另一元素后的兄弟元素，且二者有相同父元素,元素需要紧邻. div + p选择所有紧随<div>元素之后的<p>元素。\r\n\r\n$(\"#select option:selected\").val();\r\n$(\"#select option[value='1']\").attr(\"selected\",true);\r\n$(\"p :eq(1)\")  // 选择第二个<p>元素：\r\n```\r\n\r\n### 获取div class的值\r\n\r\n```js\r\n$(\"#divid\").attr('class');// attr基本上选中html原生属性\r\n$(\"#divid\").prop('class');// prop自定义属性\r\n```\r\n\r\n### display属性\r\n\r\n- display:block块级元素特点：\r\n1. 每个块级元素都从新的一行开始，并且其后的元素也另起一行。（很霸道，一个块级元素独占一行）\r\n2. 元素的高度、宽度、行高以及顶和底边距都可设置。\r\n3. 元素宽度在不设置的情况下，是它本身父容器的100%（和父元素的宽度一致），除非设定一个宽度。\r\n- display:inline内联元素特点：\r\n1. 和其他元素都在一行上；\r\n2. 元素的高度、宽度及顶部和底部边距不可设置；\r\n3. 元素的宽度就是它包含的文字或图片的宽度，不可改变。\r\n- display:inline-block内联块状元素（inline-block）就是同时具备内联元素、块状元素的特点。\r\ninline-block元素特点：\r\n1. 和其他元素都在一行上；\r\n2. 元素的高度、宽度、行高以及顶和底边距都可设置\r\n\r\n### aria-hidden=true\r\n\r\naria-hidden=\"true\"不会导致任何事情,它只是声明作者已经隐藏了该元素.\r\n\r\n### 三种方式脱离文档流\r\n\r\n```css\r\nposition:absolute\r\nposition:fixed\r\nfloat\r\n```\r\n\r\n### Map转json\r\n\r\n```js\r\nfunction MapToJson(m) {\r\n  var str = '{';\r\n  var i = 1;\r\n  m.forEach(function (item, key, mapObj) {\r\n   if(mapObj.size == i){\r\n     str += '\"'+ key+'\":\"'+ item + '\"';\r\n   }else{\r\n     str += '\"'+ key+'\":\"'+ item + '\",';\r\n   }\r\n   i++;\r\n  });\r\n  str +='}';\r\n  return str;\r\n}\r\nvar jsons=JSON.parse(MapToJson(map));\r\n```\r\n\r\n### if(obj)判断\r\n\r\nif(jsObj){}过滤**undefined不能过,null不能过 ,''不能过 ,0不能过,{}能过,[]能过**。即`jsObj!=undefined && jsObj!=null && jsObj!='' && jsObj!=0`\r\n\r\n**if(!!jsObj)与上面等价 可以隐式转换类型**\r\n\r\n**js判断对象是否为空对象的几种方法**\r\n1、将json对象转化为json字符串，再判断该字符串是否为\"{}\"\r\n```js\r\nvar data = {};\r\nvar b = (JSON.stringify(data) == \"{}\");\r\nalert(b);//true\r\n```\r\n\r\n2、for in循环判断\r\n\r\n```js\r\nvar obj = {};\r\nvar b = function() {\r\nfor(var key in obj) {\r\n\treturn false; \r\n} \r\nreturn true;\r\n\r\nalert(b());//true\r\n```\r\n\r\n3、jquery的**isEmptyObject**方法\r\n\r\n此方法是jquery将2方法(for in)进行封装，使用时需要依赖jquery\r\n```js\r\nvar data = {};\r\nvar b = $.isEmptyObject(data);\r\nalert(b);//true\r\n```\r\n\r\n4、**Object.getOwnPropertyNames()** 方法\r\n\r\n此方法是使用Object对象的getOwnPropertyNames方法，获取到对象中的属性名，存到一个数组中，返回数组对象，我们可以通过判断数组的length来判断此对象是否为空。注意：此方法不兼容ie8，其余浏览器没有测试\r\n```js\r\nvar data = {};\r\nvar arr = Object.getOwnPropertyNames(data);\r\nalert(arr.length == 0);//true\r\n```\r\n\r\n5、使用ES6的**Object.keys()** 方法\r\n与4方法类似，是ES6的新方法,返回值也是对象中属性名组成的数组\r\n```js\r\nvar data = {};\r\nvar arr = Object.keys(data);\r\nalert(arr.length == 0);//true\r\n```\r\n\r\n### 滚动条位置\r\n\r\n- scrollTop:获取或设置一个元素的内容垂直滚动的像素数。//页面内容的滚动距离\r\n- scrollHeight:一个元素内容高度的度量，包括由于溢出导致的视图中不可见内容。//滚动内容的总大小\r\n- clientHeight:元素内部的高度(单位像素)，包含内边距，但不包括水平滚动条、边框和外边距。//可见网页内容高\r\n\r\n### 浏览器展示页面执行顺序\r\n\r\n$(document).ready(function) = $().ready(function) = $(function)\r\n当DOM（文档对象模型）已经加载(页面所有的html标签（包括图片等）都加载完了，即浏览器已经响应完了，加载完了，全部展现到浏览器界面上了。)，并且页面（包括图像）已经完全呈现时，会发生ready事件。对于一个HTML文档，浏览器的解析顺序为：按照文档流，从上到下逐步解析页面的结构。JavaScript代码作为通过标签嵌入或引入的脚本，也HTML文档的组成部分。因此，JavaScript代码在装载时的执行顺序也是根据脚本标签<script\\>的出现顺序来确定的。但是，浏览器加载JavaScript时有个特点，那就是载入之后立即就会执行（先编译后执行），因为JavaScript可能会影响DOM树的结构，所以浏览器在执行完后才能继续加载下面的HTML内容。也就是说，浏览器下载并执行JavaScript的过程会阻塞DOM树的继续建立。所以，引入的多个js文件，会按顺序分开执行。同样的，对于不同<script\\>标签嵌入的JavaScript代码，也会分开执行。同一组<script\\>标签包括的代码就是一个代码块。后引入的JavaScript文件可以调用先引入的JavaScript文件的资源，下面的代码块可以访问上面代码块的资源，反之则不行。由于JavaScript通常需要操作DOM，所以，一般把JavaScript放在</body\\>前或者文档结尾处引入。若需要在<head\\>中引入，可以通过修改window.onload或者document.ready事件，强制等到DOM加载完成后再执行相关函数。\r\n\r\n\r\n### 引用\r\n\r\n- 数字、字符串、布尔类型的为原始类型，是值引用\r\n- 数组、对象类型为地址引用\r\n- 值引用可以深拷贝\r\n- 地址引用循环到原始类型方可进行深拷贝\r\n\r\n### http状态码\r\n\r\n- 301永久重定向\r\n- 302临时重定向\r\n- 400 bad request：错误请求，一般是前端提交数据的字段名称或者是字段类型和后台的实体类不一致(后台接收的数据类型不一致)，导致无法封装。或前端提交的到后台的数据应该是json字符串类型，而前端没有将对象转化为字符串类型；\r\n- 403服务器理解请求但拒绝执行，一般是资源权限问题导致,无权限访问\r\n- 405 get post等请求类型错误\r\n- 406 服务器返回的数据前端无法解析,一般是返回json格式数据前端的Content-Type是text:html\r\n- 502 bad gateway:错误的网关,上游服务器出现问题。连接超时 我们向服务器发送请求,由于服务器当前链接太多，导致服务器方面无法给于正常的响应，产生此类报错\r\n- 503过载\r\n- 504 gateway time-out\r\n程序执行时间过长导致响应超时，例如程序需要执行20秒，而nginx最大响应等待时间为10秒，这样就会出现超时\r\n\r\n> [http状态码详解](http://tool.oschina.net/commons?type=5)\r\n> [请求头响应头等参数详解](https://mp.weixin.qq.com/s/w_FgN5tVGr1DlbqyF5g4gw)\r\n\r\n### GET与POST区别\r\n\r\n1. GET在浏览器回退时是无害的，而POST会再次提交请求。\r\n2. GET产生的URL地址可以被Bookmark，而POST不可以。\r\n3. GET请求会被浏览器主动cache，而POST不会，除非手动设置。\r\n4. GET请求只能进行url编码，而POST支持多种编码方式。\r\n5. GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。\r\n6. GET请求在URL中传送的参数是有长度限制的，而POST没有。\r\n7. 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。\r\n8. GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。\r\n9. GET参数通过URL传递，POST放在Request body中。\r\n\r\n> [听我讲完GET、POST原理，面试官给我倒了杯卡布奇诺](https://mp.weixin.qq.com/s/W68JzNIoUpm9hyXinOzkMw)\r\n\r\n### ||和&&\r\n只要\"||\"前面为false,不管\"||\"后面是true还是false，都返回\"||\"后面的值\r\n只要\"||\"前面为true,不管\"||\"后面是true还是false，都返回\"||\"前面的值\r\n\r\n只要\"&&\"前面是false，无论\"&&\"后面是true还是false，结果都将返\"&&\"前面的值\r\n只要\"&&\"前面是true，无论\"&&\"后面是true还是false，结果都将返\"&&\"后面的值\r\n\r\n## JS关键字\r\n\r\n\r\n### arguments\r\n\r\narguments是js中内置的一个对象数组，存放的是调用函数的参数\r\narguments.callee()递归函数(callee是arguments内置的一个函数)\r\n```js\r\nfunction factorial(num) {\r\n  if(num<=1) {\r\n   return 1;\r\n  }else {\r\n   return num * factorial(num-1);\r\n  }\r\n} \r\n```\r\n相当于\r\n```js\r\nfunction factorial(num) {\r\n  if(num<=1) {\r\n   return 1;\r\n  }else {\r\n   return num * arguments.callee(num-1);\r\n  }\r\n} \r\n```\r\n\r\n### prototype、\\__proto\\__(两个下划线)与constructor\r\n\r\n\\__proto\\__和constructor属性是对象所独有的；prototype属性是函数所独有的，因为函数也是一种对象，所以函数也拥有\\__proto\\__和constructor属性。\\__proto\\__属性的作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的\\__proto\\__属性所指向的那个对象（父对象）里找，一直找，直到\\__proto\\__属性的终点null，再往上找就相当于在null上取值，会报错。通过\\__proto\\__属性将对象连接起来的这条链路即我们所谓的原型链。大多数情况下，\\__proto\\__可以理解为“构造器的原型”，即\\__proto\\__===constructor.prototype,但是通过Object.create()创建的对象有可能不是，Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的\\__proto_\\_\r\nprototype属性的作用就是让该函数所实例化的对象们都可以找到公用的属性和方法，即**book1.\\__proto\\__ === Book.prototype**。\r\n构造函数有什么缺点呢？构造函数的缺点就是会将构造函数内部的对象都复制一份：\r\n\r\n```js\r\nfunction Book(){\r\n    this.name ='www.flydean.com';\r\n    this.getName =function (){\r\n        console.log('flydean');\r\n    }\r\n}\r\nvar book1 = new Book();\r\nvar book2  = new Book();\r\nconsole.log(book1.getName  === book2.getName);//false\r\n```\r\n输出结果是false,说明每次new一个对象，对象中的方法也被拷贝了一份。而这并不是必须的。JavaScript的每个对象都继承另一个对象，后者称为“原型”（prototype）对象。只有null除外，它没有自己的原型对象。原型对象上的所有属性和方法，都能被派生对象共享。这就是JavaScript继承机制的基本设计。通过构造函数生成实例对象时，会自动为实例对象分配原型对象。每一个构造函数都有一个prototype属性，这个属性就是实例对象的原型对象。\r\n\r\n```js\r\n\r\nfunction Book(name){\r\n    this.name = name;\r\n}\r\nBook.prototype.author ='flydean';\r\nvar book1 = new Book();\r\nvar book2 = new Book();\r\nconsole.log(book1.author);//flydean\r\nconsole.log(book2.author);//flydean\r\n```\r\n上面例子中的author属性会被Book的所有实例所继承，Book的prototype对象，就是book1和book2的原型对象。\r\n原型对象的属性不是实例对象自身的属性。只要修改原型对象，变动就立刻会体现在所有实例对象上。由于原型本身也是对象，又有自己的原型，所以形成了一条原型链（prototype chain）。如果一层层地上溯，所有对象的原型最终都可以上溯到Object.prototype，即Object构造函数的prototype属性指向的那个对象。Object.prototype对象有没有它的原型呢？回答可以是有的，就是没有任何属性和方法的null对象，而null对象没有自己的原型。\r\n\r\n```js\r\nconsole.log(Object.getPrototypeOf(Object.prototype));//null\r\n```\r\nprototype对象有一个constructor属性，默认指向prototype对象所在的构造函数.\r\n```js\r\nfunction Book(name){\r\n    this.name = name;\r\n}\r\nvar book3 = new Book();\r\nconsole.log(book3.constructor);//function Book(name){this.name = name;}\r\nconsole.log(book3.constructor === Book.prototype.constructor);//true\r\nconsole.log(book3.hasOwnProperty(constructor));//false\r\n```\r\n还是刚刚的book，book3.constructor就是function Book本身。它也等于Book.prototype.constructor。constructor属性的含义就是指向该对象的构造函数，所有函数（此时看成对象了）最终的构造函数都指向Function。constructor属性的作用，是分辨原型对象到底属于哪个构造函数。因为prototype是一个对象，所以对象可以被赋值，也就是说prototype可以被改变：\r\n\r\n```js\r\nfunction A(){}\r\nvar a = new A();\r\nconsole.log(a instanceof A);//true\r\nfunction B(){}\r\nA.prototype = B.prototype;\r\nconsole.log(a instanceof A);//false\r\n```\r\n上面的例子中，我们修改了A.prototype，最后a instanceof A值是false。为了保证不会出现这样错误匹配的问题，我们再构建prototype的时候，一定不要直接重写整个的prototype，只需要修改其中的某个属性就好:\r\n```js\r\n// 不要这样写\r\nA.prototype = {\r\n    method1:function (){}\r\n}\r\n// 比较好的写法\r\nA.prototype = {\r\n    constructor:A,\r\n    method1:function (){}\r\n}\r\n// 更好的写法\r\nA.prototype.method1 = function (){}\r\n```\r\n#### Object的prototype操作\r\n**Object.getPrototypeOf**方法返回一个对象的原型。这是获取原型对象的标准方法.\r\n\r\n```js\r\n// 空对象的prototype是Object.prototype\r\nconsole.log(Object.getPrototypeOf({}) === Object.prototype);//true\r\n// function的prototype是Function.prototype\r\nfunction f(){}\r\nconsole.log(Object.getPrototypeOf(f)  === Function.prototype);//true\r\n\r\nfunction F(){this.name ='flydean'}\r\nvar f1 = new F();\r\nconsole.log(Object.getPrototypeOf(f1) === F.prototype);//true\r\nvar f2 = new f();\r\nconsole.log(Object.getPrototypeOf(f2) === f.prototype);//true\r\n```\r\n**Object.setPrototypeOf**方法可以为现有对象设置原型，返回一个新对象。\r\nObject.setPrototypeOf方法接受两个参数，第一个是现有对象，第二个是原型对象。\r\n\r\n```js\r\nvar a = {name: 'flydean'};\r\nvar b = Object.setPrototypeOf({},a);\r\nconsole.log(b.name);//flydean\r\n```\r\n**Object.prototype.isPrototypeOf()**\r\n对象实例的isPrototypeOf方法，用来判断一个对象是否是另一个对象的原型.\r\n\r\n```js\r\nvar a = {name: 'flydean'};\r\nvar b = Object.setPrototypeOf({},a);\r\nconsole.log(a.isPrototypeOf(b));//true\r\n```\r\n**Object.prototype.proto**\r\nproto属性（前后各两个下划线）可以改写某个对象的原型对象。还是刚才的例子，这次我们使用proto来改写对象的原型。\r\n\r\n```js\r\nvar a = {name: 'flydean'};\r\nvar c ={};\r\nc.__proto__ = a;\r\nconsole.log(Object.getPrototypeOf(c));//{\"name\": \"flydean\",[[Prototype]]:object}\r\n\r\n//-------\r\nfunction Book(name){\r\n    this.name = name;\r\n}\r\nconsole.log(Book.prototype)//{\"author\": \"flydean\",constructor:f Book(name)..}\r\nvar book1 = new Book();\r\nconsole.log(book1.__proto__===Book.prototype);//true\r\n```\r\nproto属性只有浏览器才需要部署，其他环境可以没有这个属性，而且前后的两根下划线，表示它本质是一个内部属性，不应该对使用者暴露。因此，应该尽量少用这个属性，而是用Object.getPrototypeof()（读取）和Object.setPrototypeOf()（设置），进行原型对象的读写操作\r\n\r\n综上，我们有三种获取原型对象的方法：\r\n```js\r\nobj.proto\r\nobj.constructor.prototype\r\nObject.getPrototypeOf(obj)\r\n```\r\n\r\n### Promise\r\n\r\n什么时候用\r\n回调地狱时使用，当代码难以维护，常常第一个的函数的输出是第二个函数的输入这种现象时使用promise。Promise对象用于表示一个异步操作的最终完成(或失败)及其结果值\r\n基本用法\r\ndemo1\r\n\r\n```js\r\nlet myFirstPromise = new Promise(function(resolve,reject){\r\n//调用then()时,当异步代码执行成功时，调用resolve(...),当异步代码失败时,调用reject(...)\r\n  if(){\r\n   resolve(111)\r\n  }else{\r\n   reject(222)\r\n  }\r\n});\r\nmyFirstPromise.then(function(successMessage){\r\n//successMessage的值是上面调用resolve(...)方法传入的值.上面不写resolve()的话不会执行这个函数\r\n//successMessage参数不一定非要是字符串类型，也可以是函数\r\n  console.log(\"Yay! \" + successMessage);\r\n},function(failedMessage){\r\n  // failedMessage的值是reject(..)传过来的参数，如果没有在上面写reject()的话不会执行此函数，写上reject()才会执行此快函数\r\n});\r\n```\r\ndemo2：\r\n\r\n```js\r\nfunction test(fun) {\r\n  //这里表示执行了一大堆各种代码;\r\n  ...\r\n  // 返回Promise对象\r\n  return new Promise(function(resolve, reject) {\r\n  // 这里也可以执行相关代码\r\n\tif (typeof fun== 'function') {\r\n\t   resolve(fun);\r\n\t } else {\r\n\t   reject('TypeError: '+ fun+'不是一个函数')\r\n\t }\r\n  })\r\n}\r\n// 当fun是一个function时\r\ntest(fun).then(function(abc) {// 参数abc是上面resolve(fun)的参数\r\n  abc();\r\n})\r\ntest('1234').catch(function(err) {\r\n// 参数err是上面reject('TypeError: '+ fun+'不是一个函数')的参数\r\n  console.log(err);\r\n})\r\n//promise.then(onFulfilled, onRejected)等价于promise.then(onFulfilled).catch(onRejected)\r\n```\r\n> [前端基础进阶（十五）：透彻掌握Promise的使用，读这篇就够了](https://www.jianshu.com/p/fe5f173276bd)\r\n> [JavaScript Promise对象](https://www.runoob.com/w3cnote/javascript-promise-object.html)\r\n> [mozilla promise](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise)\r\n> [写给Java程序员的前端Promise教程](https://mp.weixin.qq.com/s/92AHFPWjtH_y2_88mP3CYQ)\r\n\r\n\r\n### await、async\r\n\r\nasync是一个修饰符，async定义的函数会默认的返回一个Promise对象resolve的值，因此对async函数可以直接进行then操作,返回的值即为then方法的传入函数\r\n```js\r\n// 0. async基础用法测试\r\nasync function fun0() {\r\n    console.log(1)\r\n    return 1\r\n}\r\nfun0().then( x => { console.log(x) })  //  输出结果 1， 1，\r\n\r\nasync function funa() {\r\n    console.log('a')\r\n    return 'a'\r\n}\r\nfuna().then( x => { console.log(x) })  //  输出结果a， a，\r\n\r\nasync function funo() {\r\n    console.log({})\r\n    return {}\r\n}\r\nfuno().then( x => { console.log(x) })   // 输出结果 {}  {}\r\n\r\nasync function funp() {\r\n    console.log('Promise')\r\n    return new Promise(function(resolve, reject){\r\n        resolve('Promise')\r\n    })\r\n}\r\n\r\nfunp().then( x => { console.log(x) })   // 输出promise  promise\r\n```\r\nawait也是一个修饰符，await操作符用于等待一个Promise对象。它只能在异步函数async function中使用(await关键字只能放在async函数内部)，await关键字的作用就是返回Promise对象的处理结果，如果await后面并不是一个Promise的返回值，则会按照同步程序返回该值本身\r\n```js\r\n//  await关键字只能放在async函数内部，await关键字的作用就是获取Promise中返回的内容，获取的是Promise函数中resolve或者reject的值\r\n// 如果await后面并不是一个Promise的返回值，则会按照同步程序返回值处理,为undefined\r\nconst bbb = function(){ return 'string'}\r\n\r\nasync function funAsy() {\r\n   const a = await 1\r\n   const b = await new Promise((resolve, reject)=>{\r\n        setTimeout(function(){\r\n           resolve('time')\r\n        }, 3000)\r\n   })\r\n   const c = await bbb()\r\n   console.log(a, b, c)\r\n}\r\nfunAsy()  //  运行结果是3秒钟之后输出1，time,string,\r\n```\r\n\r\n那么由此看来async/await的综合用法如下\r\n\r\n```js\r\n// 1.定义一个或多个普通函数，函数必须返回Promise对象，如果返回其他类型的数据，将按照普通同步程序处理\r\nfunction log(time) {\r\n    return new Promise((resolve, reject)=> {\r\n        setTimeout(function(){\r\n           console.log(time)\r\n           resolve()\r\n        }, time)\r\n    })\r\n}\r\nasync function fun() {\r\n    await log(5000)\r\n    await log(10000)\r\n    log(1000)\r\n    console.log(1)\r\n}\r\nfun()\r\n\r\n// 2.如果不使用promise的方法的话\r\nfunction log2(time) {\r\n   setTimeout(function(){\r\n       console.log(time)\r\n       return 1\r\n    }, time)\r\n}\r\nasync function fun1() {\r\n    const a = await log2(5000)\r\n    const b = await log2(10000)\r\n    const c = log2(2000)\r\n    console.log(a)\r\n    console.log(1)\r\n}\r\n\r\nfun1()\r\n// 以上运行结果为：立刻输出undefined 立刻输出1  2秒后输出2000  5秒后输出5000  10秒后输出10000\r\n\r\n// 3.async/await的重要应用 \r\nconst asy = function(x, time) {\r\n    return new Promise((resolve, reject) =>{\r\n        setTimeout(()=>{\r\n            resolve(x)\r\n        }, time)\r\n    })\r\n}\r\nconst add = async function() {\r\n    const a = await asy(3, 5000)\r\n    console.log(a)\r\n    const b = await asy(4, 10000)\r\n    console.log(b)\r\n    const c =  await asy(5, 15000)\r\n    console.log(a,b,c)\r\n    const d = a + b +c  \r\n    console.log(d)\r\n}\r\nadd();\r\n// 5秒后输出3  又10秒后输出4 又15秒后输出5  然后立刻输出3,4,5，然后输出12\r\n```\r\n\r\n### js new\r\n\r\n帮我们做了这样几件事：\r\n1. 帮我们创建了一个空对象，作为返回对象的实例,例如：obj；\r\n2. 将空对象原型指向构造函数的property属性\r\n3. 将这个空对象赋值给函数内部的this\r\n4. 执行构造函数(如果构造函数内部有return语句，而且return后面跟着一个对象，new命令会返回return语句指定的对象；否则，就会不管return语句，返回this对象。)\r\n```js\r\nfunction Foo(name) {\r\n  this.name = name;\r\n  return this;\r\n}\r\nvar obj = {};\r\nobj.__proto__ = Foo.prototype;\r\nvar foo = Foo.call(obj, 'mm'); //call会改变this的指向\r\nconsole.log(foo);\r\n// 等同于\r\nvar foo = new Foo('mm')\r\nconsole.log(foo)\r\n```\r\n> [JavaScript：对象都是这样生成的!※(很重要的一篇文章)！](https://mp.weixin.qq.com/s/QJj9TnUKeXGj1HIX039etg)\r\n\r\n\r\n### JS this\r\n\r\nthis总是返回一个对象，简单说，就是返回属性或方法“当前”所在的对象。\r\n```js\r\nvar book = {\r\n    name :'flydean',\r\n    getName : function (){\r\n        return '书名：'+ this.name;\r\n    }\r\n}\r\nconsole.log(book.getName());\r\n//书名：flydean\r\n```\r\n这里this的指向是可变的，我们看一个例子：\r\n```js\r\nvar book = {\r\n    name :'flydean',\r\n    getName : function (){\r\n        return '书名：'+ this.name;\r\n    }\r\n}\r\nvar car ={\r\n    name :'car'\r\n}\r\ncar.getName = book.getName;\r\nconsole.log(car.getName());\r\n//书名：car\r\n```\r\n当A对象的方法被赋予B对象，该方法中的this就从指向A对象变成了指向B对象\r\n上面的例子中，我们把book中的getName方法赋值给了car对象，this对象现在就指向了car。如果某个方法位于多层对象的内部，这时this只是指向当前一层的对象，而不会继承更上面的层。\r\n\r\n```js\r\nvar book1 = {\r\n    name :'flydean',\r\n    book2: {\r\n        getName : function (){\r\n            return '书名：'+ this.name;\r\n        }\r\n    }\r\n}\r\nconsole.log(book1.book2.getName());\r\n//书名：undefined\r\n```\r\n上面的例子中，this是定义在对象中的函数中，如果是在函数中的函数中定义的this，代表什么呢？\r\n```js\r\nvar book3 = {\r\n    name :'flydean',\r\n    book4: function(){\r\n        console.log('book4');\r\n        var getName = function (){\r\n            console.log(this); //Window\r\n        }();\r\n    }\r\n}\r\nbook3.book4();\r\n```\r\n如果在函数中的函数中使用了this，那么内层的this指向的是全局的window对象。所以我们在使用的过程中要避免多层this。由于this的指向是不确定的，所以切勿在函数中包含多层的this。如果在全局环境使用this，它指的就是顶层对象window。\r\n数组的map和foreach方法，允许提供一个函数作为参数。这个函数内部不应该使用this。\r\n```js\r\nvar book5 ={\r\n    name : 'flydean',\r\n    author : ['max','jacken'],\r\n    f: function (){\r\n        this.author.forEach(function (item) {\r\n            console.log(this.name+' '+item);\r\n        })\r\n    }\r\n}\r\nbook5.f();\r\n//undefined max\r\n//undefined jacken\r\n```\r\nforeach方法的回调函数中的this，其实是指向window对象，因此取不到o.v的值。原因跟上一段的多层this是一样的，就是内层的this不指向外部，而指向顶层对象。怎么解决呢？我们使用一个中间变量：\r\n```js\r\nvar book6 ={\r\n    name : 'flydean',\r\n    author : ['max','jacken'],\r\n    f: function (){\r\n        var that = this;\r\n        this.author.forEach(function (item) {\r\n            console.log(that.name+' '+item);\r\n        })\r\n    }\r\n}\r\nbook6.f();\r\n//flydean max\r\n//flydean jacken\r\n```\r\n或者将this当作foreach方法的第二个参数，固定它的运行环境：\r\n```js\r\nvar book7 ={\r\n    name : 'flydean',\r\n    author : ['max','jacken'],\r\n    f: function (){\r\n        this.author.forEach(function (item) {\r\n            console.log(this.name+' '+item);\r\n        },this)\r\n    }\r\n}\r\nbook7.f();\r\n//flydean max\r\n//flydean jacken\r\n```\r\n绑定this的方法,JavaScript提供了call、apply、bind这三个方法，来切换/固定this的指向.\r\n\r\n**call**\r\n函数实例的call方法，可以指定函数内部this的指向（即函数执行时所在的作用域），然后在所指定的作用域中，调用该函数.\r\n\r\n```js\r\nvar book = {};\r\nvar f = function () {\r\n    return this;\r\n}\r\nf()  === this ; //true\r\nf.call(book) === book; //true\r\n```\r\n上面例子中，如果直接调用f()，那么返回的就是全局的window对象。如果传入book对象，那么返回的就是book对象。call方法的参数，应该是一个对象。如果参数为空、null和undefined，则默认传入全局对象。如果call方法的参数是一个原始值，那么这个原始值会自动转成对应的包装对象，然后传入call方法。\r\n\r\n```js\r\nvar f = function () {\r\n    return this;\r\n}\r\nconsole.log(f.call(100));\r\n//[Number: 100]\r\n```\r\ncall方法还可以接受多个参数。func.call(thisValue,arg1,arg2,...);call的第一个参数就是this所要指向的那个对象，后面的参数则是函数调用时所需的参数。call一般用在调用对象的原始方法：\r\n```js\r\nvar person =  {};\r\nperson.hasOwnProperty('getName');//false\r\n//覆盖person的getName方法\r\nperson.getName  = function(){\r\n    return true;\r\n}\r\nperson.hasOwnProperty('getName');//true\r\nObject.prototype.hasOwnProperty.call(person,'getName');//false\r\n```\r\n**apply**\r\napply方法的作用与call方法类似，也是改变this指向，然后再调用该函数。唯一的区别就是，它接收一个数组作为函数执行时的参数.\r\n```js\r\nfunc.apply(thisValue,[arg1,arg2,...])\r\n```\r\n**bind**\r\ncall和apply是改变this的指向，然后调用该函数，而bind方法用于将函数体内的this绑定到某个对象，然后返回一个新函数.\r\n```js\r\nvar d = new Date();\r\nconsole.log(d.getTime()); //1600755862787\r\nvar getTime= d.getTime;\r\nconsole.log(getTime());//TypeError: this is not a Date object.\r\n```\r\n上面的例子中，getTime方法里面调用了this，如果直接把d.getTime赋值给getTime变量，那么this将会指向全局的window对象，导致运行错误。我们可以这样修改：\r\n```js\r\nvar d = new Date();\r\nconsole.log(d.getTime()); //1600755862787\r\nvar getTime2= d.getTime.bind(d);\r\nconsole.log(getTime2());\r\n```\r\nbind比call方法和apply方法更进一步的是，除了绑定this以外，还可以绑定原函数的参数。\r\n```js\r\nvar add = function(x,y){\r\n    return x +this.m +  y + this.n;\r\n}\r\nvar addObj ={\r\n    m: 10,\r\n    n: 10\r\n}\r\nvar newAdd = add.bind(addObj,2);\r\nconsole.log(newAdd(3));//25\r\n```\r\n上面的例子中，bind将两个参数的add方法，替换成了1个参数的add方法。注意：bind每次调用都会返回一个新的函数，从而导致无法取消之前的绑定。\r\n\r\n> [理解js中this的指向](https://www.cnblogs.com/pssp/p/5216085.html)\r\n\r\n\r\n### class\r\n\r\nES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。\r\n```js\r\nclass Person {\r\n    constructor(name,sex) {\r\n        this.name=name;\r\n        this.sex =sex;\r\n    }\r\n    toString(){\r\n        return this.name + ' '+ this.sex;\r\n    }\r\n}\r\n```\r\n构造函数的prototype属性，在ES6的“类”上面继续存在。事实上，类的所有方法都定义在类的prototype属性上面。\r\n上面的类等同于：\r\n```js\r\nPerson.prototype = {\r\n       constructor(name,sex) {\r\n        this.name=name;\r\n        this.sex =sex;\r\n    }\r\n    toString(){\r\n        return this.name + ' '+ this.sex;\r\n    } \r\n}\r\n```\r\n表达式属性名\r\nclass还支持动态的表达式属性名：\r\n```js\r\nlet methodName = 'getName';\r\nclass Person {\r\n    constructor(name,sex) {\r\n        this.name=name;\r\n        this.sex =sex;\r\n    }\r\n\r\n    toString(){\r\n        return this.name + ' '+ this.sex;\r\n    }\r\n\r\n    [methodName](){\r\n        return this.name;\r\n    }\r\n}\r\n```\r\n静态方法\r\n类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。\r\n```js\r\nclass Person {\r\n    constructor(name,sex) {\r\n        this.name=name;\r\n        this.sex =sex;\r\n    }\r\n    static getSex(){\r\n        return '男';\r\n    }\r\n}\r\nconsole.log(Person.getSex()); //男\r\nlet  p  = new Person();\r\nconsole.log(p.getSex());//TypeError: p.getSex is not a function\r\n```\r\n静态属性\r\n静态属性指的是Class本身的属性，即Class.propName，而不是定义在实例对象（this）上的属性.\r\n```js\r\nclass Person {\r\n    constructor(name,sex) {\r\n        this.name=name;\r\n        this.sex =sex;\r\n    }\r\n}\r\nPerson.address ='address';\r\nconsole.log(Person.address);\r\n```\r\n目前，只有这种写法可行，因为ES6明确规定，Class内部只有静态方法，没有静态属性。\r\n\r\nclass的继承\r\nclass 的继承一般使用extends关键字：\r\n```js\r\nclass Boy extends Person{\r\n    constructor(name,sex,address) {\r\n        super(name,sex); //调用父类的构造函数\r\n        this.address =address;\r\n    }\r\n    toString() {\r\n        return super.toString();//调用父类的方法\r\n    }\r\n}\r\n```\r\n在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。这是因为子类实例的构建，是基于对父类实例加工，只有super方法才能返回父类实例。super作为函数调用时，代表父类的构造函数。ES6要求，子类的构造函数必须执行一次super函数。super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。上面的例子，我们在子类Boy中的toString普通方法中，调用了super.toString()，之前我们也讲了，类的所有方法都定义在类的prototype属性上面。所以super.toString就是Person中定义的toString方法。由于super指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过super调用的。定义在父类实例上的方法或属性就是指在constructor中定义的方法或者属性。Person 类，在constructor中定义了name属性。我们看一下在Boy中的普通方法中访问会有什么问题：\r\n```js\r\nclass Boy extends Person{\r\n    constructor(name,sex,address) {\r\n        super(name,sex); //调用父类的构造函数\r\n        console.log(super.name);  //undefined\r\n        console.log(this.name);  //hanmeimei\r\n        this.address =address;\r\n    }\r\n    toString() {\r\n        return super.toString();//调用父类的方法\r\n    }\r\n    getName(){\r\n        console.log(super.name);  //undefined\r\n        console.log(this.name);    //hanmeimei\r\n    }\r\n}\r\nvar b =new Boy('hanmeimei','女','北京');\r\nb.getName();\r\n```\r\n\r\n### 继承\r\n\r\n构造函数的继承。\r\n构造函数的继承第一步是在子类的构造函数中，调用父类的构造函数,让子类实例具有父类实例的属性。然后让子类的原型指向父类的原型，这样子类就可以继承父类原型。\r\n\r\n```js\r\nfunction Person (){\r\n    this.name = 'person';\r\n}\r\n\r\nfunction Boy(){\r\n    Person.call(this);\r\n    this.title = 'boy';\r\n}\r\n\r\nBoy.prototype= Object.create(Person.prototype);\r\nBoy.prototype.constructor=Boy;\r\nBoy.prototype.getTitle=function (){console.log(this.title)};\r\n\r\nvar b =new Boy();\r\nb.getTitle();\r\nconsole.log(b);\r\n```\r\n调用父类的构造函数是初始化实例对象的属性。子类的原型指向父类的原型是为了基础父类的原型对象的属性。\r\n另外一种写法是Boy.prototype等于一个父类实例：\r\n```js\r\nBoy.prototype = new Person();\r\n```\r\n上面这种写法也有继承的效果，但是子类会具有父类实例的方法。有时，这可能不是我们需要的，所以不推荐使用这种写法.\r\nJavaScript不提供多重继承功能，即不允许一个对象同时继承多个对象。但是，可以通过变通方法，实现这个功能:\r\n```js\r\nfunction Person1 (){\r\n    this.name = 'person';\r\n}\r\nfunction Person2 (){\r\n    this.sex = '男';\r\n}\r\n\r\nfunction Boy(){\r\n    Person1.call(this);\r\n    Person2.call(this);\r\n    this.title = 'boy';\r\n}\r\n\r\n//继承Person1\r\nBoy.prototype= Object.create(Person1.prototype);\r\n//继承链加上Person2\r\nObject.assign(Boy.prototype,Person2.prototype);\r\n\r\nBoy.prototype.constructor=Boy;\r\nBoy.prototype.getTitle=function (){console.log(this.title)};\r\n\r\nvar b =new Boy();\r\nb.getTitle();\r\nconsole.log(b);\r\n//Boy { name: 'person', sex: '男', title: 'boy' }\r\n```\r\n\r\n### spread运算符(扩展运算符)\r\n\r\n扩展运算符`...`是ES6中引入的一个新运算符，它可以将一个数组或者类数组对象展开（或者说“拍扁”）成一系列单独的值，或者将多个值合并成一个数组\r\n\r\n```js\r\n// 插入数组：\r\n// 看看如下代码，不使用扩展语法：\r\nvar mid = [3, 4];\r\nvar arr = [1, 2, mid, 5, 6];\r\nconsole.log(arr);  // [1, 2, [3, 4] , 5, 6]\r\n// 上面这段代码将得到一个嵌套数组的数组。大部分情况，我们希望一个array（mid）展开后再插入到另一个array（arr）中。\r\n// 使用spread操作符我们可以这样：\r\nvar mid = [3, 4];\r\nvar arr = [1, 2, ...mid, 5, 6];\r\nconsole.log(arr); // [1，2，3，4，5，6]\r\n\r\n// 展开数组作为参数\r\n// 当一个函数接收多个参数，比如Math.max，当我们有一个数组需要找到你了的最大值，我们可以使用如下代码进行调用。\r\nvar arr = [2, 4, 8, 6, 0];\r\nfunction max(arr) {\r\n  return Math.max.apply(null, arr);\r\n}\r\nconsole.log(max(arr)); // 8\r\n\r\n// 如果这时候使用spread运算符会变得非常方便。\r\nvar arr = [2, 4, 8, 6, 0];\r\nvar max = Math.max(...arr);\r\nconsole.log(max); // 8\r\n\r\n// 复制数组\r\n// 用数组给新数组赋值只是获取到数组引用，并没有达到深复制的效果。\r\nvar arr = ['a', 'b', 'c'];\r\nvar arr2 = arr;\r\narr2.push('d');\r\nconsole.log(arr);// [\"a\", \"b\", \"c\", \"d\"]\r\n\r\n// 有多重方法可以实现深复制，但是使用spread操作符是最简洁的一种实现：\r\nvar arr = ['a', 'b', 'c'];\r\nvar arr2 = [...arr];\r\narr2.push('d');\r\nconsole.log(arr);  // [\"a\", \"b\", \"c\"]\r\n\r\n// 展开String\r\n// 如果想将字符串转为字符数组，如果不实用展开操作：\r\nvar str = \"hello\";\r\n\"hello\".split('') // [\"h\", \"e\", \"l\", \"l\", \"o\"]\r\n\r\n// 使用展开操作符可以这样写：\r\nvar str = \"hello\";\r\nvar chars = [...str]; // [\"h\", \"e\", \"l\", \"l\", \"o\"]\r\n\r\n// 展开Object\r\n// 我们还可以对对象进行展开，如果有两个对象，有不同的key-value,我们需要将这两个对象合并起来(需要使用Object rest spread transform)，我们可以这样：\r\n\r\nlet Obj1 = {\r\n key1: 'value1'\r\n}\r\n\r\nlet Obj2 = {\r\n key2: 'value3'\r\n}\r\n\r\nlet concatValue = {\r\n ...Obj1,\r\n ...Obj2\r\n}\r\nconsole.log(concatValue) // {key1: 'value1', key2: 'value2'}\r\n```\r\n\r\n## 相关文章\r\n\r\n- [Web开发技术(mozilla)](https://developer.mozilla.org/zh-CN/docs/Web)\r\n- [万字干货！详解JavaScript执行过程](https://mp.weixin.qq.com/s/wolPlpUDizVnzh-kBKMtxg)\r\n- [20分钟全面理解JavaScript事件机制](https://mp.weixin.qq.com/s/ct4AyU--sewtOaDOlO2Oxw)\r\n- [面试官：有了for循环为什么还要forEach？](https://mp.weixin.qq.com/s/aPFCrPGBTus_Spf1QL1WWA)\r\n- [每日一题」JS中的闭包是什么？](https://zhuanlan.zhihu.com/p/22486908)\r\n- [post请求下载excel文档解决方法](https://blog.csdn.net/weixin_44001753/article/details/114266453)\r\n- [不懂Vue的Java猿不是一个好的前端工程师](https://mp.weixin.qq.com/s/QoS5z9Qfokpcw42zDbiE2A)\r\n- [前端面试复习笔记](https://github.com/CavsZhouyou/Front-End-Interview-Notebook)","categories":[{"name":"JS","path":"api/categories/JS.json"}],"tags":[{"name":"随笔","path":"api/tags/随笔.json"}]}