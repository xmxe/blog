{"title":"Dubbo","slug":"Dubbo","date":"2022-11-15T07:14:17.493Z","updated":"2023-06-16T07:17:26.957Z","comments":true,"path":"api/articles/Dubbo.json","excerpt":null,"covers":"https://picd.zhimg.com/v2-5f6b4a9d35a1add123ac6b3f444b2291_1440w.jpg","content":"\r\n\r\n## Dubbo基础\r\n\r\n### 什么是Dubbo?\r\n\r\n![img](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2020-8/427f2168-1930-4c14-8760-415fac8db1d0-20200802184737978.png)\r\n\r\n[Apache Dubbo](https://github.com/apache/dubbo)|ˈdʌbəʊ|是一款高性能、轻量级的开源Java RPC框架。\r\n\r\n根据 [Dubbo官方文档](https://dubbo.apache.org/zh/)的介绍，Dubbo提供了六大核心能力\r\n\r\n1. 面向接口代理的高性能RPC调用。\r\n2. 智能容错和负载均衡。\r\n3. 服务自动注册和发现。\r\n4. 高度可扩展能力。\r\n5. 运行期流量调度。\r\n6. 可视化的服务治理与运维。\r\n\r\n![Dubbo提供的六大核心能力](https://oss.javaguide.cn/源码/dubbo/dubbo提供的六大核心能力.png)\r\n\r\n简单来说就是：**Dubbo不光可以帮助我们调用远程服务，还提供了一些其他开箱即用的功能比如智能负载均衡。**\r\n\r\nDubbo目前已经有接近34.4k的Star。Dubbo是由阿里开源，后来加入了Apache。正是由于Dubbo的出现，才使得越来越多的公司开始使用以及接受分布式架构。\r\n\r\n### 为什么要用Dubbo?\r\n\r\n随着互联网的发展，网站的规模越来越大，用户数量越来越多。单一应用架构、垂直应用架构无法满足我们的需求，这个时候分布式服务架构就诞生了。\r\n\r\n分布式服务架构下，系统被拆分成不同的服务比如短信服务、安全服务，每个服务独立提供系统的某个核心服务。\r\n\r\n我们可以使用Java RMI（Java Remote Method Invocation）、Hessian这种支持远程调用的框架来简单地暴露和引用远程服务。但是！当服务越来越多之后，服务调用关系越来越复杂。当应用访问压力越来越大后，负载均衡以及服务监控的需求也迫在眉睫。我们可以用F5这类硬件来做负载均衡，但这样增加了成本，并且存在单点故障的风险。\r\n\r\n不过，Dubbo的出现让上述问题得到了解决。**Dubbo帮助我们解决了什么问题呢？**\r\n\r\n1. **负载均衡**：同一个服务部署在不同的机器时该调用哪一台机器上的服务。\r\n2. **服务调用链路生成**：随着系统的发展，服务越来越多，服务间依赖关系变得错踪复杂，甚至分不清哪个应用要在哪个应用之前启动，架构师都不能完整的描述应用的架构关系。Dubbo可以为我们解决服务之间互相是如何调用的。\r\n3. **服务访问压力以及时长统计、资源调度和治理**：基于访问压力实时管理集群容量，提高集群利用率。\r\n4. ......\r\n\r\n![img](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-26/43050183.jpg)\r\n\r\n另外，Dubbo除了能够应用在分布式系统中，也可以应用在现在比较火的微服务系统中。不过，由于Spring Cloud在微服务中应用更加广泛，所以，我觉得一般我们提Dubbo的话，大部分是分布式系统的情况。\r\n\r\n**我们刚刚提到了分布式这个概念，下面再给大家介绍一下什么是分布式？为什么要分布式？**\r\n\r\n## 分布式基础\r\n\r\n### 什么是分布式?\r\n\r\n分布式或者说SOA分布式重要的就是面向服务，说简单的分布式就是我们把整个系统拆分成不同的服务然后将这些服务放在不同的服务器上减轻单体服务的压力提高并发量和性能。比如电商系统可以简单地拆分成订单系统、商品系统、登录系统等等，拆分之后的每个服务可以部署在不同的机器上，如果某一个服务的访问量比较大的话也可以将这个服务同时部署在多台机器上。\r\n\r\n![分布式事务示意图](https://oss.javaguide.cn/java-guide-blog/分布式事务示意图.png)\r\n\r\n### 为什么要分布式?\r\n\r\n从开发角度来讲单体应用的代码都集中在一起，而分布式系统的代码根据业务被拆分。所以，每个团队可以负责一个服务的开发，这样提升了开发效率。另外，代码根据业务拆分之后更加便于维护和扩展。\r\n\r\n另外，我觉得将系统拆分成分布式之后不光便于系统扩展和维护，更能提高整个系统的性能。你想一想嘛？把整个系统拆分成不同的服务/系统，然后每个服务/系统单独部署在一台服务器上，是不是很大程度上提高了系统性能呢？\r\n\r\n## Dubbo架构\r\n\r\n### Dubbo架构中的核心角色有哪些？\r\n\r\n[官方文档中的框架设计章节](https://dubbo.apache.org/zh/docs/v2.7/dev/design/)已经介绍的非常详细了，我这里把一些比较重要的点再提一下。\r\n\r\n![dubbo-relation](https://oss.javaguide.cn/源码/dubbo/dubbo-relation.jpg)\r\n\r\n上述节点简单介绍以及他们之间的关系：\r\n\r\n- **Container**：服务运行容器，负责加载、运行服务提供者。必须。\r\n- **Provider**：暴露服务的服务提供方，会向注册中心注册自己提供的服务。必须。\r\n- **Consumer**：调用远程服务的服务消费方，会向注册中心订阅自己所需的服务。必须。\r\n- **Registry**：服务注册与发现的注册中心。注册中心会返回服务提供者地址列表给消费者。非必须。\r\n- **Monitor**：统计服务的调用次数和调用时间的监控中心。服务消费者和提供者会定时发送统计数据到监控中心。非必须。\r\n\r\n### Dubbo中的Invoker概念了解么？\r\n\r\nInvoker是Dubbo领域模型中非常重要的一个概念，你如果阅读过Dubbo源码的话，你会无数次看到这玩意。就比如下面我要说的负载均衡这块的源码中就有大量Invoker的身影。\r\n\r\n简单来说，Invoker就是Dubbo对远程调用的抽象。\r\n\r\n![dubbo_rpc_invoke.jpg](https://oss.javaguide.cn/java-guide-blog/dubbo_rpc_invoke.jpg)\r\n\r\n按照Dubbo官方的话来说，Invoker分为\r\n\r\n- 服务提供Invoker\r\n- 服务消费Invoker\r\n\r\n假如我们需要调用一个远程方法，我们需要动态代理来屏蔽远程调用的细节吧！我们屏蔽掉的这些细节就依赖对应的Invoker实现，Invoker实现了真正的远程服务调用。\r\n\r\n### Dubbo的工作原理了解么？\r\n\r\n下图是Dubbo的整体设计，从下至上分为十层，各层均为单向依赖。\r\n\r\n> 左边淡蓝背景的为服务消费方使用的接口，右边淡绿色背景的为服务提供方使用的接口，位于中轴线上的为双方都用到的接口。\r\n\r\n![dubbo-framework](https://oss.javaguide.cn/source-code/dubbo/dubbo-framework.jpg)\r\n\r\n- **config配置层**：Dubbo相关的配置。支持代码配置，同时也支持基于Spring来做配置，以Service Config,Reference Config为中心\r\n- **proxy服务代理层**：调用远程方法像调用本地的方法一样简单的一个关键，真实调用过程依赖代理类，以ServiceProxy为中心。\r\n- **registry注册中心层**：封装服务地址的注册与发现。\r\n- **cluster路由层**：封装多个提供者的路由及负载均衡，并桥接注册中心，以Invoker为中心。\r\n- **monitor监控层**：RPC调用次数和调用时间监控，以Statistics为中心。\r\n- **protocol远程调用层**：封装RPC调用，以Invocation,Result为中心。\r\n- **exchange信息交换层**：封装请求响应模式，同步转异步，以Request,Response为中心。\r\n- **transport网络传输层**：抽象mina和netty为统一接口，以Message为中心。\r\n- **serialize数据序列化层**：对需要在网络传输的数据进行序列化。\r\n\r\n### Dubbo的SPI机制了解么？如何扩展Dubbo中的默认实现？\r\n\r\nSPI（Service Provider Interface）机制被大量用在开源项目中，它可以帮助我们动态寻找服务/功能（比如负载均衡策略）的实现。\r\n\r\nSPI的具体原理是这样的：我们将接口的实现类放在配置文件中，我们在程序运行过程中读取配置文件，通过反射加载实现类。这样，我们可以在运行的时候，动态替换接口的实现类。和IoC的解耦思想是类似的。\r\n\r\nJava本身就提供了SPI机制的实现。不过，Dubbo没有直接用，而是对Java原生的SPI机制进行了增强，以便更好满足自己的需求。\r\n\r\n**那我们如何扩展Dubbo中的默认实现呢？**\r\n\r\n比如说我们想要实现自己的负载均衡策略，我们创建对应的实现类XxxLoadBalance实现LoadBalance接口或者AbstractLoadBalance类。\r\n\r\n```java\r\npackage com.xxx;\r\n \r\nimport org.apache.dubbo.rpc.cluster.LoadBalance;\r\nimport org.apache.dubbo.rpc.Invoker;\r\nimport org.apache.dubbo.rpc.Invocation;\r\nimport org.apache.dubbo.rpc.RpcException;\r\n \r\npublic class XxxLoadBalance implements LoadBalance {\r\n    public <T> Invoker<T> select(List<Invoker<T>> invokers, Invocation invocation) throws RpcException {\r\n        // ...\r\n    }\r\n}\r\n```\r\n\r\n我们将这个实现类的路径写入到resources目录下的META-INF/dubbo/org.apache.dubbo.rpc.cluster.LoadBalance文件中即可。\r\n\r\n```java\r\nsrc\r\n |-main\r\n    |-java\r\n        |-com\r\n            |-xxx\r\n                |-XxxLoadBalance.java(实现LoadBalance接口)\r\n    |-resources\r\n        |-META-INF\r\n            |-dubbo\r\n                |-org.apache.dubbo.rpc.cluster.LoadBalance(纯文本文件，内容为：xxx=com.xxx.XxxLoadBalance)\r\n```\r\norg.apache.dubbo.rpc.cluster.LoadBalance\r\n\r\n```text\r\nxxx=com.xxx.XxxLoadBalance\r\n```\r\n\r\n其他还有很多可供扩展的选择，你可以在[官方文档](https://cn.dubbo.apache.org/zh-cn/overview/home/)中找到。\r\n\r\n### Dubbo的微内核架构了解吗？\r\n\r\nDubbo采用微内核（Microkernel）+插件（Plugin）模式，简单来说就是微内核架构。微内核只负责组装插件。\r\n\r\n**何为微内核架构呢**？《软件架构模式》这本书是这样介绍的：\r\n\r\n> 微内核架构模式（有时被称为插件架构模式）是实现基于产品应用程序的一种自然模式。基于产品的应用程序是已经打包好并且拥有不同版本，可作为第三方插件下载的。然后，很多公司也在开发、发布自己内部商业应用像有版本号、说明及可加载插件式的应用软件（这也是这种模式的特征）。微内核系统可让用户添加额外的应用如插件，到核心应用，继而提供了可扩展性和功能分离的用法。\r\n\r\n微内核架构包含两类组件：**核心系统（coresystem）**和**插件模块（plug-inmodules）**。\r\n\r\n![img](https://oss.javaguide.cn/source-code/dubbo/微内核架构示意图.png)\r\n\r\n核心系统提供系统所需核心能力，插件模块可以扩展系统的功能。因此，基于微内核架构的系统，非常易于扩展功能。\r\n\r\n我们常见的一些IDE，都可以看作是基于微内核架构设计的。绝大多数IDE比如IDEA、VSCode都提供了插件来丰富自己的功能。\r\n\r\n正是因为Dubbo基于微内核架构，才使得我们可以随心所欲替换Dubbo的功能点。比如你觉得Dubbo的序列化模块实现的不满足自己要求，没关系,你自己实现一个序列化模块就好了\r\n\r\n通常情况下，微核心都会采用Factory、IoC、OSGi等方式管理插件生命周期。Dubbo不想依赖Spring等IoC容器，也不想自己造一个小的IoC容器（过度设计），因此采用了一种最简单的Factory方式管理插件：**JDK标准的SPI扩展机制**（java.util.ServiceLoader）。\r\n\r\n### 关于Dubbo架构的一些自测小问题\r\n\r\n#### 注册中心的作用了解么？\r\n\r\n注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互。\r\n\r\n#### 服务提供者宕机后，注册中心会做什么？\r\n\r\n注册中心会立即推送事件通知消费者。\r\n\r\n#### 监控中心的作用呢？\r\n\r\n监控中心负责统计各服务调用次数，调用时间等。\r\n\r\n#### 注册中心和监控中心都宕机的话，服务都会挂掉吗？\r\n\r\n不会。两者都宕机也不影响已运行的提供者和消费者，消费者在本地缓存了提供者列表。注册中心和监控中心都是可选的，服务消费者可以直连服务提供者。\r\n\r\n## Dubbo的负载均衡策略\r\n\r\n### 什么是负载均衡？\r\n\r\n先来看一下稍微官方点的解释。下面这段话摘自维基百科对负载均衡的定义：\r\n\r\n> 负载均衡改善了跨多个计算资源（例如计算机，计算机集群，网络链接，中央处理单元或磁盘驱动）的工作负载分布。负载平衡旨在优化资源使用，最大化吞吐量，最小化响应时间，并避免任何单个资源的过载。使用具有负载平衡而不是单个组件的多个组件可以通过冗余提高可靠性和可用性。负载平衡通常涉及专用软件或硬件。\r\n\r\n**上面讲的大家可能不太好理解，再用通俗的话给大家说一下。**\r\n\r\n我们的系统中的某个服务的访问量特别大，我们将这个服务部署在了多台服务器上，当客户端发起请求的时候，多台服务器都可以处理这个请求。那么，如何正确选择处理该请求的服务器就很关键。假如，你就要一台服务器来处理该服务的请求，那该服务部署在多台服务器的意义就不复存在了。负载均衡就是为了避免单个服务器响应同一请求，容易造成服务器宕机、崩溃等问题，我们从负载均衡的这四个字就能明显感受到它的意义。\r\n\r\n### Dubbo提供的负载均衡策略有哪些？\r\n\r\n在集群负载均衡时，Dubbo提供了多种均衡策略，默认为random随机调用。我们还可以自行扩展负载均衡策略（参考DubboSPI机制）。\r\n\r\n在Dubbo中，所有负载均衡实现类均继承自AbstractLoadBalance，该类实现了LoadBalance接口，并封装了一些公共的逻辑。\r\n\r\n```java\r\npublic abstract class AbstractLoadBalance implements LoadBalance {\r\n\r\n    static int calculateWarmupWeight(int uptime, int warmup, int weight) {\r\n    }\r\n\r\n    @Override\r\n    public <T> Invoker<T> select(List<Invoker<T>> invokers, URL url, Invocation invocation) {\r\n    }\r\n\r\n    protected abstract <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation);\r\n\r\n    int getWeight(Invoker<?> invoker, Invocation invocation) {\r\n\r\n    }\r\n}\r\n```\r\n\r\nAbstractLoadBalance的实现类有下面这些：\r\n\r\n![img](https://oss.javaguide.cn/java-guide-blog/image-20210326105257812.png)\r\n\r\n\r\n\r\n#### RandomLoadBalance\r\n\r\n根据权重随机选择（对加权随机算法的实现）。这是Dubbo默认采用的一种负载均衡策略。\r\n\r\nRandomLoadBalance具体的实现原理非常简单，假如有两个提供相同服务的服务器S1,S2，S1的权重为7，S2的权重为3。\r\n\r\n我们把这些权重值分布在坐标区间会得到：S1->[0,7)，S2->[7,10)。我们生成[0,10)之间的随机数，随机数落到对应的区间，我们就选择对应的服务器来处理请求。\r\n\r\n![RandomLoadBalance](https://oss.javaguide.cn/java-guide-blog/%20RandomLoadBalance.png)\r\n\r\nRandomLoadBalance的源码非常简单，简单花几分钟时间看一下。\r\n\r\n>以下源码来自Dubbomaster分支上的最新的版本2.7.9。\r\n\r\n```java\r\npublic class RandomLoadBalance extends AbstractLoadBalance {\r\n\r\n    public static final String NAME = \"random\";\r\n\r\n    @Override\r\n    protected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) {\r\n\r\n        int length = invokers.size();\r\n        boolean sameWeight = true;\r\n        int[] weights = new int[length]; \r\n        int totalWeight = 0;\r\n        // 下面这个for循环的主要作用就是计算所有该服务的提供者的权重之和totalWeight（），\r\n        // 除此之外，还会检测每个服务提供者的权重是否相同\r\n        for (int i = 0; i < length; i++) {\r\n            int weight = getWeight(invokers.get(i), invocation);\r\n            totalWeight += weight;\r\n            weights[i] = totalWeight;\r\n            if (sameWeight && totalWeight != weight * (i + 1)) {\r\n                sameWeight = false;\r\n            }\r\n        }\r\n        if (totalWeight > 0 && !sameWeight) {\r\n            // 随机生成一个[0,totalWeight)区间内的数字\r\n            int offset = ThreadLocalRandom.current().nextInt(totalWeight);\r\n            // 判断会落在哪个服务提供者的区间\r\n            for (int i = 0; i < length; i++) {\r\n                if (offset < weights[i]) {\r\n                    return invokers.get(i);\r\n                }\r\n            }\r\n  \r\n        return invokers.get(ThreadLocalRandom.current().nextInt(length));\r\n    }\r\n\r\n}\r\n```\r\n\r\n#### LeastActiveLoadBalance\r\n\r\nLeastActiveLoadBalance直译过来就是**最小活跃数负载均衡**。\r\n\r\n这个名字起得有点不直观，不仔细看官方对活跃数的定义，你压根不知道这玩意是干嘛的。\r\n\r\n我这么说吧！初始状态下所有服务提供者的活跃数均为0（每个服务提供者的中特定方法都对应一个活跃数，我在后面的源码中会提到），每收到一个请求后，对应的服务提供者的活跃数+1，当这个请求处理完之后，活跃数-1。\r\n\r\n因此，**Dubbo就认为谁的活跃数越少，谁的处理速度就越快，性能也越好，这样的话，我就优先把请求给活跃数少的服务提供者处理。**\r\n\r\n**如果有多个服务提供者的活跃数相等怎么办？**\r\n\r\n很简单，那就再走一遍RandomLoadBalance。\r\n\r\n```java\r\npublic class LeastActiveLoadBalance extends AbstractLoadBalance {\r\n\r\n    public static final String NAME = \"leastactive\";\r\n\r\n    @Override\r\n    protected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) {\r\n        int length = invokers.size();\r\n        int leastActive = -1;\r\n        int leastCount = 0;\r\n        int[] leastIndexes = new int[length];\r\n        int[] weights = new int[length];\r\n        int totalWeight = 0;\r\n        int firstWeight = 0;\r\n        boolean sameWeight = true;\r\n        // 这个for循环的主要作用是遍历invokers列表，找出活跃数最小的Invoker\r\n        // 如果有多个Invoker具有相同的最小活跃数，还会记录下这些Invoker在invokers集合中的下标，并累加它们的权重，比较它们的权重值是否相等\r\n        for (int i = 0; i < length; i++) {\r\n            Invoker<T> invoker = invokers.get(i);\r\n            // 获取invoker对应的活跃(active)数\r\n            int active = RpcStatus.getStatus(invoker.getUrl(), invocation.getMethodName()).getActive();\r\n            int afterWarmup = getWeight(invoker, invocation);\r\n            weights[i] = afterWarmup;\r\n            if (leastActive == -1 || active < leastActive) {\r\n                leastActive = active;\r\n                leastCount = 1;\r\n                leastIndexes[0] = i;\r\n                totalWeight = afterWarmup;\r\n                firstWeight = afterWarmup;\r\n                sameWeight = true;\r\n            } else if (active == leastActive) {\r\n                leastIndexes[leastCount++] = i;\r\n                totalWeight += afterWarmup;\r\n                if (sameWeight && afterWarmup != firstWeight) {\r\n                    sameWeight = false;\r\n                }\r\n            }\r\n        }\r\n       // 如果只有一个Invoker具有最小的活跃数，此时直接返回该Invoker即可\r\n        if (leastCount == 1) {\r\n            return invokers.get(leastIndexes[0]);\r\n        }\r\n        // 如果有多个Invoker具有相同的最小活跃数，但它们之间的权重不同\r\n        // 这里的处理方式就和RandomLoadBalance一致了\r\n        if (!sameWeight && totalWeight > 0) {\r\n            int offsetWeight = ThreadLocalRandom.current().nextInt(totalWeight);\r\n            for (int i = 0; i < leastCount; i++) {\r\n                int leastIndex = leastIndexes[i];\r\n                offsetWeight -= weights[leastIndex];\r\n                if (offsetWeight < 0) {\r\n                    return invokers.get(leastIndex);\r\n                }\r\n            }\r\n        }\r\n        return invokers.get(leastIndexes[ThreadLocalRandom.current().nextInt(leastCount)]);\r\n    }\r\n}\r\n```\r\n\r\n活跃数是通过RpcStatus中的一个ConcurrentMap保存的，根据URL以及服务提供者被调用的方法的名称，我们便可以获取到对应的活跃数。也就是说服务提供者中的每一个方法的活跃数都是互相独立的。\r\n\r\n```java\r\npublic class RpcStatus {\r\n    \r\n    private static final ConcurrentMap<String, ConcurrentMap<String, RpcStatus>> METHOD_STATISTICS =\r\n            new ConcurrentHashMap<String, ConcurrentMap<String, RpcStatus>>();\r\n\r\n   public static RpcStatus getStatus(URL url, String methodName) {\r\n        String uri = url.toIdentityString();\r\n        ConcurrentMap<String, RpcStatus> map = METHOD_STATISTICS.computeIfAbsent(uri, k -> new ConcurrentHashMap<>());\r\n        return map.computeIfAbsent(methodName, k -> new RpcStatus());\r\n    }\r\n    public int getActive() {\r\n        return active.get();\r\n    }\r\n\r\n}\r\n```\r\n\r\n#### ConsistentHashLoadBalance\r\n\r\nConsistentHashLoadBalance小伙伴们应该也不会陌生，在分库分表、各种集群中就经常使用这个负载均衡策略。\r\n\r\nConsistentHashLoadBalance即**一致性Hash负载均衡策略**。ConsistentHashLoadBalance中没有权重的概念，具体是哪个服务提供者处理请求是由你的请求的参数决定的，也就是说相同参数的请求总是发到同一个服务提供者。\r\n\r\n![img](https://oss.javaguide.cn/java-guide-blog/consistent-hash-data-incline.jpg)\r\n\r\n另外，Dubbo为了避免数据倾斜问题（节点不够分散，大量请求落到同一节点），还引入了虚拟节点的概念。通过虚拟节点可以让节点更加分散，有效均衡各个节点的请求量。\r\n\r\n![img](https://oss.javaguide.cn/java-guide-blog/consistent-hash-invoker.jpg)\r\n\r\n官方有详细的[源码分析](https://dubbo.apache.org/zh/docs/v2.7/dev/source/loadbalance/#23-consistenthashloadbalance)。这里还有一个相关的[PR#5440](https://github.com/apache/dubbo/pull/5440)来修复老版本中ConsistentHashLoadBalance存在的一些Bug。感兴趣的小伙伴，可以多花点时间研究一下。\r\n\r\n#### RoundRobinLoadBalance\r\n\r\n加权轮询负载均衡。\r\n\r\n轮询就是把请求依次分配给每个服务提供者。加权轮询就是在轮询的基础上，让更多的请求落到权重更大的服务提供者上。比如假如有两个提供相同服务的服务器S1,S2，S1的权重为7，S2的权重为3。\r\n\r\n如果我们有10次请求，那么7次会被S1处理，3次被S2处理。\r\n\r\n但是，如果是RandomLoadBalance的话，很可能存在10次请求有9次都被S1处理的情况（概率性问题）。\r\n\r\nDubbo中的RoundRobinLoadBalance的代码实现被修改重建了好几次，Dubbo-2.6.5版本的RoundRobinLoadBalance为平滑加权轮询算法。\r\n\r\n## Dubbo序列化协议\r\n\r\n### Dubbo支持哪些序列化方式呢？\r\n\r\n![img](https://oss.javaguide.cn/github/javaguide/csdn/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MzM3Mjcy,size_16,color_FFFFFF,t_70-20230309234143460.png)\r\n\r\nDubbo支持多种序列化方式：JDK自带的序列化、hessian2、JSON、Kryo、FST、Protostuff，ProtoBuf等等。\r\n\r\nDubbo默认使用的序列化方式是hessian2。\r\n\r\n### 谈谈你对这些序列化协议了解？\r\n\r\n一般我们不会直接使用JDK自带的序列化方式。主要原因有两个：\r\n\r\n1. **不支持跨语言调用**:如果调用的是其他语言开发的服务的时候就不支持了。\r\n2. **性能差**：相比于其他序列化框架性能更低，主要原因是序列化之后的字节数组体积较大，导致传输成本加大。\r\n\r\nJSON序列化由于性能问题，我们一般也不会考虑使用。\r\n\r\n像Protostuff，ProtoBuf、hessian2这些都是跨语言的序列化方式，如果有跨语言需求的话可以考虑使用。\r\n\r\nKryo和FST这两种序列化方式是Dubbo后来才引入的，性能非常好。不过，这两者都是专门针对Java语言的。Dubbo官网的一篇文章中提到说推荐使用Kryo作为生产环境的序列化方式。([文章地址](https://dubbo.apache.org/zh/docs/v2.7/user/references/protocol/rest/))\r\n\r\n![img](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2020-8/569e541a-22b2-4846-aa07-0ad479f07440.png)\r\n\r\nDubbo官方文档中还有一个关于这些[序列化协议的性能对比图](https://dubbo.apache.org/zh/docs/v2.7/user/serialization/#m-zhdocsv27userserialization)可供参考。\r\n\r\n![img](https://oscimg.oschina.net/oscnet/up-00c3ce1e5d222e477ed84310239daa2f6b0.png)\r\n\r\n> [原文链接](https://javaguide.cn/distributed-system/rpc/dubbo.html)\r\n\r\n\r\n## 相关文章\r\n\r\n- [dubbo官方文档](http://dubbo.apache.org/zh-cn/docs/user/quick-start.html)\r\n- [长文图解七种负载均衡策略](https://mp.weixin.qq.com/s/jveqCUAiqKdKRoea9wESbw)\r\n- [如果Dubbo还没精通原理，就从这里开始吧](https://mp.weixin.qq.com/s/NEfWwnRVOI73_TQurmxk9A)","categories":[{"name":"技术栈","path":"api/categories/技术栈.json"}],"tags":[]}