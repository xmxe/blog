{"title":"Nginx","slug":"Nginx","date":"2022-09-27T07:51:22.667Z","updated":"2024-11-11T01:53:31.013Z","comments":true,"path":"api/articles/Nginx.json","excerpt":null,"covers":"https://picx1.zhimg.com/v2-e68d524210343613129267bd2cb75a0d_1440w.jpg","content":"\r\n\r\n## Nginx安装\r\n\r\n### 离线安装\r\n\r\n**下载**\r\n\r\n```shell\r\n# 下载nginx:\r\nwget http://nginx.org/download/nginx-1.8.1.tar.gz\r\n# 下载openssl:\r\nwget https://www.openssl.org/source/openssl-fips-2.0.16.tar.gz\r\n# 下载zlib:\r\nwget http://www.zlib.net/zlib-1.2.11.tar.gz\r\n# 下载pcre:\r\nwget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.39.tar.gz\r\n# 如果没有安装c++编译环境，还得安装，通过```yum install gcc-c++```完成安装\r\n```\r\n\r\n**编译安装**\r\n\r\n```shell\r\n# openssl：\r\n[root@localhost] tar zxvf openssl-fips-2.0.16.tar.gz\r\n[root@localhost] cd openssl-fips-2.0.16\r\n[root@localhost] ./config && make && make install\r\n\r\n# pcre:\r\n[root@localhost] tar zxvf pcre-8.39.tar.gz\r\n[root@localhost] cd pcre-8.39\r\n[root@localhost]  ./configure && make && make install\r\n\r\n# zlib:\r\n[root@localhost]tar zxvf zlib-1.2.11.tar.gz\r\n[root@localhost] cd zlib-1.2.11\r\n[root@localhost]  ./configure && make && make install\r\n\r\n# 最后安装nginx\r\n[root@localhost]tar zxvf nginx-1.8.1.tar.gz\r\n[root@localhost] cd nginx-1.8.1\r\n[root@localhost]  ./configure && make && make install\r\n```\r\n\r\n**启动nginx**\r\n\r\n```shell\r\n/usr/local/nginx/sbin/nginx\r\n/usr/local/nginx/sbin/nginx -s stop # 立即停止nginx，不保存相关信息\r\n/usr/local/nginx/sbin/nginx -s quit  # 正常退出nginx，保存相关信息\r\n/usr/local/nginx/sbin/nginx -s reload # 重启\r\n```\r\n> [Linux安装Nginx详细图解教程](https://www.cnblogs.com/lovexinyi8/p/5845017.html)\r\n\r\n**将nginx做成系统服务并且开机自启动**\r\n\r\n由于是源码安装，需要手动创建nginx.service服务\r\n> 不止nginx，其他源码安装的想要实现开机自启动就在/lib/systemd/system目录下自定义服务即可\r\n```shell\r\nvim /lib/systemd/system/nginx.service\r\n# 编辑内容\r\n[Unit]\r\nDescription=nginx.service\r\nAfter=network.target\r\n\r\n[Service]\r\nType=forking\r\nExecStart=/usr/local/nginx/sbin/nginx\r\nExecReload=/usr/local/nginx/sbin/nginx -s reload\r\nExecStop=/usr/local/nginx/sbin/nginx -s quit\r\nPrivateTmp=true\r\n\r\n[Install]\r\nWantedBy=multi-user.target\r\n\r\n# 参数介绍：\r\n# [Unit]:服务的说明\r\n# Description:描述服务\r\n# After:描述服务类别\r\n# [Service]服务运行参数的设置\r\n# Type=forking是后台运行的形式\r\n# ExecStart为服务的具体运行命令\r\n# ExecReload为重启命令\r\n# ExecStop为停止命令\r\n# PrivateTmp=True表示给服务分配独立的临时空间\r\n# 注意：[Service]的启动、重启、停止命令全部要求使用绝对路径\r\n# [Install]运行级别下服务安装的相关设置，可设置为多用户，即系统运行级别为3\r\n```\r\n:wq! 保存退出。\r\n```shell\r\n# 设置开机启动\r\nsystemctl enable nginx.service\r\n# 其他命令\r\n# 启动nginx服务\r\nsystemctl start nginx.service　\r\n# 停止开机自启动\r\nsystemctl disable nginx.service\r\n# 查看服务当前状态\r\nsystemctl status nginx.service\r\n# 重新启动服务\r\nsystemctl restart nginx.service　\r\n# 查看所有已启动的服务\r\nsystemctl list-units --type=service\r\n```\r\n\r\n### 在线安装\r\n\r\n**下载**\r\n\r\n[官网地址](https://nginx.org)\r\n\r\n**安装依赖**\r\n\r\n```shell\r\nyum -y install gcc zlib zlib-devel pcre-devel openssl openssl-devel\r\n```\r\n\r\n**安装**\r\n\r\n- 创建一个文件夹,上传本地提供的nginx包\r\n```shell\r\nif [ ! -d \"/root/software\" ]; then\r\nmkdir -p /root/software\r\nfi && cd /root/software && rz\r\n```\r\n\r\n- 解压\r\n```shell\r\ntar -zxvf nginx-1.18.0.tar.gz && cd nginx-1.18.0\r\n```\r\n\r\n- 配置、编译、安装\r\n```shell\r\n./configure && make && make install\r\n```\r\n\r\n- 检查是否安装成功\r\n```shell\r\nwhereis nginx\r\ncd /usr/local/nginx/sbin && ./nginx\r\nps -ef | grep nginx\r\n```\r\n\r\n- 启动代码格式：nginx安装目录地址 -c nginx配置文件地址\r\n```shell\r\n/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf\r\n```\r\n\r\n- 热加载\r\n```shell\r\n/usr/local/nginx/sbin/nginx -s reload\r\n```\r\n\r\n### Nginx安装手册\r\n**nginx安装环境**\r\n\r\nnginx是C语言开发，建议在linux上运行，本教程使用Centos6.5作为安装环境。\r\n\r\n- gcc。安装nginx需要先将官网下载的源码进行编译，编译依赖gcc环境，如果没有gcc环境，需要安装gcc：`yum install gcc-c++`\r\n\r\n- PCRE。PCRE(Perl Compatible Regular Expressions)是一个Perl库，包括perl兼容的正则表达式库。nginx的http模块使用pcre来解析正则表达式，所以需要在linux上安装pcre库。`yum install -y pcre pcre-devel`\r\n> pcre-devel是使用pcre开发的一个二次开发库。nginx也需要此库。\r\n\r\n- zlib\r\nzlib库提供了很多种压缩和解压缩的方式，nginx使用zlib对http包的内容进行gzip，所以需要在linux上安装zlib库。`yum install -y zlib zlib-devel`\r\n\r\n- openssl\r\nOpenSSL是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及SSL协议，并提供丰富的应用程序供测试或其它目的使用。nginx不仅支持http协议，还支持https（即在ssl协议上传输http），所以需要在linux安装openssl库。`yum install -y openssl openssl-devel`\r\n\r\n**编译安装**\r\n\r\n将nginx-1.8.0.tar.gz拷贝至linux服务器。\r\n```shell\r\n# 解压\r\ntar -zxvf nginx-1.8.0.tar.gz\r\ncd nginx-1.8.0\r\n```\r\n1. configure：`./configure --help`查询详细参数（参考本教程附录部分：nginx编译参数）注意：上边将临时文件目录指定为/var/temp/nginx，需要在/var下创建temp及nginx目录,参数设置如下：\r\n```config\r\n./configure \\\r\n--prefix=/usr/local/nginx \\\r\n--pid-path=/var/run/nginx/nginx.pid \\\r\n--lock-path=/var/lock/nginx.lock \\\r\n--error-log-path=/var/log/nginx/error.log \\\r\n--http-log-path=/var/log/nginx/access.log \\\r\n--with-http_gzip_static_module \\\r\n--http-client-body-temp-path=/var/temp/nginx/client \\\r\n--http-proxy-temp-path=/var/temp/nginx/proxy \\\r\n--http-fastcgi-temp-path=/var/temp/nginx/fastcgi \\\r\n--http-uwsgi-temp-path=/var/temp/nginx/uwsgi \\\r\n--http-scgi-temp-path=/var/temp/nginx/scgi\r\n```\r\n注意：上边将临时文件目录指定为/var/temp/nginx，需要在/var下创建temp及nginx目录\r\n2. 编译安装\r\n```shell\r\nmake\r\nmake install\r\n```\r\n\r\n3. 启动nginx\r\n```shell\r\ncd /usr/local/nginx/sbin/\r\n./nginx\r\n```\r\n查询nginx进程：`ps aux|grep nginx`。注意：执行./nginx启动nginx，这里可以-c指定加载的nginx配置文件，如下：\r\n```nginx\r\n./nginx -c /usr/local/nginx/conf/nginx.conf\r\n```\r\n如果不指定-c，nginx在启动时默认加载conf/nginx.conf文件，此文件的地址也可以在编译安装nginx时指定./configure的参数（--conf-path=指向配置文件（nginx.conf））\r\n4. 停止nginx。\r\n```shell\r\n# 方式1，快速停止：\r\ncd /usr/local/nginx/sbin\r\n./nginx -s stop\r\n```\r\n此方式相当于先查出nginx进程id再使用kill命令强制杀掉进程。\r\n```shell\r\n# 方式2，完整停止(建议使用)：\r\ncd /usr/local/nginx/sbin\r\n./nginx -s quit\r\n```\r\n此方式停止步骤是待nginx进程处理任务完毕进行停止。\r\n5. 重启nginx。\r\n方式1，先停止再启动（建议使用）：对nginx进行重启相当于先停止nginx再启动nginx，即先执行停止命令再执行启动命令。如下：\r\n```shell\r\n./nginx -s quit\r\n./nginx\r\n```\r\n方式2，重新加载配置文件：当nginx的配置文件nginx.conf修改后，要想让配置生效需要重启nginx，使用`-s reload`不用先停止nginx再启动nginx即可将配置信息在nginx中生效，如下：\r\n```shell\r\n./nginx -s reload\r\n```\r\n6. 测试。nginx安装成功，启动nginx，即可访问虚拟机上的nginx：到这说明nginx上安装成功。\r\n\r\n7. 开机自启动nginx\r\n\r\n**编写shell脚本**,这里使用的是编写shell脚本的方式来处理`vi /etc/init.d/nginx`(输入下面的代码)\r\n```bash\r\n#!/bin/bash\r\n# nginx Startup script for the Nginx HTTP Server\r\n# it is v.0.0.2 version.\r\n# chkconfig: - 85 15\r\n# description: Nginx is a high-performance web and proxy server.\r\n# It has a lot of features, but it's not for everyone.\r\n# processname: nginx\r\n# pidfile: /var/run/nginx.pid\r\n# config: /usr/local/nginx/conf/nginx.conf\r\nnginxd=/usr/local/nginx/sbin/nginx\r\nnginx_config=/usr/local/nginx/conf/nginx.conf\r\nnginx_pid=/var/run/nginx.pid\r\nRETVAL=0\r\nprog=\"nginx\"\r\n# Source function library.\r\n. /etc/rc.d/init.d/functions\r\n# Source networking configuration.\r\n. /etc/sysconfig/network\r\n# Check that networking is up.\r\n[ ${NETWORKING} = \"no\" ] && exit 0\r\n[ -x $nginxd ] || exit 0\r\n# Start nginx daemons functions.\r\nstart() {\r\nif [ -e $nginx_pid ];then\r\n echo \"nginx already running....\"\r\n exit 1\r\nfi\r\n echo -n $\"Starting $prog: \"\r\n daemon $nginxd -c ${nginx_config}\r\n RETVAL=$?\r\n echo\r\n [ $RETVAL = 0 ] && touch /var/lock/subsys/nginx\r\n return $RETVAL\r\n}\r\n# Stop nginx daemons functions.\r\nstop() {\r\n echo -n $\"Stopping $prog: \"\r\n killproc $nginxd\r\n RETVAL=$?\r\n echo\r\n [ $RETVAL = 0 ] && rm -f /var/lock/subsys/nginx /var/run/nginx.pid\r\n}\r\n# reload nginx service functions.\r\nreload() {\r\n echo -n $\"Reloading $prog: \"\r\n #kill -HUP `cat ${nginx_pid}`\r\n killproc $nginxd -HUP\r\n RETVAL=$?\r\n echo\r\n}\r\n# See how we were called.\r\ncase \"$1\" in\r\nstart)\r\n start\r\n ;;\r\nstop)\r\n stop\r\n ;;\r\nreload)\r\n reload\r\n ;;\r\nrestart)\r\n stop\r\n start\r\n ;;\r\nstatus)\r\n status $prog\r\n RETVAL=$?\r\n ;;\r\n*)\r\n echo $\"Usage: $prog {start|stop|restart|reload|status|help}\"\r\n exit 1\r\nesac\r\nexit $RETVAL\r\n```\r\n:wq保存并退出\r\n**设置文件的访问权限**\r\n\r\n```shell\r\nchmod a+x /etc/init.d/nginx #(a+x ==> all user can execute 所有用户可执行)\r\n```\r\n这样在控制台就很容易的操作nginx了：查看Nginx当前状态、启动Nginx、停止Nginx、重启Nginx…如果修改了nginx的配置文件nginx.conf，也可以使用上面的命令重新加载新的配置文件并运行，可以将此命令加入到rc.local文件中，这样开机的时候nginx就默认启动了\r\n**加入到rc.local文件中**\r\n\r\n```shell\r\nvi /etc/rc.local\r\n```\r\n加入一行`/etc/init.d/nginx start`保存并退出，下次重启会生效。\r\n\r\n## Nginx语法与变量\r\n\r\n### 语法规则\r\n\r\nlocation [= | \\~ | \\~\\* | ^\\~ ] /uri/ { … }\r\n\r\n- =：表示精确匹配,这个优先级也是最高的\r\n- ^\\~：表示uri以某个常规字符串开头，理解为匹配url路径即可。nginx不对url做编码，因此请求为/static/20%/aa，可以被规则^~ /static/ /aa匹配到（注意是空格）。\r\n- \\~：表示区分大小写的正则匹配\r\n- \\~\\*：表示不区分大小写的正则匹配(和上面的唯一区别就是大小写)\r\n- !\\~和!\\~\\*：分别为区分大小写不匹配及不区分大小写不匹配的正则\r\n- /：通用匹配，任何请求都会匹配到，默认匹配.\r\n\r\n**语法的一些规则和优先级**\r\n多个location配置的情况下匹配顺序为：首先匹配=，其次匹配^\\~,其次是按文件中顺序的正则匹配，最后是交给/通用匹配。当有匹配成功时候，停止匹配，按当前匹配规则处理请求。\r\n\r\n#### 正则匹配\r\n\r\n- ^ 以什么开始\r\n- \\$ 以什么结束\r\n- \\~ 区分大小写匹配\r\n- \\~\\* 不区分大小写匹配\r\n\r\n```nginx\r\n# ^/api/user$\r\n# 匹配任何以/uri/开头的任务查询并且停止搜索\r\nlocation ^~ /uri/\r\n```\r\n\r\n#### 精准匹配\r\n\r\n```nginx\r\n# =:表示精准匹配,只要完全匹配才能生效\r\nlocation= /uri\r\n```\r\n\r\n#### 前缀匹配\r\n\r\n不带任务修饰符,表示前缀匹配\r\n\r\n#### 通用匹配\r\n\r\n任务未匹配到其他location的请求都会匹配到\r\n\r\n```nginx\r\nlocation /\r\n```\r\n\r\n#### 优先级\r\n\r\n精准匹配>前缀匹配(若有多个匹配荐匹配成功,那么选择匹配长的并记录)>正则匹配\r\n\r\n#### 案例\r\n\r\n```nginx\r\nserver {\r\n    server_name xdclass.net;\r\n    location ~^/api/pub$ {\r\n    ...\r\n    }\r\n}\r\n# ^/api/pub\\$这个正则表达式表示字符串必须以/开始，以b\\$结束，中间必须是/api/pub\r\n# http://xdclass.net/api/v1 匹配（完全匹配）\r\n# http://xdclass.net/API/PUB 不匹配，大小写敏感\r\n# http://xdclass.net/api/pub?key1=value1 匹配\r\n# http://xdclass.net/api/pub/ 不匹配\r\n# http://xdclass.net/api/public 不匹配，不能匹配正则表达式\r\n```\r\n\r\n#### nginx判断\r\n\r\n1、正则表达式匹配：\r\n\r\n==：等值比较;\r\n\\~：与指定正则表达式模式匹配时返回“真”，判断匹配与否时区分字符大小写；\r\n\\~\\*：与指定正则表达式模式匹配时返回“真”，判断匹配与否时不区分字符大小写；\r\n!\\~：与指定正则表达式模式不匹配时返回“真”，判断匹配与否时区分字符大小写；\r\n!\\~\\*：与指定正则表达式模式不匹配时返回“真”，判断匹配与否时不区分字符大小写；\r\n\r\n2、文件及目录匹配判断：\r\n\r\n-f, !-f：判断指定的路径是否为存在且为文件；\r\n-d, !-d：判断指定的路径是否为存在且为目录；\r\n-e, !-e：判断指定的路径是否存在，文件或目录均可；\r\n-x, !-x：判断指定路径的文件是否存在且可执行；\r\n\r\n#### if语法\r\n\r\n- 语法：if (condition) { … }\r\n- 默认值：none\r\n- 使用字段：server, location\r\n- 注意：尽量考虑使用trp_files代替。\r\n- 判断的条件可以有以下值：\r\n\r\n1. 一个变量的名称：空字符传”“或者一些“0”开始的字符串为false。\r\n2. 字符串比较：使用=或!=运算符\r\n3. 正则表达式匹配：使用\\~(区分大小写)和\\~\\*(不区分大小写)，取反运算!\\~和!\\~\\*。\r\n4. 文件是否存在：使用-f和!-f操作符\r\n5. 目录是否存在：使用-d和!-d操作符\r\n7. 文件、目录、符号链接是否存在：使用-e和!-e操作符\r\n8. 文件是否可执行：使用-x和!-x操作符\r\n\r\n#### return\r\n\r\n- 语法：return code\r\n- 默认值：none\r\n- 使用字段：server,location,if\r\n- nginx隐藏版本号\r\n- nginx.conf中修改http zone中的变量值： server_tokens off;\r\n- php-fpm fastcgi.conf中的变量值： fastcgi_param SERVER_SOFTWARE nginx;\r\n\r\n#### nginx正向代理\r\n\r\n```nginx\r\nserver {\r\n    listen 8090;\r\n    location / {\r\n        resolver 218.85.157.99 218.85.152.99;\r\n        resolver_timeout 30s;\r\n        proxy_pass http://$host$request_uri;\r\n    }\r\n    access_log /data/httplogs/proxy-$host-aceess.log;\r\n}\r\n```\r\n\r\nresolver指令\r\n\r\n- 语法: resolver address ... [valid=time];\r\n- 默认值: —\r\n- 配置段: http, server, location\r\n- 配置DNS服务器IP地址。可以指定多个，以轮询方式请求。\r\n- nginx会缓存解析的结果。默认情况下，缓存时间是名字解析响应中的TTL字段的值，可以通过valid参数更改。\r\n\r\n### 变量\r\n\r\n#### ngx_http_core_module模块的变量\r\n\r\n- **$arg_PARAMETER**：HTTP请求中某个参数的值，如/index.php?site=www.domain.com 可以用$arg_site取得www.domain.com 这个值。\r\n- **$args HTTP**：请求中的完整参数。例如，在请求/index.php?width=400&height=200中，$args表示字符串width=400&height=200.\r\n- **$binary_remote_addr**：二进制格式的客户端地址。例如：\\x0A\\xE0B\\x0E\r\n- **$body_bytes_sent**：表示在向客户端发送的http响应中，包体部分的字节数\r\n- **$content_length**：表示客户端请求头部中的Content-Length字段\r\n- **$content_type**：表示客户端请求头部中的Content-Type字段\r\n- **$cookie_COOKIE**：表示在客户端请求头部中的cookie字段\r\n- **$document_root**：表示当前请求所使用的root配置项的值\r\n- **$uri**：表示当前请求的URI，不带任何参数\r\n- **$document_uri与$uri含义相同**\r\n- **$request_uri**：表示客户端发来的原始请求URI，带完整的参数。$uri和$document_uri未必是用户的原始请求，在内部重定向后可能是重定向后的URI，而$request_uri永远不会改变，始终是客户端的原始URI\r\n- **$host**：表示客户端请求头部中的Host字段。如果Host字段不存在，则以实际处理的server（虚拟主机）名称代替。如果Host字段中带有端口，如IP:PORT，那么$host是去掉端口的，它的值为IP。$host是全小写的。这些特性与http_HEADER中的http_host不同，http_host只取出Host头部对应的值。\r\n- **$hostname**：表示Nginx所在机器的名称，与gethostbyname调用返回的值相同\r\n- **$http_HEADER**：表示当前HTTP请求中相应头部的值。HEADER名称全小写。例如，示请求中Host头部对应的值用$http_host表\r\n- **$sent_http_HEADER**：表示返回客户端的HTTP响应中相应头部的值。HEADER名称全小写。例如，用$sent_http_content_type表示响应中Content-Type头部对应的值\r\n- **$is_args**：表示请求中的URI是否带参数，如果带参数，$is_args值为?，如果不带参数，则是空字符串\r\n- **$limit_rate**：表示当前连接的限速是多少，0表示无限速\r\n- **$nginx_version**：表示当前Nginx的版本号\r\n- **$query_string**：请求URI中的参数，与$args相同，然而$query_string是只读的不会改变\r\n- **$remote_addr**：表示客户端的地址\r\n- **$remote_port**：表示客户端连接使用的端口\r\n- **$remote_user**：表示使用Auth Basic Module时定义的用户名\r\n- **$request_filename**：表示用户请求中的URI经过root或alias转换后的文件路径\r\n- **$request_body**：表示HTTP请求中的包体，该参数只在proxy_pass或fastcgi_pass中有意义\r\n- **$request_body_file**：表示HTTP请求中的包体存储的临时文件名\r\n- **$request_completion**：当请求已经全部完成时，其值为“ok”。若没有完成，就要返回客户端，则其值为空字符串；或者在断点续传等情况下使用HTTP range访问的并不是文件的最后一块，那么其值也是空字符串。\r\n- **$request_method**：表示HTTP请求的方法名，如GET、PUT、POST等\r\n- **$scheme**：表示HTTP scheme，如在请求https://nginx.com/中表示https\r\n- **$server_addr**：表示服务器地址\r\n- **$server_name**：表示服务器名称\r\n- **$server_port**：表示服务器端口\r\n- **$server_protocol**：表示服务器向客户端发送响应的协议，如HTTP/1.1或HTTP/1.0\r\n\r\n#### 日志配置\r\n\r\n- **$remote_addr,$http_x_forwarded_for-**：记录客户端IP地址\r\n- **$remote_user**：记录客户端用户名称\r\n- **$request**：记录请求的URL和HTTP协议\r\n- **$status**：记录请求状态\r\n- **$body_bytes_sent**：发送给客户端的字节数，不包括响应头的大小；该变量与Apache模块mod_log_config里的“%B”参数兼容。\r\n- **$bytes_sent**：发送给客户端的总字节数。\r\n- **$connection**：连接的序列号。\r\n- **$connection_requests**：当前通过一个连接获得的请求数量。\r\n- **$msec**：日志写入时间。单位为秒，精度是毫秒。\r\n- **$pipe**：如果请求是通过HTTP流水线(pipelined)发送，pipe值为“p”，否则为“.”。\r\n- **$http_referer**：记录从哪个页面链接访问过来的\r\n- **$http_user_agent**：记录客户端浏览器相关信息\r\n- **$request_length**：请求的长度（包括请求行，请求头和请求正文）。\r\n- **$request_time**：请求处理时间，单位为秒，精度毫秒；从读入客户端的第一个字节开始，直到把最后一个字符发送给客户端后进行日志写入为止。\r\n- **$time_iso8601**：ISO8601标准格式下的本地时间。\r\n- **$time_local**：通用日志格式下的本地时间。\r\n\r\n## location \"/\"的作用\r\n\r\n**前置测试访问域名**：www.test.com/api/upload\r\n\r\n### location和proxy\\_pass都带/，则真实地址不带location匹配目录\r\n\r\n```nginx\r\nlocation /api/ {\r\n    proxy_pass http://127.0.0.1:8080/;\r\n}\r\n```\r\n\r\n**访问地址**：www.test.com/api/upload-->http://127.0.0.1:8080/upload\r\n\r\n### location不带/，proxy\\_pass带/，则真实地址会带/\r\n\r\n```nginx\r\nlocation /api {\r\n    proxy_pass http://127.0.0.1:8080/;\r\n}\r\n```\r\n\r\n**访问地址**：www.test.com/api/upload-->http://127.0.0.1:8080/upload\r\n\r\n### location带/，proxy\\_pass不带/，则真实地址会带location匹配目录/api/\r\n\r\n```nginx\r\nlocation /api/ {\r\n    proxy_pass http://127.0.0.1:8080;\r\n}\r\n```\r\n\r\n**访问地址**：www.test.com/api/upload-->http://127.0.0.1:8080/api/upload\r\n\r\n### location和proxy\\_pass都不带/，则真实地址会带location匹配目录/api/\r\n\r\n```nginx\r\nlocation /api {\r\n    proxy_pass http://127.0.0.1:8080;\r\n}\r\n```\r\n\r\n**访问地址**：www.test.com/api/upload-->http://127.0.0.1:8080/api/upload\r\n\r\n### location和proxy\\_pass都带/，但proxy\\_pass带地址(同1)\r\n\r\n```nginx\r\nlocation /api/ {\r\n    proxy_pass http://127.0.0.1:8080/server/;\r\n}\r\n```\r\n\r\n**访问地址**：www.test.com/api/upload-->http://127.0.0.1:8080/server/upload\r\n\r\n### location不带/，proxy\\_pass带/，但proxy\\_pass带地址，则真实地址会多个/(同2)\r\n\r\n```nginx\r\nlocation /api {\r\n    proxy_pass http://127.0.0.1:8080/server/;\r\n}\r\n```\r\n\r\n**访问地址**：www.test.com/api/upload-->http://127.0.0.1:8080/server//upload\r\n\r\n### location带/，proxy\\_pass不带/，但proxy\\_pass带地址，则真实地址会直接连起来(同3)\r\n\r\n```nginx\r\nlocation /api/ {\r\n    proxy_pass http://127.0.0.1:8080/server;\r\n}\r\n```\r\n\r\n**访问地址**：www.test.com/api/upload-->http://127.0.0.1:8080/serverupload\r\n\r\n### location和proxy\\_pass都不带/，但proxy\\_pass带地址，则真实地址匹配地址会替换location匹配目录(同4)\r\n\r\n```nginx\r\nlocation /api {\r\n    proxy_pass http://127.0.0.1:8080/server;\r\n}\r\n```\r\n\r\n**访问地址**：www.test.com/api/upload-->http://127.0.0.1:8080/server/upload\r\n\r\n### 总结\r\n\r\n1. proxy_pass代理地址端口后有目录(包括/)，转发后地址：代理地址+访问URL目录部分去除location匹配目录\r\n2. proxy_pass代理地址端口后无任何，转发后地址：代理地址+访问URL目录部\r\n\r\n\r\n## Nginx业务需求配置\r\n\r\n\r\n### Nginx设置黑/白名单IP限制\r\n\r\n**第一种方法:allow、deny**\r\n\r\ndeny和allow指令属于ngx_http_access_module，nginx默认加载此模块，所以可直接使用。这种方式，最简单，最直接。设置类似防火墙iptable，使用方法：直接配置文件中添加：\r\n```nginx\r\n# 白名单设置，allow后面为可访问IP\r\nlocation / {\r\n     allow 123.13.123.12;\r\n     allow 23.53.32.1/100;\r\n     deny  all;\r\n}\r\n\r\n# 黑名单设置，deny后面接限制的IP，为什么不加allow all?因为这个默认是开启的\r\nlocation / {\r\n     deny 123.13.123.12;\r\n}\r\n\r\n# 白名单，特定目录访问限制\r\nlocation /tree/list {\r\n     allow 123.13.123.12;\r\n     deny all;\r\n}\r\n```\r\n\r\n或者通过读取文件IP配置白名单\r\n\r\n```nginx\r\nlocation /{\r\n    include /home/whitelist.conf;\r\n    # 默认位置路径为/etc/nginx/下，\r\n    # 如直接写include whitelist.conf，则只需要在/etc/nginx目录下创建whitelist.conf\r\n    deny all;\r\n}\r\n```\r\n\r\n在/home/目录下创建whitelist.conf，并写入需要加入白名单的IP，添加完成后查看如下：\r\n\r\n```shell\r\ncat /home/whitelist.conf\r\n\r\n# 白名单IP\r\nallow 10.1.1.10;\r\nallow 10.1.1.11;\r\n```\r\n\r\n白名单设置完成，黑名单设置方法一样。\r\n\r\n**第二种方法:ngx_http_geo_module**\r\n\r\n默认情况下，一般nginx是有加该模块的，[ngx_http_geo_module官方文档](https://nginx.org/en/docs/http/ngx_http_geo_module.html)。参数需设置在位置在http模块中。此模块可设置IP限制，也可设置国家地区限制。位置在server模块外即可。语法示例：配置文件直接添加\r\n\r\n```nginx\r\ngeo $ip_list {\r\n    default 0;\r\n    # 设置默认值为0\r\n    192.168.1.0/24 1;\r\n    10.1.0.0/16    1;\r\n}\r\nserver {\r\n   listen       8081;\r\n   server_name  192.168.152.100;\r\n\r\n   location / {\r\n       root   /var/www/test;\r\n       index  index.html index.htm index.php;\r\n       if ( $ip_list = 0 ) {\r\n           # 判断默认值，如果值为0，可访问，这时上面添加的IP为黑名单。\r\n           # 白名单，将设置$ip_list = 1，这时上面添加的IP为白名单。\r\n           proxy_pass http://192.168.152.100:8081;\r\n        }\r\n    }\r\n\r\n}\r\n```\r\n\r\n同样可通过读取文件IP配置\r\n\r\n```nginx\r\ngeo $ip_list {\r\n    default 0;\r\n    #设置默认值为0\r\n    include ip_white.conf;\r\n}\r\nserver {\r\n    listen       8081;\r\n    server_name  192.168.152.100;\r\n\r\n    location / {\r\n        root   /var/www/test;\r\n        index  index.html index.htm index.php;\r\n        if ( $ip_list = 0 ) {\r\n            return 403;\r\n            # 限制的IP返回值为403，也可以设置为503，504其他值。\r\n            # 建议设置503，504这样返回的页面不会暴露nginx相关信息，限制的IP看到的信息只显示服务器错误，无法判断真正原因。\r\n        }\r\n    }\r\n}\r\n```\r\n在/etc/nginx目录下创建ip_list.conf，添加IP完成后，查看如下：\r\n\r\n```shell\r\ncat /etc/nginx/ip_list.conf\r\n\r\n192.168.152.1 1;\r\n192.168.150.0/24 1;\r\n```\r\n\r\n设置完成，ip_list.conf的IP为白名单，不在名单中的，直接返回403页面。黑名单设置方法相同。\r\n\r\n**ngx_http_geo_module负载均衡（扩展）**\r\n\r\nngx_http_geo_module，模块还可以做负载均衡使用，如web集群在不同地区都有服务器，某个地区IP段，负载均衡至访问某个地区的服务器。方式类似，IP后面加上自定义值，不仅仅数字，如US,CN等字母。示例：如果三台服务器：122.11.11.11，133.11.12.22，144.11.11.33\r\n\r\n```nginx\r\ngeo $country {\r\n    default default;\r\n    111.11.11.0/24   uk;\r\n    # IP段定义值uk\r\n    111.11.12.0/24   us;\r\n    # IP段定义值us\r\n    }\r\nupstream  uk.server {\r\n    erver 122.11.11.11:9090;\r\n    # 定义值uk的IP直接访问此服务器\r\n}\r\n\r\nupstream  us.server {\r\n    server 133.11.12.22:9090;\r\n    # 定义值us的IP直接访问此服务器\r\n}\r\n\r\nupstream  default.server {\r\n    server 144.11.11.33:9090;\r\n    #默认的定义值default的IP直接访问此服务器\r\n}\r\n\r\nserver {\r\n    listen    9090;\r\n    server_name 144.11.11.33;\r\n\r\n    location / {\r\n      root  /var/www/html/;\r\n      index index.html index.htm;\r\n     }\r\n }\r\n```\r\n\r\n### 国家城市IP访问限制\r\n\r\n有些第三方也提供设置，如cloudflare，设置更简单，防火墙规则里设置。这里讲讲nginx的设置方法。\r\n\r\n**安装ngx_http_geoip_module模块**\r\n\r\n[ngx_http_geoip_module官方文档](https://nginx.org/en/docs/http/ngx_http_geoip_module.html)，参数需设置在位置在http模块中。nginx默认情况下不构建此模块，应使用`--with-http_geoip_module`配置参数启用它。对于ubuntu系统来说，直接安装nginx-extras组件，包括几乎所有的模块。\r\n\r\n```shell\r\nsudo apt install nginx-extras\r\n```\r\n\r\n对于centos系统，安装模块。\r\n\r\n```shell\r\nyum install nginx-module-geoip\r\n```\r\n\r\n**下载IP数据库**\r\n\r\n此模块依赖于IP数据库，所有数据在此数据库中读取，所有还需要下载ip库（dat格式）。MaxMind提供了免费的IP地域数据库，坏消息是MaxMind官方已经停止支持dat格式的ip库。在其他地方可以找到dat格式的文件，或者老版本的，当然数据不可能最新，多少有误差。\r\n\r\n> 第三方下载地址：https://www.miyuru.lk/geoiplegacy\r\n\r\n下载同时包括Ipv4和Ipv6的country、city版本。\r\n\r\n```shell\r\n# 下载国家IP库，解压并移动到nginx配置文件目录，\r\nsudo wget https://dl.miyuru.lk/geoip/maxmind/country/maxmind.dat.gz\r\ngunzip maxmind.dat.gz\r\nsudo mv maxmind.dat /etc/nginx/GeoCountry.dat\r\n\r\nsudo wget https://dl.miyuru.lk/geoip/maxmind/city/maxmind.dat.gz\r\ngunzip maxmind.dat.gz\r\nsudo mv maxmind.dat /etc/nginx/GeoCity.dat\r\n```\r\n\r\n**配置nginx**\r\n\r\n示例：\r\n\r\n```nginx\r\ngeoip_country /etc/nginx/GeoCountry.dat;\r\ngeoip_city /etc/nginx/GeoCity.dat;\r\n\r\nserver {\r\n    listen  80;\r\n    server_name 144.11.11.33;\r\n\r\n    location / {\r\n      root  /var/www/html/;\r\n      index index.html index.htm;\r\n      if ($geoip_country_code = CN) {\r\n         return 403;\r\n       # 中国地区，拒绝访问。返回403页面\r\n      }\r\n   }\r\n }\r\n```\r\n这里，地区国家基础设置就完成了。\r\n\r\nGeoip其他参数：\r\n\r\n- 国家相关参数：\r\n\r\n```nginx\r\n$geoip_country_code # 两位字符的英文国家码。如：CN,US\r\n$geoip_country_code3 # 三位字符的英文国家码。如：CHN,USA\r\n$geoip_country_name # 国家英文全称。如：China,United States\r\n```\r\n\r\n- 城市相关参数：\r\n\r\n```nginx\r\n$geoip_city_country_code # 也是两位字符的英文国家码。\r\n$geoip_city_country_code3 # 上同\r\n$geoip_city_country_name # 上同.\r\n$geoip_region # 这个经测试是两位数的数字，如杭州是02,上海是23。但是没有搜到相关资料，希望知道的朋友留言告之。\r\n$geoip_city # 城市的英文名称。如：Hangzhou\r\n$geoip_postal_code # 城市的邮政编码。经测试，国内这字段为空\r\n$geoip_city_continent_code # 不知什么用途，国内好像都是AS\r\n$geoip_latitude # 纬度\r\n$geoip_longitude # 经度\r\n```\r\n\r\n### 封禁恶意ip\r\n\r\n单独网站屏蔽IP的方法，把`include xxx;`放到网址对应的在server{}语句块,虚拟主机所有网站屏蔽IP的方法，把`include xxx;`放到http{}语句块。\r\n\r\n**手动封禁**\r\n\r\n```nginx\r\nhttp{\r\n    # ....\r\n    include blacklist.conf;\r\n}\r\n\r\nlocation / {\r\n    proxy_pass http://lbs;\r\n    proxy_redirect default;\r\n}\r\n\r\n# blacklist.conf目录文件下的内容\r\ndeny 192.168.159.2;\r\ndeny 192.168.159.32;\r\n\r\n# 重新加载配置，不中断服务\r\n./nginx -s reload\r\n```\r\n\r\n**自动化封禁**\r\n\r\n思路:\r\n\r\n- 编写shell脚本\r\n- AWK统计access.log，记录每秒访问超过60次的ip，然后配合nginx或者iptables进行封禁\r\n- crontab定时跑脚本\r\n\r\n```nginx\r\nlocation / {\r\n    add_header 'Access-Control-Allow-Origin' $http_origin;\r\n    add_header 'Access-Control-Allow-Credentials' 'true';\r\n    add_header 'Access-Control-Allow-Headers' 'DNT,web-token,app-token,Authorization,Accept,Origin,Keep-Alive,User-Agent,X-Mx-ReqToken,X-Data-Type,X-Auth-Token,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range';\r\n    add_header Access-Control-Allow-Methods 'GET,POST,OPTIONS';\r\n    # 如果预检请求则返回成功,不需要转发到后端\r\n    if ($request_method = 'OPTIONS') {\r\n        add_header 'Access-Control-Max-Age' 1728000;\r\n        add_header 'Content-Type' 'text/plain; charset=utf-8';\r\n        add_header 'Content-Length' 0;\r\n        return 200;\r\n    }\r\n}\r\n```\r\n\r\n\r\n### 地址重定向\r\n\r\n**rewrite地址重定向，实现URL重定向的重要指令，他根据regex(正则表达式)来匹配内容跳转到**\r\n\r\n语法: \r\n```bash\r\nrewrite regex replacement[flag]\r\n```\r\n这是⼀个正则表达式，匹配完整的域名和后⾯的路径地址,replacement部分https://xdclass.net/$1,$1是取自regex部分()里的内容.rewrite ^/(.\\*) https://xdclass.net/$1 permanent\r\n\r\n常用正则表达式\r\n\r\n- ^: 匹配输入字符串的起始位置\r\n- $: 匹配输入字符串的结束位置\r\n- \\*: 匹配前面的字符0次或者多次\r\n- ?: 匹配前面字符串的0次或者1次\r\n- .: 匹配除\"\\n\"之外的所有单个字符\r\n- (pattern) 匹配括号内的pattern\r\n\r\nrewrite最后一项flag参数\r\n\r\n- last: 本条规则匹配完成后继续向下匹配新的location URI规则\r\n- break: 本条规则匹配完成后终止,不再匹配任何规则\r\n- redirect: 返回302临时重定向\r\n- permanent: 返回301永久重定向\r\n\r\n\r\n**应用场景**\r\n\r\n– 非法访问跳转,防盗链\r\n\r\n– 网站更换新域名\r\n\r\n– http跳转https\r\n\r\n– 不同地址访问同⼀个虚拟主机的资源\r\n\r\n### 配置websocket反向代理\r\n\r\n```nginx\r\nserver {\r\n    listen 80;\r\n    server_name xdclass.net;\r\n    location / {\r\n        proxy_pass http://lbs;\r\n        proxy_read_timeout 300s; //websocket空闲保持时⻓\r\n        proxy_set_header Host $host;\r\n        proxy_set_header X-Real-IP $remote_addr;\r\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\r\n        proxy_http_version 1.1;\r\n\r\n        proxy_set_header Upgrade $http_upgrade;\r\n        proxy_set_header Connection\r\n        $connection_upgrade;\r\n    }\r\n}\r\n```\r\n\r\n### 性能优化\r\n\r\n**服务端缓存前置**\r\n\r\n- /root/cache\r\n本地路径，用来设置Nginx缓存资源的存放地址\r\n\r\n- levels=1:2\r\n默认所有缓存文件都放在上面指定的根路径中，可能影响缓存的性能，推荐指定为2级目录来存储缓存文件；1和2表示用1位和2位16进制来命名目录名称。第⼀级目录用1位16进制命名，如a；第⼆级目录用2位16进制命名，如3a。所以此例中⼀级目录有16个，⼆级目录有16 * 16=256个,总目录数为16 * 256=4096个。\r\n\r\n- levels=1:1:1时，表示是三级目录，且每级目录数均为16个\r\n- key_zone\r\n在共享内存中定义⼀块存储区域来存放缓存的key和metadata\r\n\r\n  - max_size\r\n最大缓存空间,如果不指定会使用掉所有磁盘空间。当达到disk上限后，会删除最少使用的cache\r\n  - inactive\r\n某个缓存在inactive指定的时间内如果不访问，将会从缓存中删除\r\n  - proxy_cache_valid\r\n配置nginx cache中的缓存⽂件的缓存时间,proxy_cache_valid 200 304 2m对于状态为200和304的缓存⽂件的缓存时间是2分钟\r\n  - use_temp_path\r\n建议为off，则nginx会将缓存⽂件直接写⼊指定的cache文件中\r\n  - proxy_cache\r\n启用proxy cache，并指定key_zone，如果proxy_cache off表示关闭掉缓存\r\n  - add_header Nging-Cache \"$upstream_cache_status\"\r\n用于前端判断是否是缓存，miss、hit、expired(缓存过期)、updating(更新，使用旧的应答)\r\n```nginx\r\nproxy_cache_path /root/cache levels=1:2 keys_zone=xd_cache:10m max_size=1g inactive=60m use_temp_path=off;\r\nserver {\r\n    location /{\r\n    ...\r\n    proxy_cache xd_cache;\r\n    proxy_cache_valid 200 304 10m;\r\n    proxy_cache_valid 404 1m;\r\n    proxy_cache_key $host$uri$is_args$args;\r\n    add_header Nginx-Cache \"$upstream_cache_status\";\r\n    }\r\n}\r\n```\r\n\r\n**动静分离**\r\n\r\n性能优化-静态资源压缩\r\n\r\n对文本、js和css文件等进行压缩，⼀般是压缩后的大小是原始大小的25%\r\n```nginx\r\n# 开启gzip,减少我们发送的数据量\r\ngzip on;\r\ngzip_min_length 1k;\r\n\r\n# 4个单位为16k的内存作为压缩结果流缓存\r\ngzip_buffers 4 16k;\r\n\r\n# gzip压缩⽐，可在1~9中设置，1压缩⽐最⼩，速度最快，9压缩⽐最⼤，速度最慢，消耗CPU\r\ngzip_comp_level 4;\r\n\r\n# 压缩的类型\r\ngzip_types application/javascript text/plain text/css application/json application/xml text/javascript;\r\n\r\n# 给代理服务器⽤的，有的浏览器⽀持压缩，有的不⽀持，所以避免浪费不⽀持的也压缩，所以根据客户端的HTTP头来判断，是否需要压缩\r\ngzip_vary on;\r\n\r\n# 禁⽤IE6以下的gzip压缩，IE某些版本对gzip的压缩⽀持很不好\r\ngzip_disable \"MSIE [1-6].\";\r\n```\r\n\r\n**压缩是时间换空间，还是空间换时间**？\r\n\r\n- web层主要涉及浏览器和服务器的网络交互，而网络交互显然是耗费时间的\r\n\r\n- 要尽量减少交互次数\r\n\r\n- 降低每次请求或响应数据量\r\n\r\n- 开启压缩\r\n\r\n- 在服务端是时间换空间的策略，服务端需要牺牲时间进行压缩以减小响应数据大小\r\n\r\n- 压缩后的内容可以获得更快的网络传输速度，时间是得到了优化,所以是双向的\r\n\r\n### https配置\r\n\r\n**删除原先的nginx，新增ssl模块**\r\n\r\n```shell\r\n./configure --prefix=/usr/local/nginx --with-http_stub_status_module --withhttp_ssl_module\r\nmake\r\nmake install\r\n#查看是否成功\r\n/usr/local/nginx/sbin/nginx -V\r\n```\r\n\r\n**Nginx配置https证书**\r\n\r\n```nginx\r\nserver {\r\n    listen 443 ssl;\r\n    server_name 16web.net;\r\n    ssl_certificate /usr/local/software/biz/key/4383407_16web.net.pem;\r\n    ssl_certificate_key /usr/local/software/biz/key/4383407_16web.net.key;\r\n    ssl_session_cache shared:SSL:1m;\r\n    ssl_session_timeout 5m;\r\n    ssl_ciphers HIGH:!aNULL:!MD5;\r\n    ssl_prefer_server_ciphers on;\r\n    location / {\r\n        root html;\r\n        index index.html index.htm;\r\n    }\r\n}\r\n```\r\n\r\n**https访问实操**\r\n\r\n- 杀掉原先进程\r\n- 防⽕墙关闭或者开放443端⼝\r\n```shell\r\nservice firewalld stop\r\n```\r\n\r\n- 网络安全组开放端口\r\n\r\n- 其他\r\n\r\n反向代理，获取用户的真实ip\r\n```nginx\r\nproxy_set_header Host $host;\r\nproxy_set_header X-Real-IP $remote_addr;\r\nproxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\r\n```\r\n\r\n### 高可用\r\n\r\nLVS+keepalived+nginx架构解决的问题：\r\n\r\n1. 如果其中keepalived挂了，那就会vip就会分发到另外⼀个keepalived节点，响应正常\r\n\r\n2. 如果某个realServer挂了，比如是Nginx挂了，那对应keepalived节点存活依旧可以转发过去，但是响应失败\r\n\r\n- 脚本监听\r\n```bash\r\n# 配置vrrp_script，主要⽤于健康检查及检查失败后执⾏的动作。\r\nvrrp_script chk_real_server {\r\n    # 健康检查脚本，当脚本返回值不为0时认为失败\r\n    script \"/usr/local/software/conf/chk_server.sh\"\r\n    # 检查频率，以下配置每2秒检查1次\r\n    interval 2\r\n    # 当检查失败后，将vrrp_instance的priority减⼩5\r\n    weight -5\r\n    # 连续监测失败3次，才认为真的健康检查失败。并调整优先级\r\n    fall 3\r\n    # 连续监测2次成功，就认为成功。但不调整优先级\r\n    rise 2\r\n    user root\r\n}\r\n```\r\n\r\n- 编辑脚本\r\n\r\n```shell\r\nmkdir -p /usr/local/software/conf\r\ncd /usr/local/software/conf\r\nvim /usr/local/software/conf/chk_server.sh\r\nchmod +x chk_server.sh\r\n```\r\n脚本详情\r\n```shell\r\n#!/bin/bash\r\n#检查nginx进程是否存在\r\ncounter=$(ps -C nginx --no-heading|wc -l)\r\nif [ \"${counter}\" -eq \"0\" ]; then\r\nservice keepalived stop\r\necho 'nginx server is died.......'\r\nfi\r\n```\r\n\r\n3. 步骤\r\n4. ds服务器:\r\n- 安装keepalived,参考keepalived安装步骤\r\n- 安装ipvsadm -y\r\n- 配置防火墙,两种方式,直接关闭，或者按照keepalived中描述的操作\r\n- 参照keepalived描述的修改配置文件\r\n\r\n5. rs服务器:\r\n- 安装openresty或者nginx\r\n- 配置防火墙,保证外网能访问\r\n- 配置realserver\r\n```shell\r\nvim /etc/init.d/realserver\r\n\r\n#虚拟的vip根据自己的实际情况定义\r\nSNS_VIP=192.168.1.25\r\n/etc/rc.d/init.d/functions\r\ncase \"$1\" in\r\nstart)\r\nifconfig lo:0 $SNS_VIP netmask 255.255.255.255 broadcast $SNS_VIP\r\n/sbin/route add -host $SNS_VIP dev lo:0\r\necho \"1\" >/proc/sys/net/ipv4/conf/lo/arp_ignore\r\necho \"2\" >/proc/sys/net/ipv4/conf/lo/arp_announce\r\necho \"1\" >/proc/sys/net/ipv4/conf/all/arp_ignore\r\necho \"2\" >/proc/sys/net/ipv4/conf/all/arp_announce\r\nsysctl -p >/dev/null 2>&1\r\necho \"RealServer Start OK\"\r\n;;\r\nstop)\r\nifconfig lo:0 down\r\nroute del $SNS_VIP >/dev/null 2>&1\r\necho \"0\" >/proc/sys/net/ipv4/conf/lo/arp_ignore\r\necho \"0\" >/proc/sys/net/ipv4/conf/lo/arp_announce\r\necho \"0\" >/proc/sys/net/ipv4/conf/all/arp_ignore\r\necho \"0\" >/proc/sys/net/ipv4/conf/all/arp_announce\r\necho \"RealServer Stoped\"\r\n;;\r\n*)\r\necho \"Usage: $0 {start|stop}\"\r\nexit 1\r\nesac\r\nexit 0\r\n#保存并设置脚本的执行权限\r\nchmod 755 /etc/init.d/realserver\r\n#因为realserver脚本中用到了/etc/rc.d/init.d/functions，所以一并设置权限\r\nchmod 755 /etc/rc.d/init.d/functions\r\n#重启后会失效,所以要设置为开机自启动\r\nchmod +x /etc/rc.d/rc.local\r\nvi /etc/rc.d/rc.local\r\n/etc/rc.d/init.d/realserver.sh start\r\n\r\n#执行脚本\r\nservice realserver start\r\n\r\n#查看执行结果,lo多出vip表明配置正确\r\nip a\r\n```\r\n\r\n- 常见问题\r\n  - vip能ping通，vip监听的端口不通:第⼀个原因:nginx1和nginx2两台服务器的服务没有正常启动\r\n  - vip ping不通:核对是否出现裂脑,常见原因为防火墙配置所致导致多播心跳失败,核对keepalived的配置是否正确：需要关闭selinux，不然sh脚本可能不生效\r\n```shell\r\n#查看\r\ngetenforce\r\n#关闭\r\nsetenforce 0\r\n```\r\n\r\n### 运维统计\r\n\r\n1. 查看访问最频繁的前100个IP\r\n```shell\r\nawk '{print $1}' access_temp.log | sort -n |uniq -c | sort -rn | head -n 100\r\n```\r\n2. 统计访问最多的url 前20名\r\n```shell\r\ncat access_temp.log |awk '{print $7}'| sort|uniq -c| sort -rn| head -20 | more\r\n```\r\n3. 自定义日志统计接口性能\r\n- 日志格式增加$request_time\r\n从接收用户请求的第⼀个字节到发送完响应数据的时间，即包括接收请求数据时间、程序响应时间、输出响应数据时间\r\n$upstream_response_time：指从Nginx向后端建立连接开始到接受完数据然后关闭连接为⽌的时间\r\n$request_time⼀般会比upstream_response_time大，因为用户网络较差，或者传递数据较⼤时，前者会耗时大很多\r\n```nginx\r\nlog_format main '$remote_addr -$remote_user [$time_local] \"$request\" ' '$status\r\n$body_bytes_sent \"$http_referer\" '\r\n'\"$http_user_agent\"\r\n\"$http_x_forwarded_for\" $request_time';\r\n\r\nserver {\r\n    listen 80;\r\n    server_name aabbcc.com;\r\n    location / {\r\n    root /usr/local/nginx/html;\r\n    index xdclass.html;\r\n}\r\n#charset koi8-r;\r\n#\r\naccess_log logs/host.access.log main;\r\n}\r\n```\r\n\r\n4. 统计耗时接口,列出传输时间超过2秒的接口，显示前5条\r\n```shell\r\n#$NF 表示最后⼀列, awk '{print $NF}\r\ncat time_temp.log|awk '($NF > 2){print $7}'|sort -n|uniq -c|sort -nr|head -5\r\n```\r\n\r\n### 防止sql注入\r\n\r\n将下面的Nginx配置文件代码放入到server块中，然后重启Nginx即可\r\n\r\n```nginx\r\n if ($request_method !~* GET|POST) { return 444; }\r\n # 使用444错误代码可以更加减轻服务器负载压力。\r\n # 防止SQL注入\r\n if ($query_string ~* (\\$|'|--|[+|(%20)]union[+|(%20)]|[+|(%20)]insert[+|(%20)]|[+|(%20)]drop[+|(%20)]|[+|(%20)]truncate[+|(%20)]|[+|(%20)]update[+|(%20)]|[+|(%20)]from[+|(%20)]|[+|(%20)]grant[+|(%20)]|[+|(%20)]exec[+|(%20)]|[+|(%20)]where[+|(%20)]|[+|(%20)]select[+|(%20)]|[+|(%20)]and[+|(%20)]|[+|(%20)]or[+|(%20)]|[+|(%20)]count[+|(%20)]|[+|(%20)]exec[+|(%20)]|[+|(%20)]chr[+|(%20)]|[+|(%20)]mid[+|(%20)]|[+|(%20)]like[+|(%20)]|[+|(%20)]iframe[+|(%20)]|[\\<|%3c]script[\\>|%3e]|javascript|alert|webscan|dbappsecurity|style|confirm\\(|innerhtml|innertext)(.*)$) { return 555; }\r\n if ($uri ~* (/~).*) { return 501; }\r\n if ($uri ~* (\\\\x.)) { return 501; }\r\n # 防止SQL注入 \r\n if ($query_string ~* \"[;'<>].*\") { return 509; }\r\n if ($request_uri ~ \" \") { return 509; }\r\n if ($request_uri ~ (\\/\\.+)) { return 509; }\r\n if ($request_uri ~ (\\.+\\/)) { return 509; }\r\n # if ($uri ~* (insert|select|delete|update|count|master|truncate|declare|exec|\\*|\\')(.*)$ ) { return 503; }\r\n # 防止SQL注入\r\n if ($request_uri ~* \"(cost\\()|(concat\\()\") { return 504; }\r\n if ($request_uri ~* \"[+|(%20)]union[+|(%20)]\") { return 504; }\r\n if ($request_uri ~* \"[+|(%20)]and[+|(%20)]\") { return 504; }\r\n if ($request_uri ~* \"[+|(%20)]select[+|(%20)]\") { return 504; }\r\n if ($request_uri ~* \"[+|(%20)]or[+|(%20)]\") { return 504; }\r\n if ($request_uri ~* \"[+|(%20)]delete[+|(%20)]\") { return 504; }\r\n if ($request_uri ~* \"[+|(%20)]update[+|(%20)]\") { return 504; }\r\n if ($request_uri ~* \"[+|(%20)]insert[+|(%20)]\") { return 504; }\r\n if ($query_string ~ \"(<|%3C).*script.*(>|%3E)\") { return 505; }\r\n if ($query_string ~ \"GLOBALS(=|\\[|\\%[0-9A-Z]{0,2})\") { return 505; }\r\n if ($query_string ~ \"_REQUEST(=|\\[|\\%[0-9A-Z]{0,2})\") { return 505; }\r\n if ($query_string ~ \"proc/self/environ\") { return 505; }\r\n if ($query_string ~ \"mosConfig_[a-zA-Z_]{1,21}(=|\\%3D)\") { return 505; }\r\n if ($query_string ~ \"base64_(en|de)code\\(.*\\)\") { return 505; }\r\n if ($query_string ~ \"[a-zA-Z0-9_]=http://\") { return 506; }\r\n if ($query_string ~ \"[a-zA-Z0-9_]=(\\.\\.//?)+\") { return 506; }\r\n if ($query_string ~ \"[a-zA-Z0-9_]=/([a-z0-9_.]//?)+\") { return 506; }\r\n if ($query_string ~ \"b(ultram|unicauca|valium|viagra|vicodin|xanax|ypxaieo)b\") { return 507; }\r\n if ($query_string ~ \"b(erections|hoodia|huronriveracres|impotence|levitra|libido)b\") {return 507; }\r\n if ($query_string ~ \"b(ambien|bluespill|cialis|cocaine|ejaculation|erectile)b\") { return 507; }\r\n if ($query_string ~ \"b(lipitor|phentermin|pro[sz]ac|sandyauer|tramadol|troyhamby)b\") { return 507; }\r\n # 这里大家根据自己情况添加删减上述判断参数，cURL、wget这类的屏蔽有点儿极端了，但要“宁可错杀一千，不可放过一个”。\r\n if ($http_user_agent ~* YisouSpider|ApacheBench|WebBench|Jmeter|JoeDog|Havij|GetRight|TurnitinBot|GrabNet|masscan|mail2000|github|wget|curl|Java|python) { return 508; }\r\n # 同上，大家根据自己站点实际情况来添加删减下面的屏蔽拦截参数。\r\n if ($http_user_agent ~* \"Go-Ahead-Got-It\") { return 508; }\r\n if ($http_user_agent ~* \"GetWeb!\") { return 508; }\r\n if ($http_user_agent ~* \"Go!Zilla\") { return 508; }\r\n if ($http_user_agent ~* \"Download Demon\") { return 508; }\r\n if ($http_user_agent ~* \"Indy Library\") { return 508; }\r\n if ($http_user_agent ~* \"libwww-perl\") { return 508; }\r\n if ($http_user_agent ~* \"Nmap Scripting Engine\") { return 508; }\r\n if ($http_user_agent ~* \"~17ce.com\") { return 508; }\r\n if ($http_user_agent ~* \"WebBench*\") { return 508; }\r\n if ($http_user_agent ~* \"spider\") { return 508; } #这个会影响国内某些搜索引擎爬虫，比如：搜狗\r\n # 拦截各恶意请求的UA，可以通过分析站点日志文件或者waf日志作为参考配置。\r\n if ($http_referer ~* 17ce.com) { return 509; }\r\n # 拦截17ce.com站点测速节点的请求，所以明月一直都说这些测速网站的数据仅供参考不能当真的。\r\n if ($http_referer ~* WebBench*\") { return 509; }\r\n # 拦截WebBench或者类似压力测试工具，其他工具只需要更换名称即可。\r\n```\r\n\r\n### 限制连接数量\r\n\r\nNginx可以通过limit_conn_zone和limit_conn两个组件来对客户端访问目录和文件的访问频率和次数进行限制，两个模块都能够对客户端访问进行限制，具体如何使用要结合公司业务环境进行配置。举个简单的例子：\r\n\r\n```nginx\r\nhttp {\r\n  limit_conn_zone $binary_remote_addr zone=ops:10m;\r\n  # ...\r\n  server {\r\n    listen       80;\r\n    server_name  www.javaboy.org;\r\n    location / {\r\n      limit_conn ops 1;  #这将指定一个地址只能同时存在一个连接。“one”与上面的对应，也可以自定义命名\r\n      limit_rate 300k;\r\n  }\r\n}\r\n```\r\n\r\n这里涉及到三个配置项：\r\n\r\n- limit_zone：是针对每个IP定义一个存储session状态的容器，这个示例中定义了一个10m的容器，假设每个session的大小是32bytes，那么可以处理327680个session。\r\n- limit_conn ops 1：限制每个IP只能发起一个并发连接。\r\n- limit_rate 300k：对每个连接限速300k。注意，这里是对连接限速，而不是对IP限速。如果一个IP允许两个并发连接，那么这个IP就是限速`limit_rate × 2`。\r\n\r\n### 限制请求频率\r\n\r\nNginx可以通过限制请求频率来防止服务器过载，最常见的场景就是登录请求，可以通过限制请求频率防止账号暴力破解。Nginx官方版本限制IP的连接和并发分别有两个模块：\r\n\r\n- limit_req_zone：用来限制单位时间内的请求数，即速率限制,采用的漏桶算法\"leaky bucket\"。\r\n- limit_req_conn：用来限制同一时间连接数，即并发限制。\r\n\r\n```nginx\r\nhttp {\r\n    limit_req_zone $binary_remote_addr zone=mylimit:10m rate=1r/s;\r\n    server {\r\n        listen 80;\r\n        location / {\r\n            limit_req zone=mylimit burst=5 nodelay;;\r\n            proxy_pass http://javaboy.org;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**limit_req_zone $binary_remote_addr zone=mylimit:10m rate=1r/s;**\r\n\r\n- 第一个参数：$binary_remote_addr表示通过remote_addr这个标识来做限制，“binary_”的目的是缩写内存占用量，是限制同一客户端ip地址。\r\n- 第二个参数：zone=mylimit:10m表示生成一个大小为10M，名字为mylimit的内存区域，用来存储访问的频次信息。\r\n- 第三个参数：rate=1r/s表示允许相同标识的客户端的访问频次，这里限制的是每秒1次，还可以有比如30r/m的。\r\n\r\n**limit_req zone=mylimit burst=5 nodelay;**\r\n\r\n- 第一个参数：zone=one设置使用哪个配置区域来做限制，与上面limit_req_zone里的name对应。\r\n- 第二个参数：burst=5，重点说明一下这个配置，burst爆发的意思，这个配置的意思是设置一个大小为5的缓冲区，当有大量请求（爆发）过来时，超过了访问频次限制的请求可以先放到这个缓冲区内。\r\n- 第三个参数：nodelay，如果设置，超过访问频次而且缓冲区也满了的时候就会直接返回503，如果没有设置，则所有请求会等待排队。\r\n\r\n### 防止目录遍历\r\n\r\n在Nginx配置中设置`autoindex off`来防止目录遍历攻击。这个一般是如果你要做文件服务器，根据自己的实际需求，有需要的话这个功能可以打开，否则将之关闭即可。\r\n\r\n```nginx\r\nlocation / {\r\n    autoindex off;\r\n}\r\n```\r\n\r\n### 隐藏Nginx版本号\r\n\r\n攻击者如果能够确定服务器使用的Nginx版本，可能会利用这个信息来寻找和利用已知的漏洞进行攻击。因此，隐藏版本信息可以提高服务器的安全性，使攻击者难以通过版本信息推断出服务器可能存在的安全漏洞。要隐藏Nginx版本号，有三个办法，一般来说我们使用第一种方式就可以了。\r\n\r\n**修改配置文件**\r\n\r\n在Nginx的配置文件中，在`http`块中添加以下配置：\r\n\r\n```nginx\r\nserver_tokens off;\r\n```\r\n\r\n这样设置后，Nginx将不会在错误页面上显示版本号。配置完成之后，保存配置文件并重新加载Nginx以应用更改：\r\n\r\n```nginx\r\nnginx -t # 测试配置文件是否正确\r\nnginx -s reload # 重新加载Nginx配置\r\n```\r\n\r\n这种方法可以隐藏错误页面上的版本信息，但可能无法完全隐藏所有响应头中的版本信息。\r\n\r\n**修改Nginx源码**\r\n\r\n如果想要从根源上修改Nginx版本信息，需要重新编译Nginx，步骤如下：\r\n\r\n- 修改`src/core/nginx.h`文件中的版本定义。\r\n- 修改`src/http/ngx_http_header_filter_module.c`文件中的服务器字符串。\r\n- 修改`src/http/ngx_http_special_response.c`文件中的错误页面底部信息。\r\n\r\n修改完这些文件后，需要重新编译Nginx。这样编译安装后，Nginx的版本信息将被彻底修改。\r\n\r\n**使用第三方模块**\r\n\r\n如果需要动态修改响应头中的版本信息，可以使用如`headers-more-nginx-module`模块。这个模块允许你动态地添加、修改或删除Nginx的响应头。通过这个模块，可以完全控制`Server`响应头的内容。选择哪种方法取决于你的具体需求和环境。如果你只是想简单地隐藏版本信息，修改配置文件可能是最简单的方法。如果你需要更彻底地控制版本信息，可能需要考虑修改源码并重新编译Nginx。\r\n\r\n### 设置超时时间\r\n\r\n设置Nginx的超时配置是非常重要的，因为它可以影响服务器的性能和资源的有效利用。比较常见的超时配置有四个：\r\n\r\n1. **keepalive_timeout**：这个指令设置了与客户端的`keep-alive`连接超时时间。如果连接在指定时间内没有数据传输，Nginx将关闭该连接。默认值通常是75秒。这个设置对于频繁访问的站点尤其重要，因为它减少了连接建立和断开的开销。\r\n2. **client_body_timeout**：这个指令指定了客户端与服务端建立连接后发送request body的超时时间。如果客户端在指定时间内没有发送任何内容，Nginx返回HTTP 408（Request Timed Out）。默认值通常是60秒。\r\n3. **client_header_timeout**：这个指令指定了客户端向服务端发送一个完整的request header的超时时间。如果在指定时间内没有发送一个完整的request header，Nginx返回HTTP 408（Request Timed Out）。默认值通常是60秒。\r\n4. **send_timeout**：这个指令设置了服务端向客户端传输数据的超时时间。如果在指定时间内客户端没有接收到任何数据，连接将被关闭。默认值通常是60秒。\r\n\r\n**keepalive_timeout**\r\n\r\n这个指令控制了客户端与服务器之间的连接保持活动状态的时间。这对于减少TCP连接的开销非常有用，特别是在高流量的网站上。\r\n\r\n```nginx\r\nhttp {\r\n    keepalive_timeout 60s;\r\n    server {\r\n        listen 80;\r\n        server_name javaboy.org;\r\n        location / {\r\n            proxy_pass http://javaboy.org;\r\n            proxy_http_version 1.1;\r\n            proxy_set_header Upgrade $http_upgrade;\r\n            proxy_set_header Connection \"upgrade\";\r\n            proxy_set_header Host $host;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n在这个配置中，`keepalive_timeout`被设置为60秒，意味着如果60秒内没有数据传输，连接将被关闭。\r\n\r\n**client_body_timeout**\r\n\r\n这个指令设置了客户端发送请求体到服务器的超时时间。\r\n\r\n```nginx\r\nhttp {\r\n    client_body_timeout 10s;\r\n    server {\r\n        listen 80;\r\n        server_name javaboy.org;\r\n        location /upload {\r\n            client_max_body_size 100M;\r\n            client_body_timeout 30s;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n在这个配置中，`client_body_timeout`被设置为10秒，适用于上传大文件的场景，确保如果客户端在30秒内没有完成文件上传，请求将被终止。\r\n\r\n**client_header_timeout**\r\n\r\n这个指令控制了客户端发送完整的HTTP请求头到服务器的超时时间。\r\n\r\n```nginx\r\nhttp {\r\n    client_header_timeout 5s;\r\n    server {\r\n        listen 80;\r\n        server_name javaboy.org;\r\n        location / {\r\n            proxy_pass http://javaboy.org;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n在这个配置中，`client_header_timeout`被设置为5秒，意味着如果客户端在5秒内没有发送完整的HTTP请求头，服务器将终止连接。\r\n\r\n**send_timeout**\r\n\r\n这个指令设置了服务器发送响应到客户端的超时时间。\r\n\r\n```nginx\r\nhttp {\r\n    send_timeout 10s;\r\n    server {\r\n        listen 80;\r\n        server_name javaboy.org;\r\n        location / {\r\n            proxy_pass http://javaboy.org;\r\n            proxy_read_timeout 10s;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n在这个配置中，`send_timeout`被设置为10秒，适用于后端服务响应慢的场景，确保如果后端服务在10秒内没有发送数据，客户端将收到超时响应。\r\n\r\n### 仅允许域名访问\r\n\r\n限制仅允许域名访问可以防止未授权的IP直接访问服务器，减少未备案域名解析到服务器IP导致的安全风险。这个也有三种不同的配置方式。\r\n\r\n**使用两个`server`块**\r\n\r\n在Nginx配置文件中，你可以设置一个默认的server块，它将捕获所有不明确的域名请求，并返回403错误。然后，为特定的域名设置server块。\r\n\r\n```nginx\r\nserver {\r\n    listen 80 default_server;\r\n    server_name _;\r\n    return 403;\r\n}\r\nserver {\r\n    listen 80;\r\n    server_name www.javaboy.org;\r\n    location / {\r\n        # 你的配置\r\n    }\r\n}\r\n```\r\n\r\n在这个配置中，第一个`server`块会拦截所有不明确域名的请求，并返回403错误。第二个`server`块则是为特定域名`www.javaboy.org`提供服务的配置。这个配置有两点需要注意：\r\n\r\n1. 如果没有显式声明default server则第一个server会被隐式的设为default server。\r\n2. server_name中的`_;`，并不是重点.`__`也可以，`___`也可以。\r\n\r\n**使用`if`语句**\r\n\r\n还可以在特定的`server`块中使用`if`语句来检查`$host`变量，如果它不匹配你的域名，则返回403错误。\r\n\r\n```nginx\r\nserver {\r\n    listen 80;\r\n    server_name javaboy.org;\r\n    location / {\r\n        if ($host != 'www.javaboy.org') {\r\n            return 403;\r\n        }\r\n        # 你的配置\r\n    }\r\n}\r\n```\r\n\r\n这种方法允许你在特定域名的server块中直接控制访问权限，只有当`$host`变量与你的域名匹配时，才会允许访问。\r\n\r\n**直接禁止IP**\r\n\r\n```nginx\r\nhttp {\r\n    server {\r\n        listen 80;\r\n        server_name www.javaboy.org;\r\n        ...\r\n    }\r\n    server {\r\n        listen 80;\r\n        server_name www.itboyhub.com;\r\n        ...\r\n    }\r\n    # 直接指定ip server_name\r\n    server {\r\n        listen 80;\r\n        server_name 11.11.11.11;\r\n        return 403; # 403 forbidden\r\n    }\r\n}\r\n```\r\n\r\n这样配置后，只有通过指定的域名才能访问网站，直接通过IP地址访问将会受到限制。\r\n\r\n### 限制Nginx请求方法\r\n\r\n通过限制特定的HTTP请求方法，可以减少服务器受到自动化攻击的风险，并且可以防止某些类型的Web漏洞，如SQL注入或跨站脚本（XSS）攻击。有两种配置方式，逐一说明。\r\n\r\n**只允许GET和POST**\r\n\r\n在`server`或`location`块中，使用`if`语句来检查请求方法，并返回403错误码以拒绝其他方法。\r\n\r\n```nginx\r\nserver {\r\n    listen 80;\r\n    server_name javaboy.org;\r\n    location / {\r\n        if ($request_method !~* (GET|POST)) {\r\n            return 403;\r\n        }\r\n        # 其他配置...\r\n    }\r\n}\r\n```\r\n\r\n这种方法会拒绝所有非GET和POST的请求方法。\r\n\r\n**使用map模块**\r\n\r\n对于更复杂的限制逻辑，可以使用Nginx的`map`模块来动态设置请求方法的限制。\r\n\r\n```nginx\r\nhttp {\r\n    map $request_method $block_request {\r\n        default 0;\r\n        POST 1;\r\n        PUT 1;\r\n    }\r\n\r\n    server {\r\n        listen 80;\r\n        server_name javaboy.org;\r\n        location / {\r\n            if ($block_request) {\r\n                return 403;\r\n            }\r\n            # 其他配置...\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n在这个例子中，所有POST和PUT请求都会被拒绝。\r\n\r\n### 错误页面重定向\r\n\r\n在Nginx中配置错误页面重定向，除了安全因素之外，还有很多好处，比如：\r\n\r\n1. **提升用户体验**：通过提供更友好的错误页面，可以减少用户在遇到错误时的困惑和挫败感。\r\n2. **增强SEO效果**：自定义错误页面可以帮助搜索引擎更好地理解网站结构，避免因错误页面导致的SEO问题。\r\n3. **维护品牌形象**：错误页面是网站的一部分，通过自定义错误页面，可以保持品牌一致性，提升专业形象。\r\n4. **提供错误信息**：自定义错误页面可以提供有用的错误信息或解决方案，帮助用户理解问题所在。\r\n\r\n在Nginx配置文件中，可以使用`error_page`指令来定义特定错误代码的重定向页面。例如，将404错误重定向到自定义的404页面：\r\n\r\n```nginx\r\nserver {\r\n    listen 80;\r\n    server_name javaboy.org;\r\n\r\n    error_page 404 /404.html;\r\n    location = /404.html {\r\n        root /path/to/error/pages;\r\n        internal;\r\n    }\r\n}\r\n```\r\n\r\n在这个配置中，当Nginx返回404错误时，它会显示位于`/path/to/error/pages/404.html`的自定义错误页面，而不是默认的错误页面。`internal`指令确保这个页面只对Nginx内部请求可见，不会被外部直接访问。当然，上面这个配置也可以同时枚举多个错误状态码：\r\n\r\n```nginx\r\nerror_page 500 502 503 504 /50x.html;\r\nlocation = /50x.html {\r\n    root /usr/share/nginx/html;\r\n}\r\n```\r\n\r\n这个配置会将所有500系列错误重定向到`/50x.html`，并显示位于`/usr/share/nginx/html/50x.html`的自定义错误页面。\r\n\r\n### 日志保留半年\r\n\r\n保留Nginx日志半年的原因有很多，比如：\r\n\r\n1. **安全审计**：日志文件可以用于安全审计，帮助分析和追踪潜在的攻击或异常行为。\r\n2. **故障排查**：在系统出现故障时，日志文件是诊断问题的重要工具，可以帮助快速定位问题原因。\r\n3. **性能监控**：通过分析日志，可以了解网站的访问情况和性能瓶颈，从而进行相应的优化。\r\n4. **合规性要求**：某些行业法规可能要求保留一定期限的日志记录，以满足合规性检查。\r\n\r\n要配置Nginx日志保留半年，通常需要使用`logrotate`工具来实现日志文件的定期轮换和压缩。在`/etc/logrotate.d/`目录下创建一个名为`nginx`的配置文件，内容如下：\r\n\r\n```nginx\r\n/var/log/nginx/*.log {\r\n    daily\r\n    rotate 180\r\n    missingok\r\n    notifempty\r\n    compress\r\n    delaycompress\r\n    sharedscripts\r\n    postrotate\r\n        [ -f /var/run/nginx.pid ] && kill -USR1 `cat /var/run/nginx.pid`\r\n    endscript\r\n}\r\n```\r\n\r\n这个配置会每天检查Nginx日志文件，并将它们保留180天（约6个月），然后自动压缩旧的日志文件。`postrotate`部分的命令会在日志轮换后重新打开Nginx日志文件，以便继续记录新的日志信息。通过这些配置，我们可以确保Nginx的日志文件被保留半年，同时旧的日志文件会被压缩以节省磁盘空间。\r\n\r\n### 设置缓冲区\r\n\r\nNginx的缓冲区溢出攻击是一种常见的安全漏洞，它发生在程序试图向一个缓冲区写入超出其预分配大小的数据时。这种攻击可能导致数据覆盖了相邻的内存区域，可能破坏程序的执行流程，甚至可以被恶意攻击者利用来执行恶意代码。为了防止缓冲区溢出类攻击事件，可以设置客户端请求体、请求头和客户端最大请求体的缓冲区大小。配置方式如下：\r\n\r\n```nginx\r\nclient_body_buffer_size 1K;\r\nclient_header_buffer_size 1k;\r\nclient_max_body_size 1k;\r\nlarge_client_header_buffers 2 1k;\r\n```\r\n\r\n这四行配置含义如下：\r\n\r\n- `client_body_buffer_size1K;`：这条指令设置了Nginx用来读取客户端请求体（比如POST请求中的数据）的缓冲区大小。在这个例子中，缓冲区大小被设置为1KB。如果请求体的大小超过了这个缓冲区的大小，Nginx会使用磁盘来暂存超出部分的数据。\r\n- `client_header_buffer_size1k;`：这条指令定义了Nginx用来读取客户端HTTP请求头部的缓冲区大小。这里设置的大小是1KB。如果请求头部的大小超过了这个缓冲区的大小，Nginx会使用`large_client_header_buffers`定义的缓冲区。\r\n- `client_max_body_size1k;`：这条指令限制了Nginx服务器愿意接收的最大请求体大小。如果客户端发送的请求体超过了这个大小（在这个例子中是1KB），Nginx将返回一个413（RequestEntityTooLarge）错误。\r\n- `large_client_header_buffers21k;`：这条指令定义了Nginx用于处理大于`client_header_buffer_size`指定大小的请求头的缓冲区数量和大小。这里配置了2个大小为1KB的缓冲区。当请求头的大小超过了`client_header_buffer_size`定义的缓冲区大小时，Nginx会使用这两个额外的缓冲区来处理请求头。\r\n\r\n这些配置对于防止缓冲区溢出攻击和处理大请求都是非常重要的。\r\n\r\n### 使用普通用户启动\r\n\r\n在Linux系统中，只有root用户或者具有特定权限的用户才能绑定1024以下的端口，如80端口（HTTP）和443端口（HTTPS）。如果Nginx以root用户运行，它将拥有过高的权限，这可能会带来安全风险。因此，为了最小化权限，通常会创建一个普通用户来运行Nginx，以减少潜在的安全漏洞。配置方式如下：\r\n\r\n**创建用户**\r\n\r\n首先，你需要创建一个普通用户和用户组，例如`nginx`。\r\n\r\n```shell\r\ngroupadd nginx\r\nuseradd -g nginx -d /usr/local/nginx nginx\r\n```\r\n\r\n这里创建了一个名为`nginx`的用户和组，并设置了用户的家目录。\r\n\r\n**授权访问**\r\n\r\n确保新用户有权访问Nginx的配置文件、日志文件和服务器文件。\r\n\r\n```shell\r\nchown -R nginx:nginx /usr/local/nginx/\r\n```\r\n\r\n这条命令将Nginx目录及其所有子目录和文件的所有权更改为新创建的`nginx`用户和组。\r\n\r\n**配置Nginx**\r\n\r\n编辑Nginx配置文件（通常位于`/etc/nginx/nginx.conf`），设置`user`指令以指定Nginx工作进程的用户。\r\n\r\n```nginx\r\nuser nginx;\r\n```\r\n\r\n这行配置指定Nginx应该以`nginx`用户的身份运行。\r\n\r\n**设置权限**\r\n\r\n如果需要，可以使用`setcap`命令赋予Nginx监听1024以下端口的能力，而不需要以root用户运行。\r\n\r\n```shell\r\nsetcap cap_net_bind_service=+ep /usr/local/nginx/sbin/nginx\r\n```\r\n\r\n这个命令允许Nginx以普通用户身份绑定到80和443端口。\r\n\r\n**启动Nginx**\r\n\r\n使用普通用户启动Nginx。\r\n\r\n```shell\r\nsu - nginx\r\n/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf\r\n```\r\n\r\n这里首先切换到`nginx`用户，然后启动Nginx服务。\r\n\r\n**验证**\r\n\r\n检查Nginx是否以普通用户启动。\r\n\r\n```shell\r\nps -ef | grep nginx\r\n```\r\n\r\n这条命令将显示Nginx的进程信息，你可以验证它是否以`nginx` 用户运行。\r\n\r\n\r\n## 相关文章\r\n\r\n| [这是一个Nginx极简教程，目的在于帮助新手快速入门Nginx。](https://github.com/dunwu/nginx-tutorial) | [就是要让你搞懂Nginx，这篇就够了！](https://mp.weixin.qq.com/s/5Q_VQoQY6kJiMwMHHDIijA) | [Nginx为什么快到根本停不下来？](https://mp.weixin.qq.com/s/e7r2Jt1DlF_4HpZU_IKZkQ) |\r\n| :----------------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |\r\n| [手把手教你在CentOS7上搭建Nginx](https://mp.weixin.qq.com/s?__biz=MzkzODE3OTI0Ng==&amp;mid=2247490879&amp;idx=1&amp;sn=bd93bc46cdfb7919b9a304c176927dd8&amp;source=41#wechat_redirect) | [nginx实现动态分离,解决css和js等图片加载问题](https://www.cnblogs.com/sz-jack/p/5206159.html) | [nginx反向代理tomcat，js，css静态资源不加载问题](https://blog.csdn.net/white1114579650/article/details/120151335) |\r\n| [彻底搞懂Nginx的五大应用场景](https://mp.weixin.qq.com/s/v6j2HStMHBDlak6UGTF0Hw) | [nginx配置参数](https://blog.51cto.com/ting2junshui/2066268) | [Nginx轻松搞定跨域问题！](https://mp.weixin.qq.com/s/clSjaLJSht5J8woIaiH4gA) |\r\n| [如何使用Nginx优雅地限流？](https://mp.weixin.qq.com/s/YXJ1jcr7XLKTbzf9kyjiEg) | [一文学会Nginx的限流配置](https://mp.weixin.qq.com/s/s4j043__MiXst8wHpEPUoA) | [Nginx如何限流？](https://mp.weixin.qq.com/s/R6GajrvNphXfgKWDsFWzFw) |\r\n|           [nginxconfig.io](https://nginxconfig.io)           | [为什么Nginx比Apache更牛叉？](https://mp.weixin.qq.com/s/pPV5s3uO1sjPTAhz_BDcJg) | [如何用Nginx代理MySQL连接，并限制可访问IP？](https://mp.weixin.qq.com/s/6lvKIQb4yk7uTmufr9pJ8w) |\r\n| [Nginx配置最全详解(万字图文总结)](https://mp.weixin.qq.com/s/---HjW_eobgY-nZI1Kmszw) | [Nginx性能优化的几个方法](https://mp.weixin.qq.com/s/g0axq_lTbNyYV-V7W8CP5w) | [Nginx部署负载均衡服务全解析](https://mp.weixin.qq.com/s/KN5o2hsVXmNm5ZBDURsi4A) |\r\n","categories":[],"tags":[{"name":"安装","path":"api/tags/安装.json"}]}