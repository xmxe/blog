{"title":"Docker","slug":"Docker","date":"2022-09-28T07:09:19.982Z","updated":"2023-11-16T01:52:15.189Z","comments":true,"path":"api/articles/Docker.json","excerpt":null,"covers":"https://pic2.zhimg.com/v2-98bbd70b053dd779240634a00c7f0950_1440w.jpg","content":"\r\n\r\n## 安装\r\n\r\n### 在线安装\r\n\r\n(1) 安装docker需要关闭selinux,由于selinux和LXC（Docker实现虚拟化的方式）有冲突，所以需要禁用selinux。编辑/etc/selinux/config，设置两个关键变量。\r\n\r\n```shell\r\nSELINUX=disabled\r\n\r\nSELINUXTYPE=targeted\r\n```\r\n\r\n(2) 关闭防火墙\r\n\r\n```shell\r\nsystemctl stop firewalld\r\n```\r\n\r\n(3) 安装容器\r\n\r\n```shell\r\nyum -y install docker-ce\r\n```\r\n\r\n(4) 启动服务\r\n\r\n```shell\r\nsystemctl start docker\r\n```\r\n\r\n(5) 测试容器\r\n\r\n```shell\r\ndocker run hello-world\r\n# PS: centos7安装命令 yum -y install docker-ce | ubuntu安装命令 apt install docker-ce\r\n```\r\n\r\n### 离线安装\r\n\r\n(1) [下载离线包](https://download.docker.com/linux/static/stable/x86_64/)\r\n\r\n(2) 解压\r\n\r\n```shell\r\ntar -xvf docker-18.06.1-ce.tgz\r\n```\r\n\r\n(3) 将解压出来的docker文件内容移动到/usr/bin/目录下\r\n\r\n```shell\r\ncp docker/* /usr/bin/\r\n```\r\n\r\n(4) 将docker注册为service\r\n\r\n```shell\r\n# vim /etc/systemd/system/docker.service\r\n\r\n# lib/systemd/system、/usr/lib/systemd/system、/etc/systemd/system都可以，lib/systemd/system真实地址是/usr/lib/system/system地址，\r\n# /usr/lib/systemd/system/ 软件包安装的单元\r\n# /etc/systemd/system/ 系统管理员安装的单元,优先级更高\r\n# 优先级为 /etc/systemd/system，/run/systemd/system，/lib/systemd/system\r\n# 如果同一选项三个地方都配置了，优先级高的会覆盖优先级低的。\r\n\r\n[Unit]\r\nDescription=Docker Application Container Engine\r\nDocumentation=https://docs.docker.com\r\nAfter=network-online.target firewalld.service\r\nWants=network-online.target\r\n\r\n[Service]\r\n\r\nType=notify\r\n# the default is not to use systemd for cgroups because the delegate issues still\r\n# exists and systemd currently does not support the cgroup feature set required\r\n# for containers run by docker\r\n\r\nExecStart=/usr/bin/dockerd -H tcp://0.0.0.0:2375 -H unix://var/run/docker.sock\r\n\r\nExecReload=/bin/kill -s HUP $MAINPID\r\n\r\n# Having non-zero Limit*s causes performance problems due to accounting overhead\r\n# in the kernel. We recommend using cgroups to do container-local accounting.\r\n\r\nLimitNOFILE=infinity\r\n\r\nLimitNPROC=infinity\r\n\r\nLimitCORE=infinity\r\n\r\n# Uncomment TasksMax if your systemd version supports it.\r\n# Only systemd 226 and above support this version.\r\n# TasksMax=infinity\r\n\r\nTimeoutStartSec=0\r\n\r\n# set delegate yes so that systemd does not reset the cgroups of docker containers\r\n\r\nDelegate=yes\r\n\r\n# kill only the docker process, not all processes in the cgroup\r\n\r\nKillMode=process\r\n\r\n# restart the docker process if it exits prematurely\r\n\r\nRestart=on-failure\r\n\r\nStartLimitBurst=3\r\n\r\nStartLimitInterval=60s\r\n\r\n\r\n[Install]\r\n\r\nWantedBy=multi-user.target\r\n```\r\n\r\n(5) 添加文件权限并启动docker\r\n\r\n```shell\r\nchmod +x /etc/systemd/system/docker.service\r\n```\r\n\r\n(6) 重载unit配置文件\r\n\r\n```shell\r\nsystemctl daemon-reload\r\n```\r\n\r\n(7) 启动Docker\r\n\r\n```shell\r\nsystemctl start docker\r\n```\r\n\r\n(8) 设置开机自启\r\n\r\n```shell\r\nsystemctl enable docker.service\r\n```\r\n\r\n(9) 查看Docker状态\r\n\r\n```shell\r\nsystemctl status docker\r\n```\r\n\r\n(10) 查看Docker版本\r\n\r\n```shell\r\ndocker -v\r\n```\r\n\r\n## 常用命令\r\n\r\n### docker images\r\n\r\n- 查看镜像\r\n```shell\r\ndocker images\r\n-a :列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）；\r\n--digests :显示镜像的摘要信息；\r\n-f :显示满足条件的镜像；\r\n--format :指定返回值的模板文件；\r\n--no-trunc :显示完整的镜像信息；\r\n-q :只显示镜像ID。\r\n```\r\n\r\n### docker pull\r\n\r\n- 拉取镜像\r\n```shell\r\ndocker pull name:tag\r\n```\r\n\r\n### docker push\r\n\r\n- 推送镜像\r\n```shell\r\ndocker push myapache:v1\r\n```\r\n\r\n### docker save\r\n\r\n- 导出镜像\r\n```shell\r\ndocker save -o <保存路径> <镜像名称:标签>\r\n\r\ndocker save -o ./ubuntu18.tar ubuntu:18.04\r\n```\r\n\r\n### docker load\r\n\r\n- 导入镜像\r\n```shell\r\ndocker load -i 文件名 或者docker load --input 文件名\r\n\r\ndocker load --input ./ubuntu18.tar\r\n```\r\n\r\n### docker rmi\r\n\r\n- 删除镜像\r\n```shell\r\ndocker rmi images_id\r\n```\r\n\r\n- 删除所有镜像\r\n```shell\r\ndocker rmi `docker images -q`\r\n```\r\n\r\n### docker rm\r\n\r\n- 删除容器\r\n```shell\r\ndocker rm [OPTIONS] container_id\r\n\r\nOPTIONS说明：\r\n-f :通过 SIGKILL 信号强制删除一个运行中的容器。\r\n-l :移除容器间的网络连接，而非容器本身。\r\n-v :删除与容器关联的卷。\r\n```\r\n\r\n- 删除所有容器\r\n```shell\r\ndocker rm $(docker ps -a -q) \r\n或者\r\ndocker rm `docker ps -a -q`\r\n```\r\n\r\n### docker search\r\n\r\n- 搜索镜像\r\n```shell\r\ndocker search *\r\n```\r\n\r\n### docker history\r\n\r\n- 查看指定镜像的创建历史\r\n```shell\r\ndocker history [OPTIONS] IMAGE\r\n\r\nOPTIONS说明：\r\n-H :以可读的格式打印镜像大小和日期，默认为true；\r\n--no-trunc :显示完整的提交记录；\r\n-q :仅列出提交记录ID。\r\n```\r\n\r\n### docker ps\r\n\r\n- 查看正在运行的容器\r\n```shell\r\ndocker ps\r\n# 或者\r\ndocker container ls\r\n```\r\n\r\n- 查看所有容器\r\n```shell\r\ndocker ps -a\r\n# 或者\r\ndocker container ls -a\r\n```\r\n\r\n### docker export\r\n\r\n- 导出容器\r\n```shell\r\ndocker export <容器名> > <保存路径>\r\n# 或者\r\ndocker export -o <容器名> <保存路径> # -o :将输入内容写到文件。\r\ndocker export ubuntu18 > ./ubuntu18.tar\r\n# 将id为a404c6c174a2的容器按日期保存为tar文件\r\ndocker export -o mysql-`date +%Y%m%d`.tar a404c6c174a2\r\n```\r\n\r\n### docker import\r\n\r\n- 导入容器\r\n```shell\r\ndocker import <文件路径> <容器名>\r\ndocker import ./ubuntu18.tar ubuntu18\r\n```\r\n\r\n### docker (container) start\r\n\r\n- 启动容器\r\n```shell\r\ndocker container start container_id\r\n```\r\n\r\n### docker stop\r\n\r\n- 停止所有容器\r\n```shell\r\ndocker stop $(docker ps -a -q)\r\n```\r\n\r\n### docker kill\r\n\r\n- 杀掉运行中的容器\r\n```shell\r\ndocker kill -s(可忽略) CONTAINER\r\n# -s :向容器发送一个信号 例：\r\ndocker kill -s KILL mynginx\r\n```\r\n\r\n### docker exec\r\n\r\n- 在运行的容器中执行命令\r\n```shell\r\ndocker exec [OPTIONS] CONTAINER COMMAND [ARG...]\r\n# 例如：进入容器\r\ndocker exec -itd 容器id /bin/bash\r\n# （-d:分离模式,在后台运行 -i:即使没有附加也保持STDIN打开 -t:分配一个伪终端）/bin/bash: 在container中启动一个bash shell。exit:退出bash shell\r\n```\r\n\r\n### docker pause\r\n\r\n- 暂停容器中所有的进程\r\n```shell\r\ndocker pause container_id\r\n```\r\n\r\n### docker unpause\r\n\r\n- 恢复容器中所有的进程\r\n```shell\r\ndocker unpause container_id\r\n```\r\n\r\n### docker create\r\n\r\n- 创建一个新的容器不运行\r\n```shell\r\ndocker create # 参数同docker run\r\n```\r\n\r\n### docker run\r\n\r\n- 创建一个新的容器并运行\r\n```shell\r\ndocker run\r\n-i: 以交互模式运行容器，通常与-t同时使用\r\n-t: 为容器重新分配一个伪输入终端，通常与-i同时使用\r\n-it 以交互模式运行\r\n-P: 随机端口映射，容器内部端口随机映射到主机的端口\r\n-p: 指定端口映射，格式为：主机(宿主)端口:容器端口\r\n-d 后台运行并返回容器ID\r\n-v,--volume 挂载主机目录:容器目录,绑定一个卷\r\n-u,--user=\"\":指定容器的用户\r\n-a,--attach=[]:登录容器（必须是以docker run -d启动的容器）\r\n-w,--workdir=\"\":指定容器的工作目录\r\n-c,--cpu-shares=0:设置容器CPU权重,在CPU共享场景使用\r\n-e username=\"ritchie\",--env=[]:设置环境变量容器中可以使用该环境变量\r\n-m,--memory=\"\":指定容器的内存上限\r\n-P,--publish-all=false:指定容器暴露的端口\r\n-h,--hostname=\"\":指定容器的主机名\r\n--name=””:容器命名\r\n--cap-add=[]:添加权限,权限清单详见:http://linux.die.net/man/7/capabilities\r\n--cap-drop=[]:删除权限,权限清单详见:http://linux.die.net/man/7/capabilities\r\n--cidfile=\"\":运行容器后,在指定文件中写入容器PID值,一种典型的监控系统用法\r\n--cpuset=\"\":设置容器可以使用哪些CPU，此参数可以用来容器独占CPU\r\n--device=[]:添加主机设备给容器，相当于设备直通\r\n--dns=[]:指定容器的dns服务器\r\n--dns-search=[]:指定容器的dns搜索域名,写入到容器的/etc/resolv.conf文件\r\n--entrypoint=\"\":覆盖image的入口点\r\n--env-file=[]:从指定文件读入环境变量\r\n--expose=[]:指定容器暴露的端口,即修改镜像的暴露端口\r\n--link=[]:添加链接到另一个容器,使用其他容器的IP、env等信息\r\n--lxc-conf=[]:指定容器的配置文件,只有在指定--exec-driver=lxc时使用\r\n--net=\"bridge\":容器网络设置:\r\nbridge - 使用docker daemon指定的网桥\r\nhost - 容器使用主机的网络\r\ncontainer:NAME_or_ID > 使用其他容器的网路，共享IP和PORT等网络资源\r\nnone - 容器使用自己的网络（类似--net=bridge），但是不进行配置\r\n\r\n--privileged=false指定容器是否为特权容器,特权容器拥有所有的capabilities\r\n--restart=\"no\"，指定容器停止后的重启策略:\r\nno - 容器退出时不重启\r\non-failure - 只在容器以非0状态码退出时重启。可选的，可以退出docker daemon尝试重启容器的次数\r\nalways – 不管退出状态码是什么始终重启容器。当指定always时，docker daemon将无限次数地重启容器。容器也会在daemon启动时尝试重启，不管容器当时的状态如何。\r\nunless-stopped – 不管退出状态码是什么始终重启容器，不过当daemon启动时，如果容器之前已经为停止状态，不要尝试启动它。\r\n\r\n--rm=false指定容器停止后自动删除容器(不支持以docker run -d启动的容器)\r\n--sig-proxy=true 设置由代理接受并处理信号，但是SIGCHLD、SIGSTOP和SIGKILL不能被代理\r\n```\r\n\r\n### docker inspect\r\n\r\n- 获取容器/镜像的元数据\r\n```shell\r\ndocker inspect [OPTIONS] NAME|ID [NAME|ID...]\r\nOPTIONS说明：\r\n-f :指定返回值的模板文件。\r\n-s :显示总的文件大小。\r\n--type :为指定类型返回JSON。\r\n```\r\n\r\n### docker top\r\n\r\n- 查看容器中运行的进程信息\r\n```shell\r\ndocker top container_id\r\n```\r\n\r\n### docker attach\r\n\r\n- 连接到正在运行中的容器\r\n```shell\r\ndocker attach container_id\r\n```\r\n\r\n### docker wait\r\n\r\n- 阻塞运行直到容器停止，然后打印出它的退出代码\r\n```shell\r\ndocker wait containser_id\r\n```\r\n\r\n### docker events\r\n\r\n- 从服务器获取实时事件\r\n```shell\r\ndocker events OPTIONS\r\n\r\nOPTIONS说明：\r\n-f ：根据条件过滤事件；\r\n--since ：从指定的时间戳后显示所有事件;\r\n--until ：流水时间显示到指定的时间为止；\r\ndocker events --since=\"1467302400\"\r\n```\r\n\r\n### docker logs\r\n\r\n- 查看日志\r\n```shell\r\ndocker logs [OPTIONS] CONTAINER\r\nOPTIONS说明：\r\n--details 显示更多的信息\r\n-f, --follow 跟踪实时日志\r\n--since string 显示自某个timestamp之后的日志，或相对时间，如42m（即42分钟）\r\n--tail string 从日志末尾显示多少行日志，默认是all\r\n-t, --timestamps 显示时间戳\r\n--until string 显示自某个timestamp之前的日志，或相对时间，如42m（即42分钟）\r\n\r\n# 查看指定时间后的日志，只显示最后100行：\r\ndocker logs -f -t --since=\"2018-02-08\" --tail=100 CONTAINER_ID\r\n# 查看最近30分钟的日志:\r\ndocker logs --since 30m CONTAINER_ID\r\n# 查看某时间之后的日志：\r\ndocker logs -t --since=\"2018-02-08T13:23:37\" CONTAINER_ID\r\n# 查看某时间段日志：\r\ndocker logs -t --since=\"2018-02-08T13:23:37\" --until \"2018-02-09T12:23:37\" CONTAINER_ID\r\n```\r\n\r\n### docker port\r\n\r\n- 列出指定的容器的端口映射\r\n```shell\r\ndocker port container_id\r\n```\r\n\r\n### docker commit\r\n\r\n- 提交\r\n```shell\r\ndocker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]\r\n\r\nOPTIONS说明：\r\n-a :提交的镜像作者；\r\n-c :使用Dockerfile指令来创建镜像；\r\n-m :提交时的说明文字；\r\n-p :在commit时，将容器暂停。\r\n\r\n# 将容器a404c6c174a2 保存为新的镜像,并添加提交人信息和说明信息。\r\ndocker commit -a \"runoob.com\" -m \"my apache\" a404c6c174a2 mymysql:v1\r\n```\r\n\r\n### docker cp\r\n\r\n- 容器与主机之间的数据拷贝\r\n```shell\r\n# 将主机/www/runoob目录拷贝到容器96f7f14e99ab的/www目录下。\r\ndocker cp /www/runoob 96f7f14e99ab:/www/\r\n```\r\n\r\n### docker diff\r\n\r\n- 查看容器文件结构更改\r\n```shell\r\ndocker diff mymysql\r\n```\r\n\r\n### docker build\r\n\r\n- 使用 Dockerfile 创建镜像\r\n```shell\r\ndocker build\r\n--build-arg=[] :设置镜像创建时的变量；\r\n--cpu-shares :设置cpu使用权重；\r\n--cpu-period :限制CPU CFS周期；\r\n--cpu-quota :限制CPU CFS配额；\r\n--cpuset-cpus :指定使用的CPU id；\r\n--cpuset-mems :指定使用的内存id；\r\n--disable-content-trust :忽略校验，默认开启；\r\n-f :指定要使用的Dockerfile路径；\r\n--force-rm :设置镜像过程中删除中间容器；\r\n--isolation :使用容器隔离技术；\r\n--label=[] :设置镜像使用的元数据；\r\n-m :设置内存最大值；\r\n--memory-swap :设置Swap的最大值为内存+swap，\"-1\"表示不限swap；\r\n--no-cache :创建镜像的过程不使用缓存；\r\n--pull :尝试去更新镜像的新版本；\r\n--quiet, -q :安静模式，成功后只输出镜像 ID；\r\n--rm :设置镜像成功后删除中间容器；\r\n--shm-size :设置/dev/shm的大小，默认值是64M；\r\n--ulimit :Ulimit配置。\r\n--squash :将Dockerfile中所有的操作压缩为一层。\r\n--tag, -t: 镜像的名字及标签，通常name:tag或者name格式；可以在一次构建中为一个镜像设置多个标签。\r\n--network: 默认default。在构建期间设置RUN指令的网络模式\r\n```\r\n\r\n### docker login\r\n\r\n- 登陆到一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub\r\n```shell\r\n# -u:登陆的用户名 -p:登陆的密码\r\ndocker login -u -p\r\n```\r\n\r\n### docker logout\r\n\r\n- 登出一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库Docker Hub\r\n```shell\r\ndocker logout\r\n```\r\n\r\n### docker tag\r\n\r\n- 标记本地镜像，将其归入某一仓库\r\n```shell\r\ndocker tag\r\n```\r\n\r\n## Dockerfile\r\n\r\n1. 文件没有后缀，名字就是Dockerfile\r\n2. 命令约定全部使用大写，如RUN,ADD,FROM\r\n3. 第一条命令必需是FROM，作用是指定在哪个基础镜像上创建镜像。\r\n4. 注释以“#”形状\r\n\r\n### 常用参数/命令\r\n\r\n#### FROM\r\n\r\n语法：`FROM 镜像名`,最简单的命令，指定在哪个基础镜像上创建镜像\r\n\r\n例：`FROM livingobjects/jre8`,在jre8镜像基础上创建自己镜像。\r\n\r\n#### RUN\r\n\r\n它接受命令作为参数并用于创建镜像,RUN命令用于创建镜像。在镜像构建的过程中执行,这个指令有两种格式\r\n\r\n第一种形式：\r\n\r\n```text\r\nRUN chown user2:user2 /home/webapi (以shell形式执行命令，等同于/bin/sh -c);\r\n```\r\n\r\n第二种形式：\r\n\r\n```text\r\nRUN [\"executable\",\"param1\", \"param2\"]\r\n```\r\n\r\n(等同于exec命令形式)，注意此处必须是双引号(\")，因为这种格式被解析为JSON数组。\r\n\r\n#### CMD\r\n\r\n语法：`CMD [\"executable\", \"param1\", \"param2\"?]`\r\n\r\n1. 在镜像构建容器后执行\r\n2. 只能存在一条CMD命令\r\n\r\n例：`CMD exec java -Djava.security.egd=file:/dev/./urandom -jar /app.jar`\r\n\r\n#### ENTRYPOINT\r\n\r\n语法：`ENTRYPOINT [\"executable\", \"param1\", \"param2\"?]`,这个命令和CMD功能一样。区别在于ENTRYPOINT后面携带的参数不会被docker run 提供的参数覆盖，而CMD会被覆盖。\r\n\r\n例：`ENTRYPOINT [\"java\",\"-Djava.security.egd=file:/dev/./urandom\",\"-jar\",\"/app.jar\"]`\r\n\r\n\r\n#### CMD 与 ENTRYPOINT\r\n\r\n二者的区别看：[docker CMD ENTRYPOINT区别终极解读](https://blog.csdn.net/u010900754/article/details/78526443)\r\n\r\n从根本上说, ENTRYPOINT和CMD都是让用户指定一个可执行程序, 这个可执行程序在container启动后自动启动。实际上, 如果你想让自己制作的镜像自动运行程序(不需要在docker run后面添加命令行指定运行的命令), 你必须在Dockerfile里面，使用ENTRYPOINT或者CMD命令。在命令行启动docker镜像时, 执行其他命令行参数，覆盖默认的CMD。和CMD类似, 默认的ENTRYPOINT也在docker run时, 也可以被覆盖. 在运行时, 用--entrypoint覆盖默认的ENTRYPOINT。\r\n\r\ndockerfile中的CMD命令被覆盖：\r\n\r\n![img](https://pic4.zhimg.com/v2-4a8d016349ee808822659ca2bf66fab3_r.jpg)\r\n\r\n**CMD**：提供了容器默认的执行命令。Dockerfile只允许使用一次CMD指令。使用多个CMD会抵消之前所有的指令，只有最后一个指令生效。CMD有三种形式：\r\n\r\n```text\r\nCMD [\"executable\",\"param1\",\"param2\"] (exec form, thisis the preferred form)\r\n```\r\n\r\n**ENTRYPOINT**：配置给容器一个可执行的命令，这意味着在每次使用镜像创建容器时一个特定的应用程序可以被设置为默认程序。同时也意味着该镜像每次被调用时仅能运行指定的应用。类似于CMD，Docker只允许一个ENTRYPOINT，多个ENTRYPOINT会抵消之前所有的指令，只执行最后的ENTRYPOINT指令。语法如下：\r\n\r\n```text\r\nENTRYPOINT [\"executable\", \"param1\",\"param2\"]\r\n```\r\n\r\n#### ADD\r\n\r\n语法：`ADD [source directory or URL] [destination directory]`\r\n它的基本作用是从源系统的文件系统上复制文件到目标容器的文件系统。\r\n\r\n1. 如果源是一个URL，那该URL的内容将被下载并复制到容器中。\r\n2. 如果如果文件是可识别的压缩格式，则docker会帮忙解压缩\r\n3. 如果要ADD本地文件，则本地文件必须在docker build PATH指定的path目录下\r\n4. ADD只有在build镜像的时候运行一次，后面运行container的时候不会再重新加载了\r\n\r\nADD指令不仅能够将构建命令所在的主机本地的文件或目录，而且能够将远程URL所对应的文件或目录，作为资源复制到镜像文件系统。所以，可以认为ADD是增强版的COPY，支持将远程URL的资源加入到镜像的文件系统。\r\n\r\nexec格式用法（推荐）：\r\n\r\n```text\r\nADD [\"<src>\",... \"<dest>\"]\r\n```\r\n\r\n特别适合路径中带有空格的情况。\r\n\r\nshell格式用法：\r\n\r\n```text\r\nADD <src>... <dest>\r\n```\r\n\r\n对于从远程URL获取资源的情况，由于ADD指令不支持认证，如果从远程获取资源需要认证，则只能使用RUN wget或RUN curl替代。另外，如果源路径的资源发生变化，则该ADD指令将使Docker Cache失效，Dockerfile中后续的所有指令都不能使用缓存。因此尽量将ADD指令放在Dockerfile的后面。\t\r\n\r\n\r\n#### EXPOSE\r\n\r\n语法：`EXPOSE [port]`,暴露容器内部端口\r\n\r\n例：`EXPOSE 5000`,暴露的是容器内部端口，不是主机端口，如果外部想使用这个端口需要在运行时映射，如下：`docker run -d -p 127.0.0.1:8080:5000 hello-world`。指令用于标明，这个镜像中的应用将会侦听某个端口，并且希望能将这个端口映射到主机的网络界面上。但是，为了安全，docker run命令如果没有带上响应的端口映射参数，docker并不会将端口映射到宿主机。\r\n\r\n#### MAINTAINER\r\n\r\n语法：`MAINTAINER 作者名`,申明作者，辅助使用，放丰FROM命令后面\r\n\r\n#### WORKDIR\r\n\r\n语法：`WORKDIR /path`,指定容器工作目录\r\n\r\n#### VOLUME\r\n\r\n语法：`VOLUME [\"/dir_1\", \"/dir_2\" ..]`可以将本地文件夹或者其他container的文件夹挂载到container中，容器即可以访问该目录\r\n\r\n```text\r\nVOLUME [\"/data\"] (exec格式指令)\r\n```\r\n\r\nVOLUME指令创建一个可以从本地主机或其他容器挂载的挂载点。经常用到的是`docker run -ti -v /data:/data nginx:1.12 bash`时指定本地路径和容器内路径的映射。\r\n\r\n#### ENV\r\n\r\n语法：`ENV key value`,设置变量，可能在容器和脚本里直接使用\r\n\r\n例：`ENV WORKPATH /tmp`或`ENV abc=bye def=$abc`\r\n\r\n第一种用法用于设置单个变量(第一个空格前为key，之后都是value,包括后面的空格)，第二种用于同时设置多个变量(空格为分隔符，value中包含空格时可以用双引号把value括起来，或者在空格前加反斜线)，当需要同时设置多个环境变量时推荐使用第二种格式。这些环境变量可以通过docker run命令的--env参数来进行修改。\r\n\r\n#### ARG\r\n\r\n```text\r\nARG <name>[=<default value>]\r\n```\r\n\r\nARG指令设置一些创建镜像时的参数，这些参数可以在执行docker build命令时通过`--build-arg = `设置，如果指定的创建参数在Dockerfile中没有指定，创建时会输出错误信息: One or more build-args were not consumed, failing build.\r\n\r\nDockerfile作者可以为ARG设置一个默认参数值，当创建镜像时如果没有传入参数就会使用默认值：\r\n\r\n```text\r\nFROM busybox\r\n```\r\n\r\n我们可以使用ARG或者ENV指令来指定RUN指令使用的变量。我们可以使用ENV定义与ARG定义名称相同的变量来覆盖ARG定义的变量值。如下示例，我们执行\r\n\r\n```text\r\ndocker build --build-arg CONT_IMG_VER=v2.0.1 Dockerfile\r\n```\r\n\r\n后将获取到的CONTIMGVER变量值为v1.0.0:\r\n\r\n```text\r\nFROM ubuntu\r\n```\r\n\r\n#### WORKDIR\r\n\r\n```text\r\nWORKDIR /path/to/workdir\r\n```\r\n\r\nWORKDIR指令用来设置Dockerfile中任何使用目录的命令的当前工作目录，此目录如果不存在就会被自动创建，即使这个目录不被使用\r\n\r\n#### COPY\r\n\r\nCOPY指令能够将构建命令所在的主机本地的文件或目录，复制到镜像文件系统。\r\n\r\nexec格式用法（推荐）：\r\n\r\n```text\r\nCOPY [\"<src>\",... \"<dest>\"]\r\n```\r\n\r\n特别适合路径中带有空格的情况。\r\n\r\nshell格式用法：\r\n\r\n```text\r\nCOPY <src>... <dest>\r\n```\r\n\r\n\r\n### 示例\r\n\r\n```dockerfile\r\nFROM anapsix/alpine-java:8_server-jre_unlimited\r\nVOLUME /tmp\r\nEXPOSE 19990\r\nADD applet-provider.jar app.jar\r\nENTRYPOINT [\"java\",\"-jar\",\"/app.jar\"]\r\n```\r\n\r\n```shell\r\n#!/bin/bash\r\necho \"自动构建pc包的镜像和运行容器\"\r\n#1.停掉容器和删掉容器\r\nid=$(docker ps |grep mdjz  | tail -n 1| awk 'RS {print $1 }')\r\necho $id\r\n#杀掉进程\r\necho \"docker kill $id\"\r\ndocker kill $id\r\n#删除容器\r\necho \"docker rm $id\"\r\ndocker rm $id\r\n#删掉镜像\r\nmid=$(docker images |grep mdjz  | tail -n 1| awk 'RS {print $1 }')\r\necho \"docker rmi $mid\"\r\ndocker rmi $mid\r\n#重新打包镜像\r\ndocker build -f /composetest/pc/Dockerfile -t mdjz /composetest/pc/\r\n#运行容器\r\necho \"run app docker run -itd --name mdjz --restart always  -p  19901:19901 \"\r\ndocker run -itd --name mdjz --network=my-net --restart always  -p  19901:19901 mdjz\r\n\r\n```\r\n\r\n## 其他\r\n\r\n### docker加速命令\r\n\r\n```shell\r\ncurl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://f1361db2.m.daocloud.io\r\n或\r\nvim /etc/docker/daemon.json\r\n{\r\n  \"registry-mirrors\": [\"https://registry.docker-cn.com\"]\r\n}\r\n\r\n```\r\n> 其他站点\r\n> http://hub-mirror.c.163.com\r\n> https://3laho3y3.mirror.aliyuncs.com\r\n> http://f1361db2.m.daocloud.io\r\n> https://mirror.ccs.tencentyun.com\r\n> https://docker.mirrors.ustc.edu.cn\r\n\r\n### 与Spring Boot\r\n\r\n- [一键部署Spring Boot到远程Docker容器](https://mp.weixin.qq.com/s/15ZAVUg5DfcF53QpEetT7Q)\r\n- [Jenkins+Docker一键自动化部署SpringBoot项目](https://mp.weixin.qq.com/s/dP-c3twzR0PMUvPWZA-U0Q)\r\n- [搭建SpringBoot项目并将其Docker化](https://mp.weixin.qq.com/s/CXUwpTbAVoXEeB7EcrCjAw)\r\n- [SpringBoot使用Docker快速部署项目](https://mp.weixin.qq.com/s?__biz=Mzg2MDYzODI5Nw==&mid=2247493762&idx=1&sn=114663a4a13ba5bb27d05e0d77de37c1&source=41#wechat_redirect)\r\n- [Docker部署Spring Boot项目的2种方式！](https://mp.weixin.qq.com/s/du2sypGQczJh7gQz_4IX9g)\r\n- [SpringBoot项目构建Docker镜像深度调优](https://mp.weixin.qq.com/s?__biz=Mzg2MDYzODI5Nw==&mid=2247493962&idx=1&sn=af6c945d629003cfd30564698c017598&source=41#wechat_redirect)\r\n- [还在手动部署springboot项目？不妨试试它，让你部署项目飞起来！](https://mp.weixin.qq.com/s/01SZo3NNf5zuAC8wAI6C-g)\r\n- [Docker+Spring Boot+FastDFS搭建一套分布式文件服务器，太强了！](https://mp.weixin.qq.com/s/HSRIYQVKR9TGtwetd3LU5w)\r\n\r\n\r\n### 相关文章\r\n\r\n- [图解Docker架构，傻瓜都能看懂！](https://mp.weixin.qq.com/s/ELZo2z4fHonoBGXQI0M9CA)\r\n- [构建Java镜像的10个最佳实践](https://mp.weixin.qq.com/s/gmZDBuYDXnNdykEx66Y0Cw)\r\n- [10个冷门但又非常实用的Docker使用技巧！！](https://mp.weixin.qq.com/s/LOmqsoBJd7h1HPwf0i1uwQ)\r\n- [Docker实战总结](https://mp.weixin.qq.com/s/tTsizeLeVyvQ44GXMNqrjA)\r\n- [Docker从入门到干活，看这一篇足矣](https://mp.weixin.qq.com/s/t81enr-ypBxk1K4lYqWZww)\r\n- [如何编写最佳的Dockerfile](https://mp.weixin.qq.com/s/x-M5iKvvuseIQwUdVmxSPQ)\r\n- [Docker：Docker Compose详解](https://www.jianshu.com/p/658911a8cff3)\r\n- [CentOS/Ubuntu安装Docker和Docker Compose](https://mp.weixin.qq.com/s/fB59zXK7cPBt1asSyUpqDg)\r\n- [DaoCloud安装docker指南](http://guide.daocloud.io/dcs/docker-9152677.html)\r\n- [Docker常用命令，还有谁不会？](https://mp.weixin.qq.com/s/fzlNnJe9SMA5k3TDXOfZUA)\r\n- [一款吊炸天的Docker图形化工具，太强大](https://mp.weixin.qq.com/s/PpI7_fY5ACjmtmnlqr7ZMQ)\r\n- [5款顶级Docker容器GUI管理工具！免费又好用](https://mp.weixin.qq.com/s/w0sFaHApOSrwgva0886ijQ)\r\n- [Docker轻量级编排创建工具Humpback](https://mp.weixin.qq.com/s/rAOsia2LU2_Fl4vrjQ2tvA)\r\n- [带着问题学Kubernetes架构！](https://mp.weixin.qq.com/s/6smzsvYSbRvSPcpbfnH98A)\r\n- [为什么大家都在学习k8s](https://mp.weixin.qq.com/s/B2tIs6YitA93iYxEZ_8Ovw)\r\n- [Kuboard-Kubernetes多集群管理界面](https://kuboard.cn/)\r\n- [图文详解Kubernetes，傻瓜都能看懂！](https://mp.weixin.qq.com/s/WWRp-e9QPcLg8-m-V3UU1Q)\r\n- [Kubernetes缺少的多租户功能，你可以通过这些方式实现](https://mp.weixin.qq.com/s/8UJnsx0NJyxlKXeduhg5Yw)\r\n- [IDEA使用Docker插件，实现一键自动化部署](https://mp.weixin.qq.com/s/yg5ACCeeyJa0AVP1LatUhA)\r\n- [Docker有几种网络模式](https://mp.weixin.qq.com/s/KU3bpxiNbHGJQ_XVRqsedg)\r\n","categories":[{"name":"技术栈","path":"api/categories/技术栈.json"}],"tags":[{"name":"安装","path":"api/tags/安装.json"}]}