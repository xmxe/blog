{"title":"Oracle相关及常用函数","slug":"Oracle相关及常用函数","date":"2022-09-27T02:32:36.536Z","updated":"2024-07-19T06:57:05.344Z","comments":true,"path":"api/articles/Oracle相关及常用函数.json","excerpt":null,"covers":"https://gimg2.baidu.com/image_search/src=http%3A%2F%2F29520719.s21i.faiusr.com%2F2%2FABUIABACGAAgpufK7QUoj7DrqQIw6Ac4_QQ%21800x800.jpg&refer=http%3A%2F%2F29520719.s21i.faiusr.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1669537603&t=31ddd7a1992896268a14e72c35ed60ed","content":"\r\n\r\n## Sys和System用户区别\r\n\r\n- **Sys**: 拥有DBA、SysDBA、Sysoper（系统操作员）角色或权限，是Oracle权限最高的用户，只能以SysDBA或Sysoper登录，不能以Normal形式登录。\r\n- **System**: 拥有DBA、Sysdba权限或角色，可以以普通用户的身份登录。\r\n\r\n## Sysdba、Sysoper、DBA区别\r\n\r\n- Sysdba用户: 可以改变字符集、创建删除数据库、登录之后用户是SYS（shutdown、startup）\r\n- Sysoper: 用户不可改变字符集、不能创、删数据库、登陆之后用户是PUBLIC（shutdown、startup）\r\n- DBA用户: 只有在启动数据库后才能执行各种管理工作。\r\n- Sysdba> Sysoper>普通的DBA\r\n\r\n## Oracle中的角色\r\n\r\n1. CONNECT\r\n2. RESOURCE\r\n3. DBA\r\n4. EXP_FULL_DATABASE\r\n5. IMP_FULL_DATABASE\r\n6. DELETE_CATALOG_ROLE\r\n7. EXECUTE_CATALOG_ROLE\r\n8. SELECT_CATALOG_ROLE\r\n\r\n- **CONNECT角色**：--是授予最终用户的典型权利，最基本的\r\n\r\n```sql\r\nALTER SESSION --修改会话\r\nCREATE CLUSTER --建立聚簇\r\nCREATE DATABASE LINK --建立数据库链接\r\nCREATE SEQUENCE --建立序列\r\nCREATE SESSION --建立会话\r\nCREATE SYNONYM --建立同义词\r\nCREATE VIEW --建立视图www_bitscn_com中国.网管联盟\r\n```\r\n\r\n- **RESOURCE角色**： --是授予开发人员的\r\n\r\n```sql\r\nCREATE CLUSTER --建立聚簇\r\nCREATE PROCEDURE --建立过程\r\nCREATE SEQUENCE --建立序列\r\nCREATE TABLE --建表\r\nCREATE TRIGGER --建立触发器\r\nCREATE TYPE --建立类型\r\n```\r\n\r\n- **DBA角色**：拥有系统所有系统级权限（系统管理员）\r\n\r\n- **IMP_FULL_DATABASE角色、EXP_FULL_DATABASE角色**：\r\n\r\n```sql\r\nBACKUP ANY TABLE --备份任何表\r\nEXECUTE ANY PROCEDURE --执行任何操作\r\nSELECT ANY TABLE --查询任何表\r\n```\r\n\r\n- **SELECT_CATALOG_ROLE角色**：具有从数据字典查询的权利，(尤其是此处数据字典：就是数据库运行时的各种信息参考：Oracle 11g体系结构--数据字典)\r\n\r\n- **EXECUTE_CATALOG_ROLE角色**：具有从数据字典中执行部分过程和函数的权利。\r\n\r\n\r\n## 分区表\r\n\r\n当表中的数据量不断增大，查询数据的速度就会变慢，应用程序的性能就会下降，这时就应该考虑对表进行分区。表进行分区后，逻辑上表仍然是一张完整的表，只是将表中的数据在物理上存放到多个表空间(物理文件上)，这样查询数据时，不至于每次都扫描整张表。\r\n\r\n## PL/SQL /Oracle乱码问题解决方案\r\n\r\n```sql\r\nSelect userenv(‘language’) from dual; -- 查看服务器端编码\r\n\r\nselect * from V$NLS_PARAMETERS；-- 查看NLS_LANGUAGE的值与第一个的查询结果是否一致，假如不一致需要设置环境变量，变量名：NLS_LANG 变量值：第1个查到的值 重启PL/SQL(假如在乱码之前已经插入数据，那么配置环境变量后依然乱码，需要删除数据重新导入)\r\n```\r\n\r\n## Oracle的操作\r\n\r\n**cmd进入oracle** \r\n\r\n```sql\r\nsqlplus 账户名/密码 as 角色名 --（sys用户必须带as sysdba）例:sqlplus sys/admin as sysdba\r\n\r\nexit --退出\r\n```\r\n\r\n**用户账号相关操作**\r\n\r\n```sql\r\n-- 创建用户\r\ncreate user xxx identified by xxx;\r\n-- 授权\r\ngrant create session, connect, resource to xxx;\r\n-- 删除用户 加cascade可以一同删除用户数据\r\ndrop user username cascade;\r\n-- 解锁登陆账号\r\nalter user scott account unlock;\r\n-- 冻结登陆账号\r\nalter user dbaName account lock;\r\n-- 修改登录账号密码\r\nalter user dbaName identified by \"password\";\r\n\r\n-- 查看所有用户相关信息\r\nSELECT * FROM DBA_USERS;-- 查询DBA用户\r\nSELECT * FROM ALL_USERS;-- 查询所有用户\r\nSELECT * FROM USER_USERS;-- 查询系统用户\r\n\r\n-- 查看用户系统权限\r\nSELECT * FROM DBA_SYS_PRIVS;\r\nSELECT * FROM USER_SYS_PRIVS;\r\n\r\n-- 查看用户对象或角色权限\r\nSELECT * FROM DBA_TAB_PRIVS;\r\nSELECT * FROM ALL_TAB_PRIVS;\r\nSELECT * FROM USER_TAB_PRIVS;\r\n\r\n-- 查看所有角色\r\nSELECT * FROM DBA_ROLES;\r\n\r\n-- 查看用户或角色所拥有的角色\r\nSELECT * FROM DBA_ROLE_PRIVS;\r\nSELECT * FROM USER_ROLE_PRIVS;\r\nselect * from role_sys_privs\r\n```\r\n\r\n**表空间相关**\r\n\r\n```sql\r\nSelect * FROM Dba_Tablespaces; -- 查看所有的表空间\r\nSelect * FROM DBA_DATA_FILES; -- 查看所有的表空间以及对应的地址\r\n\r\n-- 创建临时表空间\r\ncreate temporary tablespace user_temp\r\ntempfile 'D:\\APP\\ADMINISTRATOR\\ORADATA\\ORCL\\user_temp.dbf'\r\nsize 50m  --初始空间50m\r\nautoextend on -- on为表空间自动扩展\r\nnext 50m maxsize 20480m -- 每次50m最大2048m\r\nextent management local; -- 本地管理表空间\r\n\r\n-- 创建数据表空间\r\ncreate tablespace user_data\r\nlogging\r\ndatafile 'D:\\APP\\ADMINISTRATOR\\ORADATA\\ORCL\\user_data.dbf'\r\nsize 50m\r\nautoextend on\r\nnext 50m maxsize 20480m\r\nextent management local;\r\n\r\n-- 创建用户指定表空间\r\ncreate user 用户名 identified by 密码 default tablespace 表空间名；\r\n```\r\n\r\n## Oracle相关函数\r\n\r\n### wm_concat()行转列\r\n\r\nwm_concat()函数是oracle中独有的,mysql中有一个group_concat()函数。这两个函数的作用是相同的，它们的功能是：实现行转列功能，即将查询出的某一列值使用逗号进行隔开拼接，成为一条数据\r\n\r\n```sql\r\n-- 根据年龄获取学生的分数\r\nselect age,to_char(wm_concat(name)) as name,to_char(wm_concat(score)) as score from student t group by age;\r\n-- age  name     score\r\n-- 18  张三,李四  81,82\r\n-- 19  王五,赵六  67,90\r\n```\r\n\r\n### decode\r\n\r\n```sql\r\ndecode(c1,c2,c3,c4,c5,c6,c7....,C2x,C2x+1 ,C2x+2)\r\n```\r\n从c1之后开始,每两个参数看做是一组数,拿每组数的第一个参数和c1比较,如果相同则返回第二个参数:比如,如果c2==c1则return c3如果该组数的第一个参数和c1不相同,则比较下一组:比如,如果c2<>C1继续判断C4==C1? 相同return c5\r\n\r\n```sql\r\ndecode(type,'a','11','b','12','c','13','d','14','e','15',type)\r\n```\r\n\r\n### 树形查询\r\n\r\n```sql\r\nselect area_code from (select * from tableA where isvalid=1) start with area_code = 5002 connect by  prior parent_area_code = area_code;\r\n\r\n-- 父子关系查询（start with connect by prior）\r\nselect * from tabname t where 条件 start with t.org_parent_code='10000008' connect by t.org_code = prior t.org_parent_code\r\n```\r\n\r\n### 数值函数\r\n\r\n- mod(x,y) 取模 求余数\r\n- nvl(x,y) 如果x的值为空,则返回y\r\n```sql\r\nselect ename,sal,comm,sal+nvl(comm,0) from emp;\r\n-- 数值列可以直接做加减乘除运算,如果数值列值为null则加减乘除后也是null需要使用nvl函数去空\r\n```\r\n\r\n### 精确指定位数的函数\r\n\r\n- round(c1,c2) 能够四舍五入\r\n- trunc(c1,c2) 直接舍去\r\n  \r\n```sql\r\nc2>0 : c2表示有多少位小数\r\nselect round(21.23512,2) from dual;   --  21.24\r\nselect trunc(21.23512,2) from dual;   --  21.23\r\n```\r\nc20 : c2表示小数点向左精确c2位\r\n```sql\r\nselect round(2163.512,-2) from dual;  --  2200\r\nselect trunc(2163.512,-2) from dual;  --  2100\r\n```\r\nc2如果不存在,表示只保留整数部分\r\n```sql\r\nselect round(2163.512,0) from dual;  --  2164\r\nselect round(2163.512) from dual;    -- 2164\r\n```\r\n\r\n### 字符函数\r\n\r\n- length() 求字符串长度\r\n\r\n```sql\r\n-- 查询姓名长度为5个字符的员工姓名\r\nselect ename,length(ename) from emp where length(ename)=5;\r\n```\r\n\r\n- lower() 全部转为小写\r\n- upper() 全部转为大写\r\n- initcap() 单词首字母大写其他字母小写\r\n```sql\r\nselect ename,lower(ename),upper(ename),initcap(ename) from emp\r\n```\r\n\r\n- 截取字符串:substr(c1,c2[,c3]) \r\nc1: 原字符串\r\nc2: 从哪个位置开始截取\r\nc3: 截取长度(默认截取到最后)\r\n\r\n```sql\r\n-- 查询员工姓名,截取员工姓名的第一个字符,再截取姓名的最后一个字符\r\nselect ename,sal,substr(ename,1,1),substr(ename,length(ename)) from emp;\r\n-- 查询员工姓名,截取员工姓名中最中间的一个字符(偶数个截取后一位)\r\nselect ename, substr(ename,trunc(length(ename)/2)+1,1) from emp;\r\n```\r\n\r\n- 索引字符串:instr(c1,c2,c3,c4)\r\nc1: 原字符串\r\nc2: 要查找的字符串\r\nc3: 从哪个位置开始查找,默认值1\r\nc4: 第几次出现 默认值1\r\n\r\n```sql\r\n-- 查询员工姓名中带有E字符的员工\r\nselect * from emp where ename like '%E%';\r\nselect * from emp where instr(ename,'E')<>0;\r\n\r\nselect instr('sanhaoxuesheng','aow') from dual;\r\n-- instr能够用来替代like实现模糊查询\r\nselect * from emp where instr(ename,'%')<>0;--\r\n```\r\n\r\n- 拼接字符串:\r\n1. 符号: ||\r\n2. 函数: concat(c1,c2) 将c1 c2拼接为一个字符串\r\n\r\n```sql\r\nselect concat(concat('123','abc'),'eee') from dual;\r\nselect '123' || 'abc' || 'eee' from dual;\r\n```\r\n\r\n### 日期函数\r\n\r\n- add_months(c1,c2)\r\nc1:日期类型\r\nc2:整数,在c1日期的基础上增减c2个月份\r\n\r\n```sql\r\n-- 查询当前系统时间之前的一个月\r\nselect add_months(sysdate,-1) from dual;\r\n-- 查询十年后的今天\r\nselect add_months(sysdate,120) from dual;\r\n```\r\n\r\n- months_between(c1,c2)：c1 c2都是日期类型，计算两个日期之间相差多少个月份\r\n\r\n```sql\r\nselect round(months_between(sysdate,hiredate),2) from emp;\r\n```\r\n\r\n- last_day(date)\r\n\r\n```sql\r\n-- 查询给定日期所在月份的最后一天\r\nselect last_day(sysdate) from dual;\r\n-- 查询下一个月的第一天 \r\nselect last_day(sysdate)+1 from dual;\r\n-- 查询上一个月的第一天 \r\nselect last_day(add_months(sysdate,-2))+1 from dual;\r\n```\r\n\r\n- 计算日期:\r\nround(c1,c2): 四舍五入 trunc(c1,c2): 直接舍去\r\nc1:日期类型的值 \r\nc2:字符类型,日期格式 在c1日期的基础上,精确到c2指定的日期格式,如果比c2低的日期格式,默认是初始值\r\n\r\n```sql\r\n-- 将当前系统时间精确到年份\r\nselect round(sysdate,'yyyy') from dual;\r\n-- 如果当前时间是: 2017-2-11 13:00:00 //2017-1-1 00:00:00\r\n```\r\n\r\n- 查询本年度的一季度的起始日期\r\n\r\n```sql\r\nselect trunc(sysdate,'yyyy'),add_months(trunc(sysdate,'yyyy'),3) from dual;\r\n```\r\n\r\n- next_day(c1,c2) \r\nc1: 日期类型\r\nc2:字符或整数: 周期值,从c1日期来时,查找c2指定的周期的日期\r\n\r\n```sql\r\n-- 查询当前系统时间之后的第一个星期一\r\nselect sysdate,next_day(sysdate,'星期四') from dual;\r\n```\r\n\r\n**转换函数**\r\n\r\n- to_date(c1,c2)\r\n- to_timestamp(c1,c2)\r\nc1: 字符类型的日期\r\nc2:日期格式\r\n能够根据c2指定的格式将c1字符类型的日期转变为日期类型\r\n\r\n```sql\r\ninsert into emp(empno,hiredate) values(1001, to_date('2017-1-1','yyyy-dd-mm') );\r\ninsert into emp(empno,hiredate) values(1002, to_date('2017-1-1 12:21:20','yyyy-dd-mm hh24:mi:ss') );\r\n```\r\n\r\n- to_char()\r\n\r\n```sql\r\n-- 将一个数值转变为一个字符串\r\nselect * from emp where '1'=1;\r\nselect * from emp where '1'=to_char(1);\r\n\r\n-- 格式化字符串或数值\r\nselect to_char(2341212412,'$999,999,999,999.00') from dual;\r\n-- 第二个参数的长度必须大于第一个参数\r\nselect to_char(2341212412,'L999,999,999,999.00') from dual;\r\n\r\n-- 与日期的转换\r\n-- to_char(c1,c2) c1: 日期类型的值 c2:日期格式 按照c2指定的日期格式,从c1中取值\r\n\r\n-- 查询当前系统时间的月份\r\nselect to_char(sysdate,'month') from dual;\r\n-- 查询当前系统时间的年月日\r\nselect to_char(sysdate,'yyyy-mm-dd') from dual;\r\n-- 查询当前系统时间是本年度第几天\r\nselect to_char(sysdate,'yyyy-ddd-dd-d') from dual;\r\n```\r\n\r\n- 对比to_date 和to_char:\r\n  to_date('2017','yyyy') 将字符串转变成日期 第一个参数是:字符串类型的值\r\n  to_char(sysdate,'yyyy') 按照指定的格式将日期转变为字符串 第一个参数是:日期值\r\n\r\n\r\n## 关键字\r\n\r\n- minus从第一个查询结果中,减去第二个查询结果中重复出现的数据 剩余:第一个查询结果中的部分数据\r\n\r\n```sql\r\nselect * from emp where ename like '%E%'\r\nminus \r\nselect * from emp where ename like '%S%';\r\n```\r\n\r\n- intersect 交集\r\n\r\n```sql\r\nselect * from emp where ename like '%E%'\r\nintersect\r\nselect * from emp where ename like '%S%';\r\n```\r\n\r\n## 创建表同时复制数据\r\n\r\n```sql\r\ncreate table 新表名(列名) as select 列名 from 旧表 where 条件;\r\n-- 如果表已存在，可以向已存在的表中插入数据：\r\ninsert into 表名(列名) select 列名 from 旧表 where 条件;\r\n```\r\n\r\n## 有则更新 无则新增\r\n根据源表对目标表进行匹配查询，匹配成功时更新，不成功时插入\r\n\r\n语法\r\nMERGE INTO 目标表 a USING 源表 b ON (a.字段1 = b.字段2 and a.字段n = b.字段n)\r\nWHEN MATCHED THEN UPDATE SET a.新字段 = b.字段 WHERE 限制条件 WHEN NOT MATCHED THEN INSERT (a.字段名1，a.字段名n) VALUES(b.字段值1, b.字段值n) WHERE 限制条件123456789\r\n\r\n例子:\r\n```sql\r\nMERGE INTO T_SCHE_PYTHON_JOB T1\r\nUSING (SELECT '1001' AS JOB_DEF_ID FROM dual) T2\r\nON ( T1.JOB_DEF_ID=T2.JOB_DEF_ID)\r\nWHEN MATCHED THEN\r\n    UPDATE SET T1.param = ${param}\r\nWHEN NOT MATCHED THEN \r\n    INSERT (JOB_DEF_ID,param) VALUES(1001,${param}); \r\n```","categories":[{"name":"数据库","path":"api/categories/数据库.json"}],"tags":[]}