{"title":"Nginx","slug":"Nginx","date":"2022-09-27T07:51:22.667Z","updated":"2024-07-01T08:32:41.568Z","comments":true,"path":"api/articles/Nginx.json","excerpt":null,"covers":"https://picx1.zhimg.com/v2-e68d524210343613129267bd2cb75a0d_1440w.jpg","content":"\r\n\r\n## Nginx安装\r\n\r\n### 离线安装\r\n\r\n#### 下载\r\n\r\n```shell\r\n# 下载nginx:\r\nwget http://nginx.org/download/nginx-1.8.1.tar.gz\r\n# 下载openssl:\r\nwget https://www.openssl.org/source/openssl-fips-2.0.16.tar.gz\r\n# 下载zlib:\r\nwget http://www.zlib.net/zlib-1.2.11.tar.gz\r\n# 下载pcre:\r\nwget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.39.tar.gz\r\n# 如果没有安装c++编译环境，还得安装，通过```yum install gcc-c++```完成安装\r\n```\r\n\r\n#### 编译安装\r\n\r\n```shell\r\n# openssl：\r\n[root@localhost] tar zxvf openssl-fips-2.0.16.tar.gz\r\n[root@localhost] cd openssl-fips-2.0.16\r\n[root@localhost] ./config && make && make install\r\n\r\n# pcre:\r\n[root@localhost] tar zxvf pcre-8.39.tar.gz\r\n[root@localhost] cd pcre-8.39\r\n[root@localhost]  ./configure && make && make install\r\n\r\n# zlib:\r\n[root@localhost]tar zxvf zlib-1.2.11.tar.gz\r\n[root@localhost] cd zlib-1.2.11\r\n[root@localhost]  ./configure && make && make install\r\n\r\n# 最后安装nginx\r\n[root@localhost]tar zxvf nginx-1.8.1.tar.gz\r\n[root@localhost] cd nginx-1.8.1\r\n[root@localhost]  ./configure && make && make install\r\n```\r\n\r\n#### 启动nginx\r\n\r\n```shell\r\n/usr/local/nginx/sbin/nginx\r\n/usr/local/nginx/sbin/nginx -s stop # 立即停止nginx，不保存相关信息\r\n/usr/local/nginx/sbin/nginx -s quit  # 正常退出nginx，保存相关信息\r\n/usr/local/nginx/sbin/nginx -s reload # 重启\r\n```\r\n> [Linux安装Nginx详细图解教程](https://www.cnblogs.com/lovexinyi8/p/5845017.html)\r\n\r\n#### 将nginx做成系统服务并且开机自启动\r\n\r\n由于是源码安装，需要手动创建nginx.service服务\r\n> 不止nginx，其他源码安装的想要实现开机自启动就在/lib/systemd/system目录下自定义服务即可\r\n```shell\r\nvim /lib/systemd/system/nginx.service\r\n# 编辑内容\r\n[Unit]\r\nDescription=nginx.service\r\nAfter=network.target\r\n\r\n[Service]\r\nType=forking\r\nExecStart=/usr/local/nginx/sbin/nginx\r\nExecReload=/usr/local/nginx/sbin/nginx -s reload\r\nExecStop=/usr/local/nginx/sbin/nginx -s quit\r\nPrivateTmp=true\r\n\r\n[Install]\r\nWantedBy=multi-user.target\r\n\r\n# 参数介绍：\r\n# [Unit]:服务的说明\r\n# Description:描述服务\r\n# After:描述服务类别\r\n# [Service]服务运行参数的设置\r\n# Type=forking是后台运行的形式\r\n# ExecStart为服务的具体运行命令\r\n# ExecReload为重启命令\r\n# ExecStop为停止命令\r\n# PrivateTmp=True表示给服务分配独立的临时空间\r\n# 注意：[Service]的启动、重启、停止命令全部要求使用绝对路径\r\n# [Install]运行级别下服务安装的相关设置，可设置为多用户，即系统运行级别为3\r\n```\r\n:wq! 保存退出。\r\n```shell\r\n# 设置开机启动\r\nsystemctl enable nginx.service\r\n# 其他命令\r\n# 启动nginx服务\r\nsystemctl start nginx.service　\r\n# 停止开机自启动\r\nsystemctl disable nginx.service\r\n# 查看服务当前状态\r\nsystemctl status nginx.service\r\n# 重新启动服务\r\nsystemctl restart nginx.service　\r\n# 查看所有已启动的服务\r\nsystemctl list-units --type=service\r\n```\r\n\r\n### Nginx安装手册\r\n#### nginx安装环境\r\nnginx是C语言开发，建议在linux上运行，本教程使用Centos6.5作为安装环境。\r\n\r\n- gcc。安装nginx需要先将官网下载的源码进行编译，编译依赖gcc环境，如果没有gcc环境，需要安装gcc：`yum install gcc-c++`\r\n\r\n- PCRE。PCRE(Perl Compatible Regular Expressions)是一个Perl库，包括perl兼容的正则表达式库。nginx的http模块使用pcre来解析正则表达式，所以需要在linux上安装pcre库。`yum install -y pcre pcre-devel`\r\n> pcre-devel是使用pcre开发的一个二次开发库。nginx也需要此库。\r\n\r\n- zlib\r\nzlib库提供了很多种压缩和解压缩的方式，nginx使用zlib对http包的内容进行gzip，所以需要在linux上安装zlib库。`yum install -y zlib zlib-devel`\r\n\r\n- openssl\r\nOpenSSL是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及SSL协议，并提供丰富的应用程序供测试或其它目的使用。nginx不仅支持http协议，还支持https（即在ssl协议上传输http），所以需要在linux安装openssl库。`yum install -y openssl openssl-devel`\r\n\r\n#### 编译安装\r\n将nginx-1.8.0.tar.gz拷贝至linux服务器。\r\n```shell\r\n# 解压\r\ntar -zxvf nginx-1.8.0.tar.gz\r\ncd nginx-1.8.0\r\n```\r\n1. configure：`./configure --help`查询详细参数（参考本教程附录部分：nginx编译参数）注意：上边将临时文件目录指定为/var/temp/nginx，需要在/var下创建temp及nginx目录,参数设置如下：\r\n```config\r\n./configure \\\r\n--prefix=/usr/local/nginx \\\r\n--pid-path=/var/run/nginx/nginx.pid \\\r\n--lock-path=/var/lock/nginx.lock \\\r\n--error-log-path=/var/log/nginx/error.log \\\r\n--http-log-path=/var/log/nginx/access.log \\\r\n--with-http_gzip_static_module \\\r\n--http-client-body-temp-path=/var/temp/nginx/client \\\r\n--http-proxy-temp-path=/var/temp/nginx/proxy \\\r\n--http-fastcgi-temp-path=/var/temp/nginx/fastcgi \\\r\n--http-uwsgi-temp-path=/var/temp/nginx/uwsgi \\\r\n--http-scgi-temp-path=/var/temp/nginx/scgi\r\n```\r\n注意：上边将临时文件目录指定为/var/temp/nginx，需要在/var下创建temp及nginx目录\r\n2. 编译安装\r\n```shell\r\nmake\r\nmake install\r\n```\r\n\r\n3. 启动nginx\r\n```shell\r\ncd /usr/local/nginx/sbin/\r\n./nginx\r\n```\r\n查询nginx进程：`ps aux|grep nginx`。注意：执行./nginx启动nginx，这里可以-c指定加载的nginx配置文件，如下：\r\n```nginx\r\n./nginx -c /usr/local/nginx/conf/nginx.conf\r\n```\r\n如果不指定-c，nginx在启动时默认加载conf/nginx.conf文件，此文件的地址也可以在编译安装nginx时指定./configure的参数（--conf-path=指向配置文件（nginx.conf））\r\n4. 停止nginx。\r\n```shell\r\n# 方式1，快速停止：\r\ncd /usr/local/nginx/sbin\r\n./nginx -s stop\r\n```\r\n此方式相当于先查出nginx进程id再使用kill命令强制杀掉进程。\r\n```shell\r\n# 方式2，完整停止(建议使用)：\r\ncd /usr/local/nginx/sbin\r\n./nginx -s quit\r\n```\r\n此方式停止步骤是待nginx进程处理任务完毕进行停止。\r\n5. 重启nginx。\r\n方式1，先停止再启动（建议使用）：对nginx进行重启相当于先停止nginx再启动nginx，即先执行停止命令再执行启动命令。如下：\r\n```shell\r\n./nginx -s quit\r\n./nginx\r\n```\r\n方式2，重新加载配置文件：当nginx的配置文件nginx.conf修改后，要想让配置生效需要重启nginx，使用`-s reload`不用先停止nginx再启动nginx即可将配置信息在nginx中生效，如下：\r\n```shell\r\n./nginx -s reload\r\n```\r\n6. 测试。nginx安装成功，启动nginx，即可访问虚拟机上的nginx：到这说明nginx上安装成功。\r\n\r\n7. 开机自启动nginx\r\n\r\n**编写shell脚本**,这里使用的是编写shell脚本的方式来处理`vi /etc/init.d/nginx`(输入下面的代码)\r\n```bash\r\n#!/bin/bash\r\n# nginx Startup script for the Nginx HTTP Server\r\n# it is v.0.0.2 version.\r\n# chkconfig: - 85 15\r\n# description: Nginx is a high-performance web and proxy server.\r\n# It has a lot of features, but it's not for everyone.\r\n# processname: nginx\r\n# pidfile: /var/run/nginx.pid\r\n# config: /usr/local/nginx/conf/nginx.conf\r\nnginxd=/usr/local/nginx/sbin/nginx\r\nnginx_config=/usr/local/nginx/conf/nginx.conf\r\nnginx_pid=/var/run/nginx.pid\r\nRETVAL=0\r\nprog=\"nginx\"\r\n# Source function library.\r\n. /etc/rc.d/init.d/functions\r\n# Source networking configuration.\r\n. /etc/sysconfig/network\r\n# Check that networking is up.\r\n[ ${NETWORKING} = \"no\" ] && exit 0\r\n[ -x $nginxd ] || exit 0\r\n# Start nginx daemons functions.\r\nstart() {\r\nif [ -e $nginx_pid ];then\r\n echo \"nginx already running....\"\r\n exit 1\r\nfi\r\n echo -n $\"Starting $prog: \"\r\n daemon $nginxd -c ${nginx_config}\r\n RETVAL=$?\r\n echo\r\n [ $RETVAL = 0 ] && touch /var/lock/subsys/nginx\r\n return $RETVAL\r\n}\r\n# Stop nginx daemons functions.\r\nstop() {\r\n echo -n $\"Stopping $prog: \"\r\n killproc $nginxd\r\n RETVAL=$?\r\n echo\r\n [ $RETVAL = 0 ] && rm -f /var/lock/subsys/nginx /var/run/nginx.pid\r\n}\r\n# reload nginx service functions.\r\nreload() {\r\n echo -n $\"Reloading $prog: \"\r\n #kill -HUP `cat ${nginx_pid}`\r\n killproc $nginxd -HUP\r\n RETVAL=$?\r\n echo\r\n}\r\n# See how we were called.\r\ncase \"$1\" in\r\nstart)\r\n start\r\n ;;\r\nstop)\r\n stop\r\n ;;\r\nreload)\r\n reload\r\n ;;\r\nrestart)\r\n stop\r\n start\r\n ;;\r\nstatus)\r\n status $prog\r\n RETVAL=$?\r\n ;;\r\n*)\r\n echo $\"Usage: $prog {start|stop|restart|reload|status|help}\"\r\n exit 1\r\nesac\r\nexit $RETVAL\r\n```\r\n:wq保存并退出\r\n**设置文件的访问权限**\r\n\r\n```shell\r\nchmod a+x /etc/init.d/nginx #(a+x ==> all user can execute 所有用户可执行)\r\n```\r\n这样在控制台就很容易的操作nginx了：查看Nginx当前状态、启动Nginx、停止Nginx、重启Nginx…如果修改了nginx的配置文件nginx.conf，也可以使用上面的命令重新加载新的配置文件并运行，可以将此命令加入到rc.local文件中，这样开机的时候nginx就默认启动了\r\n**加入到rc.local文件中**\r\n\r\n```shell\r\nvi /etc/rc.local\r\n```\r\n加入一行`/etc/init.d/nginx start`保存并退出，下次重启会生效。\r\n\r\n\r\n### 在线安装\r\n\r\n#### 下载\r\n\r\n[官网地址](https://nginx.org)\r\n\r\n#### 安装依赖\r\n\r\n```shell\r\nyum -y install gcc zlib zlib-devel pcre-devel openssl openssl-devel\r\n```\r\n\r\n#### 安装\r\n\r\n- 创建一个文件夹,上传本地提供的nginx包\r\n```shell\r\nif [ ! -d \"/root/software\" ]; then\r\nmkdir -p /root/software\r\nfi && cd /root/software && rz\r\n```\r\n\r\n- 解压\r\n```shell\r\ntar -zxvf nginx-1.18.0.tar.gz && cd nginx-1.18.0\r\n```\r\n\r\n- 配置、编译、安装\r\n```shell\r\n./configure && make && make install\r\n```\r\n\r\n- 检查是否安装成功\r\n```shell\r\nwhereis nginx\r\ncd /usr/local/nginx/sbin && ./nginx\r\nps -ef | grep nginx\r\n```\r\n\r\n- 启动代码格式：nginx安装目录地址 -c nginx配置文件地址\r\n```shell\r\n/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf\r\n```\r\n\r\n- 热加载\r\n```shell\r\n/usr/local/nginx/sbin/nginx -s reload\r\n```\r\n\r\n\r\n## Nginx知识点\r\n\r\n### nginx判断\r\n\r\n1、正则表达式匹配：\r\n\r\n==：等值比较;\r\n\\~：与指定正则表达式模式匹配时返回“真”，判断匹配与否时区分字符大小写；\r\n\\~\\*：与指定正则表达式模式匹配时返回“真”，判断匹配与否时不区分字符大小写；\r\n!\\~：与指定正则表达式模式不匹配时返回“真”，判断匹配与否时区分字符大小写；\r\n!\\~\\*：与指定正则表达式模式不匹配时返回“真”，判断匹配与否时不区分字符大小写；\r\n\r\n2、文件及目录匹配判断：\r\n\r\n-f, !-f：判断指定的路径是否为存在且为文件；\r\n-d, !-d：判断指定的路径是否为存在且为目录；\r\n-e, !-e：判断指定的路径是否存在，文件或目录均可；\r\n-x, !-x：判断指定路径的文件是否存在且可执行；\r\n\r\n### ngx_http_core_module模块的变量\r\n\r\n- **$arg_PARAMETER**：HTTP请求中某个参数的值，如/index.php?site=www.domain.com 可以用$arg_site取得www.domain.com 这个值。\r\n- **$args HTTP**：请求中的完整参数。例如，在请求/index.php?width=400&height=200中，$args表示字符串width=400&height=200.\r\n- **$binary_remote_addr**：二进制格式的客户端地址。例如：\\x0A\\xE0B\\x0E\r\n- **$body_bytes_sent**：表示在向客户端发送的http响应中，包体部分的字节数\r\n- **$content_length**：表示客户端请求头部中的Content-Length字段\r\n- **$content_type**：表示客户端请求头部中的Content-Type字段\r\n- **$cookie_COOKIE**：表示在客户端请求头部中的cookie字段\r\n- **$document_root**：表示当前请求所使用的root配置项的值\r\n- **$uri**：表示当前请求的URI，不带任何参数\r\n- **$document_uri与$uri含义相同**\r\n- **$request_uri**：表示客户端发来的原始请求URI，带完整的参数。$uri和$document_uri未必是用户的原始请求，在内部重定向后可能是重定向后的URI，而$request_uri永远不会改变，始终是客户端的原始URI\r\n- **$host**：表示客户端请求头部中的Host字段。如果Host字段不存在，则以实际处理的server（虚拟主机）名称代替。如果Host字段中带有端口，如IP:PORT，那么$host是去掉端口的，它的值为IP。$host是全小写的。这些特性与http_HEADER中的http_host不同，http_host只取出Host头部对应的值。\r\n- **$hostname**：表示Nginx所在机器的名称，与gethostbyname调用返回的值相同\r\n- **$http_HEADER**：表示当前HTTP请求中相应头部的值。HEADER名称全小写。例如，示请求中Host头部对应的值用$http_host表\r\n- **$sent_http_HEADER**：表示返回客户端的HTTP响应中相应头部的值。HEADER名称全小写。例如，用$sent_http_content_type表示响应中Content-Type头部对应的值\r\n- **$is_args**：表示请求中的URI是否带参数，如果带参数，$is_args值为?，如果不带参数，则是空字符串\r\n- **$limit_rate**：表示当前连接的限速是多少，0表示无限速\r\n- **$nginx_version**：表示当前Nginx的版本号\r\n- **$query_string**：请求URI中的参数，与$args相同，然而$query_string是只读的不会改变\r\n- **$remote_addr**：表示客户端的地址\r\n- **$remote_port**：表示客户端连接使用的端口\r\n- **$remote_user**：表示使用Auth Basic Module时定义的用户名\r\n- **$request_filename**：表示用户请求中的URI经过root或alias转换后的文件路径\r\n- **$request_body**：表示HTTP请求中的包体，该参数只在proxy_pass或fastcgi_pass中有意义\r\n- **$request_body_file**：表示HTTP请求中的包体存储的临时文件名\r\n- **$request_completion**：当请求已经全部完成时，其值为“ok”。若没有完成，就要返回客户端，则其值为空字符串；或者在断点续传等情况下使用HTTP range访问的并不是文件的最后一块，那么其值也是空字符串。\r\n- **$request_method**：表示HTTP请求的方法名，如GET、PUT、POST等\r\n- **$scheme**：表示HTTP scheme，如在请求https://nginx.com/中表示https\r\n- **$server_addr**：表示服务器地址\r\n- **$server_name**：表示服务器名称\r\n- **$server_port**：表示服务器端口\r\n- **$server_protocol**：表示服务器向客户端发送响应的协议，如HTTP/1.1或HTTP/1.0\r\n\r\n### 日志配置\r\n\r\n- **$remote_addr,$http_x_forwarded_for-** ：记录客户端IP地址\r\n- **$remote_user**：记录客户端用户名称\r\n- **$request**：记录请求的URL和HTTP协议\r\n- **$status**：记录请求状态\r\n- **$body_bytes_sent**：发送给客户端的字节数，不包括响应头的大小；该变量与Apache模块mod_log_config里的“%B”参数兼容。\r\n- **$bytes_sent**：发送给客户端的总字节数。\r\n- **$connection**：连接的序列号。\r\n- **$connection_requests**：当前通过一个连接获得的请求数量。\r\n- **$msec**：日志写入时间。单位为秒，精度是毫秒。\r\n- **$pipe**：如果请求是通过HTTP流水线(pipelined)发送，pipe值为“p”，否则为“.”。\r\n- **$http_referer**：记录从哪个页面链接访问过来的\r\n- **$http_user_agent**：记录客户端浏览器相关信息\r\n- **$request_length**：请求的长度（包括请求行，请求头和请求正文）。\r\n- **$request_time**：请求处理时间，单位为秒，精度毫秒；从读入客户端的第一个字节开始，直到把最后一个字符发送给客户端后进行日志写入为止。\r\n- **$time_iso8601**：ISO8601标准格式下的本地时间。\r\n- **$time_local**：通用日志格式下的本地时间。\r\n\r\n### if语法\r\n\r\n- 语法：if (condition) { … }\r\n- 默认值：none\r\n- 使用字段：server, location\r\n- 注意：尽量考虑使用trp_files代替。\r\n- 判断的条件可以有以下值：\r\n\r\n1. 一个变量的名称：空字符传”“或者一些“0”开始的字符串为false。\r\n2. 字符串比较：使用=或!=运算符\r\n3. 正则表达式匹配：使用\\~(区分大小写)和\\~\\*(不区分大小写)，取反运算!\\~和!\\~\\*。\r\n4. 文件是否存在：使用-f和!-f操作符\r\n5. 目录是否存在：使用-d和!-d操作符\r\n7. 文件、目录、符号链接是否存在：使用-e和!-e操作符\r\n8. 文件是否可执行：使用-x和!-x操作符\r\n\r\n### return\r\n\r\n- 语法：return code\r\n- 默认值：none\r\n- 使用字段：server,location,if\r\n- nginx隐藏版本号\r\n- nginx.conf中修改http zone中的变量值： server_tokens off;\r\n- php-fpm fastcgi.conf中的变量值： fastcgi_param SERVER_SOFTWARE nginx;\r\n\r\n### nginx正向代理\r\n\r\n```nginx\r\nserver {\r\n    listen 8090;\r\n    location / {\r\n        resolver 218.85.157.99 218.85.152.99;\r\n        resolver_timeout 30s;\r\n        proxy_pass http://$host$request_uri;\r\n    }\r\n    access_log /data/httplogs/proxy-$host-aceess.log;\r\n}\r\n```\r\n\r\nresolver指令\r\n\r\n- 语法: resolver address ... [valid=time];\r\n- 默认值: —\r\n- 配置段: http, server, location\r\n- 配置DNS服务器IP地址。可以指定多个，以轮询方式请求。\r\n- nginx会缓存解析的结果。默认情况下，缓存时间是名字解析响应中的TTL字段的值，可以通过valid参数更改。\r\n\r\n## location \"/\" 的作用\r\n\r\n**前置测试访问域名**：www.test.com/api/upload\r\n\r\n### location和proxy\\_pass都带/，则真实地址不带location匹配目录\r\n\r\n```nginx\r\nlocation /api/ {\r\n    proxy_pass http://127.0.0.1:8080/;\r\n}\r\n```\r\n\r\n**访问地址**：www.test.com/api/upload-->http://127.0.0.1:8080/upload\r\n\r\n### location不带/，proxy\\_pass带/，则真实地址会带/\r\n\r\n```nginx\r\nlocation /api {\r\n    proxy_pass http://127.0.0.1:8080/;\r\n}\r\n```\r\n\r\n**访问地址**：www.test.com/api/upload-->http://127.0.0.1:8080/upload\r\n\r\n### location带/，proxy\\_pass不带/，则真实地址会带location匹配目录/api/\r\n\r\n```nginx\r\nlocation /api/ {\r\n    proxy_pass http://127.0.0.1:8080;\r\n}\r\n```\r\n\r\n**访问地址**：www.test.com/api/upload-->http://127.0.0.1:8080/api/upload\r\n\r\n### location和proxy\\_pass都不带/，则真实地址会带location匹配目录/api/\r\n\r\n```nginx\r\nlocation /api {\r\n    proxy_pass http://127.0.0.1:8080;\r\n}\r\n```\r\n\r\n**访问地址**：www.test.com/api/upload-->http://127.0.0.1:8080/api/upload\r\n\r\n### location和proxy\\_pass都带/，但proxy\\_pass带地址(同1)\r\n\r\n```nginx\r\nlocation /api/ {\r\n    proxy_pass http://127.0.0.1:8080/server/;\r\n}\r\n```\r\n\r\n**访问地址**：www.test.com/api/upload-->http://127.0.0.1:8080/server/upload\r\n\r\n### location不带/，proxy\\_pass带/，但proxy\\_pass带地址，则真实地址会多个/(同2)\r\n\r\n```nginx\r\nlocation /api {\r\n    proxy_pass http://127.0.0.1:8080/server/;\r\n}\r\n```\r\n\r\n**访问地址**：www.test.com/api/upload-->http://127.0.0.1:8080/server//upload\r\n\r\n### location带/，proxy\\_pass不带/，但proxy\\_pass带地址，则真实地址会直接连起来(同3)\r\n\r\n```nginx\r\nlocation /api/ {\r\n    proxy_pass http://127.0.0.1:8080/server;\r\n}\r\n```\r\n\r\n**访问地址**：www.test.com/api/upload-->http://127.0.0.1:8080/serverupload\r\n\r\n### location和proxy\\_pass都不带/，但proxy\\_pass带地址，则真实地址匹配地址会替换location匹配目录(同4)\r\n\r\n```nginx\r\nlocation /api {\r\n    proxy_pass http://127.0.0.1:8080/server;\r\n}\r\n```\r\n\r\n**访问地址**：www.test.com/api/upload-->http://127.0.0.1:8080/server/upload\r\n\r\n### 总结\r\n\r\n1. proxy_pass代理地址端口后有目录(包括 / )，转发后地址：代理地址+访问URL目录部分去除location匹配目录\r\n2. proxy_pass代理地址端口后无任何，转发后地址：代理地址+访问URL目录部\r\n\r\n## Nginx设置黑/白名单IP限制\r\n\r\n### 第一种方法:allow、deny\r\n\r\ndeny和allow指令属于ngx_http_access_module，nginx默认加载此模块，所以可直接使用。这种方式，最简单，最直接。设置类似防火墙iptable，使用方法：直接配置文件中添加：\r\n```nginx\r\n# 白名单设置，allow后面为可访问IP\r\nlocation / {\r\n     allow 123.13.123.12;\r\n     allow 23.53.32.1/100;\r\n     deny  all;\r\n}\r\n\r\n# 黑名单设置，deny后面接限制的IP，为什么不加allow all?因为这个默认是开启的\r\nlocation / {\r\n     deny 123.13.123.12;\r\n}\r\n\r\n# 白名单，特定目录访问限制\r\nlocation /tree/list {\r\n     allow 123.13.123.12;\r\n     deny all;\r\n}\r\n```\r\n\r\n或者通过读取文件IP配置白名单\r\n\r\n```nginx\r\nlocation /{\r\n    include /home/whitelist.conf;\r\n    # 默认位置路径为/etc/nginx/下，\r\n    # 如直接写include whitelist.conf，则只需要在/etc/nginx目录下创建whitelist.conf\r\n    deny all;\r\n}\r\n```\r\n\r\n在/home/目录下创建whitelist.conf，并写入需要加入白名单的IP，添加完成后查看如下：\r\n\r\n```shell\r\ncat /home/whitelist.conf\r\n\r\n# 白名单IP\r\nallow 10.1.1.10;\r\nallow 10.1.1.11;\r\n```\r\n\r\n白名单设置完成，黑名单设置方法一样。\r\n\r\n### 第二种方法:ngx_http_geo_module\r\n\r\n默认情况下，一般nginx是有加该模块的，[ngx_http_geo_module官方文档](https://nginx.org/en/docs/http/ngx_http_geo_module.html)。参数需设置在位置在http模块中。此模块可设置IP限制，也可设置国家地区限制。位置在server模块外即可。语法示例：配置文件直接添加\r\n\r\n```nginx\r\ngeo $ip_list {\r\n    default 0;\r\n    # 设置默认值为0\r\n    192.168.1.0/24 1;\r\n    10.1.0.0/16    1;\r\n}\r\nserver {\r\n   listen       8081;\r\n   server_name  192.168.152.100;\r\n\r\n   location / {\r\n       root   /var/www/test;\r\n       index  index.html index.htm index.php;\r\n       if ( $ip_list = 0 ) {\r\n           # 判断默认值，如果值为0，可访问，这时上面添加的IP为黑名单。\r\n           # 白名单，将设置$ip_list = 1，这时上面添加的IP为白名单。\r\n           proxy_pass http://192.168.152.100:8081;\r\n        }\r\n    }\r\n\r\n}\r\n```\r\n\r\n同样可通过读取文件IP配置\r\n\r\n```nginx\r\ngeo $ip_list {\r\n    default 0;\r\n    #设置默认值为0\r\n    include ip_white.conf;\r\n}\r\nserver {\r\n    listen       8081;\r\n    server_name  192.168.152.100;\r\n\r\n    location / {\r\n        root   /var/www/test;\r\n        index  index.html index.htm index.php;\r\n        if ( $ip_list = 0 ) {\r\n            return 403;\r\n            # 限制的IP返回值为403，也可以设置为503，504其他值。\r\n            # 建议设置503，504这样返回的页面不会暴露nginx相关信息，限制的IP看到的信息只显示服务器错误，无法判断真正原因。\r\n        }\r\n    }\r\n}\r\n```\r\n在/etc/nginx目录下创建ip_list.conf，添加IP完成后，查看如下：\r\n\r\n```shell\r\ncat /etc/nginx/ip_list.conf\r\n\r\n192.168.152.1 1;\r\n192.168.150.0/24 1;\r\n```\r\n\r\n设置完成，ip_list.conf的IP为白名单，不在名单中的，直接返回403页面。黑名单设置方法相同。\r\n\r\n### ngx_http_geo_module负载均衡（扩展）\r\n\r\nngx_http_geo_module，模块还可以做负载均衡使用，如web集群在不同地区都有服务器，某个地区IP段，负载均衡至访问某个地区的服务器。方式类似，IP后面加上自定义值，不仅仅数字，如US,CN等字母。示例：如果三台服务器：122.11.11.11，133.11.12.22，144.11.11.33\r\n\r\n```nginx\r\ngeo $country {\r\n    default default;\r\n    111.11.11.0/24   uk;\r\n    # IP段定义值uk\r\n    111.11.12.0/24   us;\r\n    # IP段定义值us\r\n    }\r\nupstream  uk.server {\r\n    erver 122.11.11.11:9090;\r\n    # 定义值uk的IP直接访问此服务器\r\n}\r\n\r\nupstream  us.server {\r\n    server 133.11.12.22:9090;\r\n    # 定义值us的IP直接访问此服务器\r\n}\r\n\r\nupstream  default.server {\r\n    server 144.11.11.33:9090;\r\n    #默认的定义值default的IP直接访问此服务器\r\n}\r\n\r\nserver {\r\n    listen    9090;\r\n    server_name 144.11.11.33;\r\n\r\n    location / {\r\n      root  /var/www/html/;\r\n      index index.html index.htm;\r\n     }\r\n }\r\n```\r\n\r\n## 国家城市IP访问限制\r\n\r\n有些第三方也提供设置，如cloudflare，设置更简单，防火墙规则里设置。这里讲讲nginx的设置方法。\r\n\r\n### 安装ngx_http_geoip_module模块\r\n\r\n[ngx_http_geoip_module官方文档](https://nginx.org/en/docs/http/ngx_http_geoip_module.html)，参数需设置在位置在http模块中。nginx默认情况下不构建此模块，应使用`--with-http_geoip_module`配置参数启用它。对于ubuntu系统来说，直接安装nginx-extras组件，包括几乎所有的模块。\r\n\r\n```shell\r\nsudo apt install nginx-extras\r\n```\r\n\r\n对于centos系统，安装模块。\r\n\r\n```shell\r\nyum install nginx-module-geoip\r\n```\r\n\r\n### 下载 IP 数据库\r\n\r\n此模块依赖于IP数据库，所有数据在此数据库中读取，所有还需要下载ip库（dat格式）。MaxMind提供了免费的IP地域数据库，坏消息是MaxMind官方已经停止支持dat格式的ip库。在其他地方可以找到dat格式的文件，或者老版本的，当然数据不可能最新，多少有误差。\r\n\r\n> 第三方下载地址：https://www.miyuru.lk/geoiplegacy\r\n\r\n下载同时包括Ipv4和Ipv6的country、city版本。\r\n\r\n```shell\r\n# 下载国家IP库，解压并移动到nginx配置文件目录，\r\nsudo wget https://dl.miyuru.lk/geoip/maxmind/country/maxmind.dat.gz\r\ngunzip maxmind.dat.gz\r\nsudo mv maxmind.dat /etc/nginx/GeoCountry.dat\r\n\r\nsudo wget https://dl.miyuru.lk/geoip/maxmind/city/maxmind.dat.gz\r\ngunzip maxmind.dat.gz\r\nsudo mv maxmind.dat /etc/nginx/GeoCity.dat\r\n```\r\n\r\n### 配置nginx\r\n\r\n示例：\r\n\r\n```nginx\r\ngeoip_country /etc/nginx/GeoCountry.dat;\r\ngeoip_city /etc/nginx/GeoCity.dat;\r\n\r\nserver {\r\n    listen  80;\r\n    server_name 144.11.11.33;\r\n\r\n    location / {\r\n      root  /var/www/html/;\r\n      index index.html index.htm;\r\n      if ($geoip_country_code = CN) {\r\n         return 403;\r\n       # 中国地区，拒绝访问。返回403页面\r\n      }\r\n   }\r\n }\r\n```\r\n这里，地区国家基础设置就完成了。\r\n\r\nGeoip其他参数：\r\n\r\n- 国家相关参数：\r\n\r\n```nginx\r\n$geoip_country_code # 两位字符的英文国家码。如：CN,US\r\n$geoip_country_code3 # 三位字符的英文国家码。如：CHN, USA\r\n$geoip_country_name # 国家英文全称。如：China,United States\r\n```\r\n\r\n- 城市相关参数：\r\n\r\n```nginx\r\n$geoip_city_country_code # 也是两位字符的英文国家码。\r\n$geoip_city_country_code3 # 上同\r\n$geoip_city_country_name # 上同.\r\n$geoip_region # 这个经测试是两位数的数字，如杭州是02,上海是23。但是没有搜到相关资料，希望知道的朋友留言告之。\r\n$geoip_city # 城市的英文名称。如：Hangzhou\r\n$geoip_postal_code # 城市的邮政编码。经测试，国内这字段为空\r\n$geoip_city_continent_code # 不知什么用途，国内好像都是AS\r\n$geoip_latitude # 纬度\r\n$geoip_longitude # 经度\r\n```\r\n\r\n## 封禁恶意ip\r\n\r\n单独网站屏蔽IP的方法，把`include xxx;`放到网址对应的在server{}语句块,虚拟主机所有网站屏蔽IP的方法，把`include xxx;`放到http{}语句块。\r\n\r\n### 手动封禁\r\n\r\n```nginx\r\nhttp{\r\n    # ....\r\n    include blacklist.conf;\r\n}\r\n\r\nlocation / {\r\n    proxy_pass http://lbs;\r\n    proxy_redirect default;\r\n}\r\n\r\n# blacklist.conf目录文件下的内容\r\ndeny 192.168.159.2;\r\ndeny 192.168.159.32;\r\n\r\n# 重新加载配置，不中断服务\r\n./nginx -s reload\r\n```\r\n\r\n### 自动化封禁\r\n\r\n思路:\r\n\r\n- 编写shell脚本\r\n- AWK统计access.log，记录每秒访问超过60次的ip，然后配合nginx或者iptables进行封禁\r\n- crontab定时跑脚本\r\n\r\n```nginx\r\nlocation / {\r\n    add_header 'Access-Control-Allow-Origin' $http_origin;\r\n    add_header 'Access-Control-Allow-Credentials' 'true';\r\n    add_header 'Access-Control-Allow-Headers' 'DNT,web-token,app-token,Authorization,Accept,Origin,Keep-Alive,User-Agent,X-Mx-ReqToken,X-Data-Type,X-Auth-Token,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range';\r\n    add_header Access-Control-Allow-Methods 'GET,POST,OPTIONS';\r\n    # 如果预检请求则返回成功,不需要转发到后端\r\n    if ($request_method = 'OPTIONS') {\r\n        add_header 'Access-Control-Max-Age' 1728000;\r\n        add_header 'Content-Type' 'text/plain; charset=utf-8';\r\n        add_header 'Content-Length' 0;\r\n        return 200;\r\n    }\r\n}\r\n```\r\n\r\n## 语法规则\r\n\r\nlocation [= | \\~ | \\~\\* | ^\\~ ] /uri/ { … }\r\n\r\n- =：表示精确匹配,这个优先级也是最高的\r\n- ^\\~：表示uri以某个常规字符串开头，理解为匹配url路径即可。nginx不对url做编码，因此请求为/static/20%/aa，可以被规则^~ /static/ /aa匹配到（注意是空格）。\r\n- \\~：表示区分大小写的正则匹配\r\n- \\~\\*：表示不区分大小写的正则匹配(和上面的唯一区别就是大小写)\r\n- !\\~和!\\~\\*：分别为区分大小写不匹配及不区分大小写不匹配的正则\r\n- /：通用匹配，任何请求都会匹配到，默认匹配.\r\n\r\n**语法的一些规则和优先级**\r\n多个location配置的情况下匹配顺序为：首先匹配=，其次匹配^\\~,其次是按文件中顺序的正则匹配，最后是交给/通用匹配。当有匹配成功时候，停止匹配，按当前匹配规则处理请求。\r\n\r\n### 正则匹配\r\n\r\n- ^ 以什么开始\r\n- \\$ 以什么结束\r\n- \\~ 区分大小写匹配\r\n- \\~\\* 不区分大小写匹配\r\n\r\n```nginx\r\n# ^/api/user$\r\n# 匹配任何以/uri/开头的任务查询并且停止搜索\r\nlocation ^~ /uri/\r\n```\r\n\r\n### 精准匹配\r\n\r\n```nginx\r\n# =:表示精准匹配,只要完全匹配才能生效\r\nlocation= /uri\r\n```\r\n\r\n### 前缀匹配\r\n\r\n不带任务修饰符,表示前缀匹配\r\n\r\n### 通用匹配\r\n\r\n任务未匹配到其他location的请求都会匹配到\r\n\r\n```nginx\r\nlocation /\r\n```\r\n\r\n### 优先级\r\n\r\n精准匹配>前缀匹配(若有多个匹配荐匹配成功,那么选择匹配长的并记录)>正则匹配\r\n\r\n### 案例\r\n\r\n```nginx\r\nserver {\r\n    server_name xdclass.net;\r\n    location ~^/api/pub$ {\r\n    ...\r\n    }\r\n}\r\n# ^/api/pub\\$这个正则表达式表示字符串必须以/开始，以b\\$结束，中间必须是/api/pub\r\n# http://xdclass.net/api/v1 匹配（完全匹配）\r\n# http://xdclass.net/API/PUB 不匹配，大小写敏感\r\n# http://xdclass.net/api/pub?key1=value1 匹配\r\n# http://xdclass.net/api/pub/ 不匹配\r\n# http://xdclass.net/api/public 不匹配，不能匹配正则表达式\r\n```\r\n\r\n## 地址重定向\r\n\r\n### rewrite地址重定向，实现URL重定向的重要指令，他根据regex(正则表达式)来匹配内容跳转到\r\n\r\n语法: \r\n```bash\r\nrewrite regex replacement[flag]\r\n```\r\n这是⼀个正则表达式，匹配完整的域名和后⾯的路径地址,replacement部分https://xdclass.net/$1, $1是取自regex部分()里的内容.rewrite ^/(.\\*) https://xdclass.net/$1 permanent\r\n\r\n常用正则表达式\r\n\r\n- ^: 匹配输入字符串的起始位置\r\n- $: 匹配输入字符串的结束位置\r\n- \\*: 匹配前面的字符0次或者多次\r\n- ?: 匹配前面字符串的0次或者1次\r\n- .: 匹配除\"\\n\"之外的所有单个字符\r\n- (pattern) 匹配括号内的pattern\r\n\r\nrewrite最后一项flag参数\r\n\r\n- last: 本条规则匹配完成后继续向下匹配新的location URI规则\r\n- break: 本条规则匹配完成后终止,不再匹配任何规则\r\n- redirect: 返回302临时重定向\r\n- permanent: 返回301永久重定向\r\n\r\n\r\n### 应用场景\r\n\r\n– 非法访问跳转,防盗链\r\n\r\n– 网站更换新域名\r\n\r\n– http跳转https\r\n\r\n– 不同地址访问同⼀个虚拟主机的资源\r\n\r\n## 配置websocket反向代理\r\n\r\n```nginx\r\nserver {\r\n    listen 80;\r\n    server_name xdclass.net;\r\n    location / {\r\n        proxy_pass http://lbs;\r\n        proxy_read_timeout 300s; //websocket空闲保持时⻓\r\n        proxy_set_header Host $host;\r\n        proxy_set_header X-Real-IP $remote_addr;\r\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\r\n        proxy_http_version 1.1;\r\n\r\n        proxy_set_header Upgrade $http_upgrade;\r\n        proxy_set_header Connection\r\n        $connection_upgrade;\r\n    }\r\n}\r\n```\r\n\r\n## 性能优化-服务端缓存前置\r\n\r\n- /root/cache\r\n本地路径，用来设置Nginx缓存资源的存放地址\r\n\r\n- levels=1:2\r\n默认所有缓存文件都放在上面指定的根路径中，可能影响缓存的性能，推荐指定为2级目录来存储缓存文件；1和2表示用1位和2位16进制来命名目录名称。第⼀级目录用1位16进制命名，如a；第⼆级目录用2位16进制命名，如3a。所以此例中⼀级目录有16个，⼆级目录有16 * 16=256个,总目录数为16 * 256=4096个。\r\n\r\n- levels=1:1:1时，表示是三级目录，且每级目录数均为16个\r\n- key_zone\r\n在共享内存中定义⼀块存储区域来存放缓存的key和metadata\r\n\r\n  - max_size\r\n最大缓存空间,如果不指定会使用掉所有磁盘空间。当达到disk上限后，会删除最少使用的cache\r\n  - inactive\r\n某个缓存在inactive指定的时间内如果不访问，将会从缓存中删除\r\n  - proxy_cache_valid\r\n配置nginx cache中的缓存⽂件的缓存时间,proxy_cache_valid 200 304 2m对于状态为200和304的缓存⽂件的缓存时间是2分钟\r\n  - use_temp_path\r\n建议为off，则nginx会将缓存⽂件直接写⼊指定的cache文件中\r\n  - proxy_cache\r\n启用proxy cache，并指定key_zone，如果proxy_cache off表示关闭掉缓存\r\n  - add_header Nging-Cache \"$upstream_cache_status\"\r\n用于前端判断是否是缓存，miss、hit、expired(缓存过期)、updating(更新，使用旧的应答)\r\n```nginx\r\nproxy_cache_path /root/cache levels=1:2 keys_zone=xd_cache:10m max_size=1g inactive=60m use_temp_path=off;\r\nserver {\r\n    location /{\r\n    ...\r\n    proxy_cache xd_cache;\r\n    proxy_cache_valid 200 304 10m;\r\n    proxy_cache_valid 404 1m;\r\n    proxy_cache_key $host$uri$is_args$args;\r\n    add_header Nginx-Cache \"$upstream_cache_status\";\r\n    }\r\n}\r\n```\r\n\r\n## 性能优化-动静分离\r\n\r\n性能优化-静态资源压缩\r\n\r\n对文本、js和css文件等进行压缩，⼀般是压缩后的大小是原始大小的25%\r\n```nginx\r\n# 开启gzip,减少我们发送的数据量\r\ngzip on;\r\ngzip_min_length 1k;\r\n\r\n# 4个单位为16k的内存作为压缩结果流缓存\r\ngzip_buffers 4 16k;\r\n\r\n# gzip压缩⽐，可在1~9中设置，1压缩⽐最⼩，速度最快，9压缩⽐最⼤，速度最慢，消耗CPU\r\ngzip_comp_level 4;\r\n\r\n# 压缩的类型\r\ngzip_types application/javascript text/plain text/css application/json application/xml text/javascript;\r\n\r\n# 给代理服务器⽤的，有的浏览器⽀持压缩，有的不⽀持，所以避免浪费不⽀持的也压缩，所以根据客户端的HTTP头来判断，是否需要压缩\r\ngzip_vary on;\r\n\r\n# 禁⽤IE6以下的gzip压缩，IE某些版本对gzip的压缩⽀持很不好\r\ngzip_disable \"MSIE [1-6].\";\r\n```\r\n\r\n**压缩是时间换空间，还是空间换时间**？\r\n\r\n- web层主要涉及浏览器和服务器的网络交互，而网络交互显然是耗费时间的\r\n\r\n- 要尽量减少交互次数\r\n\r\n- 降低每次请求或响应数据量\r\n\r\n- 开启压缩\r\n\r\n- 在服务端是时间换空间的策略，服务端需要牺牲时间进行压缩以减小响应数据大小\r\n\r\n- 压缩后的内容可以获得更快的网络传输速度，时间是得到了优化,所以是双向的\r\n\r\n## https配置\r\n\r\n### 1. 删除原先的nginx，新增ssl模块\r\n\r\n```shell\r\n./configure --prefix=/usr/local/nginx --with-http_stub_status_module --withhttp_ssl_module\r\nmake\r\nmake install\r\n#查看是否成功\r\n/usr/local/nginx/sbin/nginx -V\r\n```\r\n\r\n### 2. Nginx配置https证书\r\n\r\n```nginx\r\nserver {\r\n    listen 443 ssl;\r\n    server_name 16web.net;\r\n    ssl_certificate /usr/local/software/biz/key/4383407_16web.net.pem;\r\n    ssl_certificate_key /usr/local/software/biz/key/4383407_16web.net.key;\r\n    ssl_session_cache shared:SSL:1m;\r\n    ssl_session_timeout 5m;\r\n    ssl_ciphers HIGH:!aNULL:!MD5;\r\n    ssl_prefer_server_ciphers on;\r\n    location / {\r\n        root html;\r\n        index index.html index.htm;\r\n    }\r\n}\r\n```\r\n\r\n### 3. https访问实操\r\n\r\n- 杀掉原先进程\r\n- 防⽕墙关闭或者开放443端⼝\r\n```shell\r\nservice firewalld stop\r\n```\r\n\r\n- 网络安全组开放端口\r\n\r\n- 其他\r\n\r\n反向代理，获取用户的真实ip\r\n```nginx\r\nproxy_set_header Host $host;\r\nproxy_set_header X-Real-IP $remote_addr;\r\nproxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\r\n```\r\n\r\n## 高可用\r\n\r\nLVS+keepalived+nginx架构解决的问题：\r\n\r\n1. 如果其中keepalived挂了，那就会vip就会分发到另外⼀个keepalived节点，响应正常\r\n\r\n2. 如果某个realServer挂了，比如是Nginx挂了，那对应keepalived节点存活依旧可以转发过去，但是响应失败\r\n\r\n- 脚本监听\r\n```bash\r\n# 配置vrrp_script，主要⽤于健康检查及检查失败后执⾏的动作。\r\nvrrp_script chk_real_server {\r\n    # 健康检查脚本，当脚本返回值不为0时认为失败\r\n    script \"/usr/local/software/conf/chk_server.sh\"\r\n    # 检查频率，以下配置每2秒检查1次\r\n    interval 2\r\n    # 当检查失败后，将vrrp_instance的priority减⼩5\r\n    weight -5\r\n    # 连续监测失败3次，才认为真的健康检查失败。并调整优先级\r\n    fall 3\r\n    # 连续监测2次成功，就认为成功。但不调整优先级\r\n    rise 2\r\n    user root\r\n}\r\n```\r\n\r\n- 编辑脚本\r\n\r\n```shell\r\nmkdir -p /usr/local/software/conf\r\ncd /usr/local/software/conf\r\nvim /usr/local/software/conf/chk_server.sh\r\nchmod +x chk_server.sh\r\n```\r\n脚本详情\r\n```shell\r\n#!/bin/bash\r\n#检查nginx进程是否存在\r\ncounter=$(ps -C nginx --no-heading|wc -l)\r\nif [ \"${counter}\" -eq \"0\" ]; then\r\nservice keepalived stop\r\necho 'nginx server is died.......'\r\nfi\r\n```\r\n\r\n3. 步骤\r\n4. ds服务器:\r\n- 安装keepalived,参考keepalived安装步骤\r\n- 安装ipvsadm -y\r\n- 配置防火墙,两种方式,直接关闭，或者按照keepalived中描述的操作\r\n- 参照keepalived描述的修改配置文件\r\n\r\n5. rs服务器:\r\n- 安装openresty或者nginx\r\n- 配置防火墙,保证外网能访问\r\n- 配置realserver\r\n```shell\r\nvim /etc/init.d/realserver\r\n\r\n#虚拟的vip根据自己的实际情况定义\r\nSNS_VIP=192.168.1.25\r\n/etc/rc.d/init.d/functions\r\ncase \"$1\" in\r\nstart)\r\nifconfig lo:0 $SNS_VIP netmask 255.255.255.255 broadcast $SNS_VIP\r\n/sbin/route add -host $SNS_VIP dev lo:0\r\necho \"1\" >/proc/sys/net/ipv4/conf/lo/arp_ignore\r\necho \"2\" >/proc/sys/net/ipv4/conf/lo/arp_announce\r\necho \"1\" >/proc/sys/net/ipv4/conf/all/arp_ignore\r\necho \"2\" >/proc/sys/net/ipv4/conf/all/arp_announce\r\nsysctl -p >/dev/null 2>&1\r\necho \"RealServer Start OK\"\r\n;;\r\nstop)\r\nifconfig lo:0 down\r\nroute del $SNS_VIP >/dev/null 2>&1\r\necho \"0\" >/proc/sys/net/ipv4/conf/lo/arp_ignore\r\necho \"0\" >/proc/sys/net/ipv4/conf/lo/arp_announce\r\necho \"0\" >/proc/sys/net/ipv4/conf/all/arp_ignore\r\necho \"0\" >/proc/sys/net/ipv4/conf/all/arp_announce\r\necho \"RealServer Stoped\"\r\n;;\r\n*)\r\necho \"Usage: $0 {start|stop}\"\r\nexit 1\r\nesac\r\nexit 0\r\n#保存并设置脚本的执行权限\r\nchmod 755 /etc/init.d/realserver\r\n#因为realserver脚本中用到了/etc/rc.d/init.d/functions，所以一并设置权限\r\nchmod 755 /etc/rc.d/init.d/functions\r\n#重启后会失效,所以要设置为开机自启动\r\nchmod +x /etc/rc.d/rc.local\r\nvi /etc/rc.d/rc.local\r\n/etc/rc.d/init.d/realserver.sh start\r\n\r\n#执行脚本\r\nservice realserver start\r\n\r\n#查看执行结果,lo多出vip表明配置正确\r\nip a\r\n```\r\n\r\n- 常见问题\r\n  - vip能ping通，vip监听的端口不通: 第⼀个原因:nginx1和nginx2两台服务器的服务没有正常启动\r\n  - vip ping不通: 核对是否出现裂脑,常见原因为防火墙配置所致导致多播心跳失败,核对keepalived的配置是否正确：需要关闭selinux，不然sh脚本可能不生效\r\n```shell\r\n#查看\r\ngetenforce\r\n#关闭\r\nsetenforce 0\r\n```\r\n\r\n## 运维统计\r\n\r\n1. 查看访问最频繁的前100个IP\r\n```shell\r\nawk '{print $1}' access_temp.log | sort -n |uniq -c | sort -rn | head -n 100\r\n```\r\n2. 统计访问最多的url 前20名\r\n```shell\r\ncat access_temp.log |awk '{print $7}'| sort|uniq -c| sort -rn| head -20 | more\r\n```\r\n3. 自定义日志统计接口性能\r\n- 日志格式增加$request_time\r\n从接收用户请求的第⼀个字节到发送完响应数据的时间，即包括接收请求数据时间、程序响应时间、输出响应数据时间\r\n$upstream_response_time：指从Nginx向后端建立连接开始到接受完数据然后关闭连接为⽌的时间\r\n$request_time⼀般会比upstream_response_time大，因为用户网络较差，或者传递数据较⼤时，前者会耗时大很多\r\n```nginx\r\nlog_format main '$remote_addr -$remote_user [$time_local] \"$request\" ' '$status\r\n$body_bytes_sent \"$http_referer\" '\r\n'\"$http_user_agent\"\r\n\"$http_x_forwarded_for\" $request_time';\r\n\r\nserver {\r\n    listen 80;\r\n    server_name aabbcc.com;\r\n    location / {\r\n    root /usr/local/nginx/html;\r\n    index xdclass.html;\r\n}\r\n#charset koi8-r;\r\n#\r\naccess_log logs/host.access.log main;\r\n}\r\n```\r\n\r\n4. 统计耗时接口,列出传输时间超过2秒的接口，显示前5条\r\n```shell\r\n#$NF 表示最后⼀列, awk '{print $NF}\r\ncat time_temp.log|awk '($NF > 2){print $7}'|sort -n|uniq -c|sort -nr|head -5\r\n```\r\n\r\n## 防止sql注入\r\n\r\n将下面的Nginx配置文件代码放入到server块中，然后重启Nginx即可\r\n\r\n```nginx\r\n if ($request_method !~* GET|POST) { return 444; }\r\n # 使用444错误代码可以更加减轻服务器负载压力。\r\n # 防止SQL注入\r\n if ($query_string ~* (\\$|'|--|[+|(%20)]union[+|(%20)]|[+|(%20)]insert[+|(%20)]|[+|(%20)]drop[+|(%20)]|[+|(%20)]truncate[+|(%20)]|[+|(%20)]update[+|(%20)]|[+|(%20)]from[+|(%20)]|[+|(%20)]grant[+|(%20)]|[+|(%20)]exec[+|(%20)]|[+|(%20)]where[+|(%20)]|[+|(%20)]select[+|(%20)]|[+|(%20)]and[+|(%20)]|[+|(%20)]or[+|(%20)]|[+|(%20)]count[+|(%20)]|[+|(%20)]exec[+|(%20)]|[+|(%20)]chr[+|(%20)]|[+|(%20)]mid[+|(%20)]|[+|(%20)]like[+|(%20)]|[+|(%20)]iframe[+|(%20)]|[\\<|%3c]script[\\>|%3e]|javascript|alert|webscan|dbappsecurity|style|confirm\\(|innerhtml|innertext)(.*)$) { return 555; }\r\n if ($uri ~* (/~).*) { return 501; }\r\n if ($uri ~* (\\\\x.)) { return 501; }\r\n # 防止SQL注入 \r\n if ($query_string ~* \"[;'<>].*\") { return 509; }\r\n if ($request_uri ~ \" \") { return 509; }\r\n if ($request_uri ~ (\\/\\.+)) { return 509; }\r\n if ($request_uri ~ (\\.+\\/)) { return 509; }\r\n # if ($uri ~* (insert|select|delete|update|count|master|truncate|declare|exec|\\*|\\')(.*)$ ) { return 503; }\r\n # 防止SQL注入\r\n if ($request_uri ~* \"(cost\\()|(concat\\()\") { return 504; }\r\n if ($request_uri ~* \"[+|(%20)]union[+|(%20)]\") { return 504; }\r\n if ($request_uri ~* \"[+|(%20)]and[+|(%20)]\") { return 504; }\r\n if ($request_uri ~* \"[+|(%20)]select[+|(%20)]\") { return 504; }\r\n if ($request_uri ~* \"[+|(%20)]or[+|(%20)]\") { return 504; }\r\n if ($request_uri ~* \"[+|(%20)]delete[+|(%20)]\") { return 504; }\r\n if ($request_uri ~* \"[+|(%20)]update[+|(%20)]\") { return 504; }\r\n if ($request_uri ~* \"[+|(%20)]insert[+|(%20)]\") { return 504; }\r\n if ($query_string ~ \"(<|%3C).*script.*(>|%3E)\") { return 505; }\r\n if ($query_string ~ \"GLOBALS(=|\\[|\\%[0-9A-Z]{0,2})\") { return 505; }\r\n if ($query_string ~ \"_REQUEST(=|\\[|\\%[0-9A-Z]{0,2})\") { return 505; }\r\n if ($query_string ~ \"proc/self/environ\") { return 505; }\r\n if ($query_string ~ \"mosConfig_[a-zA-Z_]{1,21}(=|\\%3D)\") { return 505; }\r\n if ($query_string ~ \"base64_(en|de)code\\(.*\\)\") { return 505; }\r\n if ($query_string ~ \"[a-zA-Z0-9_]=http://\") { return 506; }\r\n if ($query_string ~ \"[a-zA-Z0-9_]=(\\.\\.//?)+\") { return 506; }\r\n if ($query_string ~ \"[a-zA-Z0-9_]=/([a-z0-9_.]//?)+\") { return 506; }\r\n if ($query_string ~ \"b(ultram|unicauca|valium|viagra|vicodin|xanax|ypxaieo)b\") { return 507; }\r\n if ($query_string ~ \"b(erections|hoodia|huronriveracres|impotence|levitra|libido)b\") {return 507; }\r\n if ($query_string ~ \"b(ambien|bluespill|cialis|cocaine|ejaculation|erectile)b\") { return 507; }\r\n if ($query_string ~ \"b(lipitor|phentermin|pro[sz]ac|sandyauer|tramadol|troyhamby)b\") { return 507; }\r\n # 这里大家根据自己情况添加删减上述判断参数，cURL、wget这类的屏蔽有点儿极端了，但要“宁可错杀一千，不可放过一个”。\r\n if ($http_user_agent ~* YisouSpider|ApacheBench|WebBench|Jmeter|JoeDog|Havij|GetRight|TurnitinBot|GrabNet|masscan|mail2000|github|wget|curl|Java|python) { return 508; }\r\n # 同上，大家根据自己站点实际情况来添加删减下面的屏蔽拦截参数。\r\n if ($http_user_agent ~* \"Go-Ahead-Got-It\") { return 508; }\r\n if ($http_user_agent ~* \"GetWeb!\") { return 508; }\r\n if ($http_user_agent ~* \"Go!Zilla\") { return 508; }\r\n if ($http_user_agent ~* \"Download Demon\") { return 508; }\r\n if ($http_user_agent ~* \"Indy Library\") { return 508; }\r\n if ($http_user_agent ~* \"libwww-perl\") { return 508; }\r\n if ($http_user_agent ~* \"Nmap Scripting Engine\") { return 508; }\r\n if ($http_user_agent ~* \"~17ce.com\") { return 508; }\r\n if ($http_user_agent ~* \"WebBench*\") { return 508; }\r\n if ($http_user_agent ~* \"spider\") { return 508; } #这个会影响国内某些搜索引擎爬虫，比如：搜狗\r\n # 拦截各恶意请求的UA，可以通过分析站点日志文件或者waf日志作为参考配置。\r\n if ($http_referer ~* 17ce.com) { return 509; }\r\n # 拦截17ce.com站点测速节点的请求，所以明月一直都说这些测速网站的数据仅供参考不能当真的。\r\n if ($http_referer ~* WebBench*\") { return 509; }\r\n # 拦截WebBench或者类似压力测试工具，其他工具只需要更换名称即可。\r\n```\r\n\r\n## 相关文章\r\n\r\n| [这是一个Nginx极简教程，目的在于帮助新手快速入门Nginx。](https://github.com/dunwu/nginx-tutorial) | [就是要让你搞懂Nginx，这篇就够了！](https://mp.weixin.qq.com/s/5Q_VQoQY6kJiMwMHHDIijA) | [Nginx为什么快到根本停不下来？](https://mp.weixin.qq.com/s/e7r2Jt1DlF_4HpZU_IKZkQ) |\r\n| :----------------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |\r\n| [手把手教你在CentOS7上搭建Nginx](https://mp.weixin.qq.com/s?__biz=MzkzODE3OTI0Ng==&amp;mid=2247490879&amp;idx=1&amp;sn=bd93bc46cdfb7919b9a304c176927dd8&amp;source=41#wechat_redirect) | [nginx实现动态分离,解决css和js等图片加载问题](https://www.cnblogs.com/sz-jack/p/5206159.html) | [nginx反向代理tomcat，js，css静态资源不加载问题](https://blog.csdn.net/white1114579650/article/details/120151335) |\r\n| [彻底搞懂Nginx的五大应用场景](https://mp.weixin.qq.com/s/v6j2HStMHBDlak6UGTF0Hw) | [nginx配置参数](https://blog.51cto.com/ting2junshui/2066268) | [Nginx轻松搞定跨域问题！](https://mp.weixin.qq.com/s/clSjaLJSht5J8woIaiH4gA) |\r\n| [如何使用Nginx优雅地限流？](https://mp.weixin.qq.com/s/YXJ1jcr7XLKTbzf9kyjiEg) | [一文学会Nginx的限流配置](https://mp.weixin.qq.com/s/s4j043__MiXst8wHpEPUoA) | [Nginx如何限流？](https://mp.weixin.qq.com/s/R6GajrvNphXfgKWDsFWzFw) |\r\n|           [nginxconfig.io](https://nginxconfig.io)           | [为什么Nginx比Apache更牛叉？](https://mp.weixin.qq.com/s/pPV5s3uO1sjPTAhz_BDcJg) | [如何用Nginx代理MySQL连接，并限制可访问IP？](https://mp.weixin.qq.com/s/6lvKIQb4yk7uTmufr9pJ8w) |\r\n","categories":[],"tags":[{"name":"安装","path":"api/tags/安装.json"}]}