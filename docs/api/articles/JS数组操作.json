{"title":"JS数组操作","slug":"JS数组操作","date":"2023-05-17T08:15:59.304Z","updated":"2023-07-04T06:58:51.676Z","comments":true,"path":"api/articles/JS数组操作.json","excerpt":null,"covers":"https://picx.zhimg.com/v2-271693316513b5a0410ca80a2c160b5e_1440w.jpg","content":"\r\n\r\n## 常用操作\r\n\r\n### 声明数组\r\n\r\n```js\r\nconst fruits = new Array('Apple', 'Banana');\r\nconsole.log(fruits.length);\r\n\r\n// 通过数组字面量创建一个有2个元素的'fruits'数组.\r\nconst fruits = ['Apple', 'Banana'];\r\nconsole.log(fruits.length);\r\n```\r\n\r\n### 数组去重\r\n\r\n```js\r\n// 方案一：Set + ...\r\nfunction noRepeat(arr) {\r\n  return [...new Set(arr)];\r\n}\r\nnoRepeat([1, 2, 3, 1, 2, 3]);\r\n\r\n// 方案二：Set + Array.from\r\nfunction noRepeat(arr) {\r\n  return Array.from(new Set(arr));\r\n}\r\nnoRepeat([1, 2, 3, 1, 2, 3]);\r\n\r\n// 方案三：双重遍历比对下标\r\nfunction noRepeat(arr) {\r\n  return arr.filter((v, idx) => idx == arr.lastIndexOf(v));\r\n}\r\nnoRepeat([1, 2, 3, 1, 2, 3]);\r\n\r\n// 方案四：单遍历 + Object特性\r\n// Object的特性是Key不会重复。\r\n// 这里使用values是因为可以保留类型，keys会变成字符串。\r\nfunction noRepeat(arr) {\r\n  return Object.values(\r\n    arr.reduce((s, n) => {\r\n      s[n] = n;\r\n      return s;\r\n    }, {})\r\n  );\r\n}\r\nnoRepeat([1, 2, 3, 1, 2, 3]);\r\nfunction uniqueArr(arr){\r\n    return [...new Set(arr)]\r\n}\r\n\r\n// 数组对象根据字段去重\r\n// 参数：arr:要去重的数组 key:根据去重的字段名\r\nexport const uniqueArrayObject = (arr = [], key = 'id') => {\r\n    if (arr.length === 0) return\r\n    let list = []\r\n    const map = {}\r\n    arr.forEach((item) => {\r\n        if (!map[item[key]]) {\r\n            map[item[key]] = item\r\n        }\r\n    })\r\n    list = Object.values(map)\r\n\r\n    return list\r\n}\r\n\r\n// 示例：\r\nconst responseList = [\r\n    { id: 1, name: '树哥' },\r\n    { id: 2, name: '黄老爷' },\r\n    { id: 3, name: '张麻子' },\r\n    { id: 1, name: '黄老爷' },\r\n    { id: 2, name: '张麻子' },\r\n    { id: 3, name: '树哥' },\r\n    { id: 1, name: '树哥' },\r\n    { id: 2, name: '黄老爷' },\r\n    { id: 3, name: '张麻子' },\r\n]\r\nuniqueArrayObject(responseList, 'id')\r\n// [{ id: 1, name: '树哥' },{ id: 2, name: '黄老爷' },{ id: 3, name: '张麻子' }]\r\n\r\n// 提取唯一值 我们可以使用Set对象和Spread运算符，创建一个剔除重复值的新数组。\r\nvar entries = [1, 2, 2, 3, 4, 5, 6, 6, 7, 7, 8, 4, 2, 1]\r\nvar unique_entries = [...new Set(entries)];\r\nconsole.log(unique_entries);// [1, 2, 3, 4, 5, 6, 7, 8]\r\n```\r\n\r\n### 返回两个数组中相同的元素\r\n\r\n```js\r\n// 方案一：filter + includes\r\nfunction intersection(arr1, arr2) {\r\n  return arr2.filter((v) => arr1.includes(v));\r\n}\r\nintersection([1, 2, 3], [3, 4, 5, 2]);\r\n\r\n// 方案二：同理变种用 hash\r\nfunction intersection(arr1, arr2) {\r\n  var set = new Set(arr2);\r\n  return arr1.filter((v) => set.has(v));\r\n}\r\nintersection([1, 2, 3], [3, 4, 5, 2]);\r\n```\r\n\r\n### 对比两个数组并且返回其中不同的元素\r\n\r\n```js\r\n// 方案一：filter + includes\r\n// 他原文有问题，以下方法的4,5没有返回\r\n\r\nfunction diffrence(arrA, arrB) {\r\n  return arrA.filter((v) => !arrB.includes(v));\r\n}\r\ndiffrence([1, 2, 3], [3, 4, 5, 2]);\r\n// 需要再操作一遍\r\nfunction diffrence(arrA, arrB) {\r\n  return arrA\r\n    .filter((v) => !arrB.includes(v))\r\n    .concat(arrB.filter((v) => !arrA.includes(v)));\r\n}\r\ndiffrence([1, 2, 3], [3, 4, 5, 2]);\r\n\r\n// 方案二：hash + 遍历\r\n// 算是方案1的变种吧，优化了includes的性能。\r\n```\r\n\r\n### 检查数组中某元素出现的次数\r\n\r\n```js\r\n// 方案一：reduce\r\nfunction countOccurrences(arr, value) {\r\n  return arr.reduce((a, v) => (v === value ? a + 1 : a + 0), 0);\r\n}\r\ncountOccurrences([1, 2, 3, 4, 5, 1, 2, 1, 2, 3], 1);\r\n\r\n// 方案二：filter\r\nfunction countOccurrences(arr, value) {\r\n  return arr.filter((v) => v === value).length;\r\n}\r\ncountOccurrences([1, 2, 3, 4, 5, 1, 2, 1, 2, 3], 1);\r\n```\r\n\r\n### 删除数组重复项\r\n\r\n```js\r\nconst numberArrays = [undefined,Infinity,\r\n  12,NaN,false,5,7,null,12,false,5,undefined,89,9,\r\n  null,Infinity,5, NaN];\r\nconst objArrays = [{ id: 1 }, { id: 4 }, { id: 1 }, { id: 5 }, { id: 4 }];\r\nconsole.log(\r\n  // prints [undefined, Infinity, 12, NaN, false, 5, 7, null, 89, 9]\r\n  Array.from(new Set(numberArrays)),\r\n  // prints [{id: 1}, {id: 4}, {id: 1}, {id: 5}, {id: 4}]\r\n  // nothing changes because even though the ids repeat in some objects\r\n  // the objects are different instances, different objects\r\n  Array.from(new Set(objArrays))\r\n);\r\nconst idSet = new Set();\r\nconsole.log(\r\n  // prints [{id: 1}, {id: 4}, {id: 5}] using id to track id uniqueness\r\n  objArrays.filter((obj) => {\r\n    const existingId = idSet.has(obj.id);\r\n    idSet.add(obj.id);\r\n    return !existingId;\r\n  })\r\n);\r\n```\r\n\r\n### 查找数组最大\r\n\r\n```js\r\n// 方案一：Math.max + ...\r\nfunction arrayMax(arr) {\r\n  return Math.max(...arr);\r\n}\r\narrayMax([-1, -4, 5, 2, 0]);\r\n\r\n// 方案二：Math.max + apply\r\nfunction arrayMax(arr) {\r\n  return Math.max.apply(Math, arr);\r\n}\r\narrayMax([-1, -4, 5, 2, 0]);\r\n\r\n// 方案三：Math.max + 遍历\r\nfunction arrayMax(arr) {\r\n  return arr.reduce((s, n) => Math.max(s, n));\r\n}\r\narrayMax([-1, -4, 5, 2, 0]);\r\n\r\n// 方案四：比较、条件运算法 + 遍历\r\nfunction arrayMax(arr) {\r\n  return arr.reduce((s, n) => (s > n ? s : n));\r\n}\r\narrayMax([-1, -4, 5, 2, 0]);\r\n\r\n// 方案五：排序\r\nfunction arrayMax(arr) {\r\n  return arr.sort((n, m) => m - n)[0];\r\n}\r\narrayMax([-1, -4, 5, 2, 0]);\r\n\r\n```\r\n### 查找数组最小\r\n\r\n```js\r\n// Math.max换成Math.min\r\n// s>n?s:n换成s<n?s:n\r\n// (n,m)=>m-n换成(n,m)=>n-m，或者直接取最后一个元素\r\n```\r\n\r\n### 返回以size为长度的数组分割的原数组\r\n\r\n```js\r\n// 方案一：Array.from + slice\r\nfunction chunk(arr, size = 1) {\r\n  return Array.from(\r\n    {\r\n      length: Math.ceil(arr.length / size),\r\n    },\r\n    (v, i) => arr.slice(i * size, i * size + size)\r\n  );\r\n}\r\nchunk([1, 2, 3, 4, 5, 6, 7, 8], 3);\r\n\r\n// 方案二：Array.from + splice\r\nfunction chunk(arr, size = 1) {\r\n  return Array.from(\r\n    {\r\n      length: Math.ceil(arr.length / size),\r\n    },\r\n    (v, i) => arr.splice(0, size)\r\n  );\r\n}\r\nchunk([1, 2, 3, 4, 5, 6, 7, 8], 3);\r\n\r\n// 方案三：遍历 + splice\r\nfunction chunk(arr, size = 1) {\r\n  var _returnArr = [];\r\n  while (arr.length) {\r\n    _returnArr.push(arr.splice(0, size));\r\n  }\r\n  return _returnArr;\r\n}\r\nchunk([1, 2, 3, 4, 5, 6, 7, 8], 3);\r\n```\r\n\r\n### 扁平化数组\r\n\r\n```js\r\n// 方案一：递归 + ...\r\nfunction flatten(arr, depth = -1) {\r\n  if (depth === -1) {\r\n    return [].concat(\r\n      ...arr.map((v) => (Array.isArray(v) ? this.flatten(v) : v))\r\n    );\r\n  }\r\n  if (depth === 1) {\r\n    return arr.reduce((a, v) => a.concat(v), []);\r\n  }\r\n  return arr.reduce(\r\n    (a, v) => a.concat(Array.isArray(v) ? this.flatten(v, depth - 1) : v),\r\n    []\r\n  );\r\n}\r\nflatten([1, [2, [3]]]);\r\n\r\n// 方案二：es6原生flat\r\nfunction flatten(arr, depth = Infinity) {\r\n  return arr.flat(depth);\r\n}\r\nflatten([1, [2, [3]]]);\r\n```\r\n\r\n### 从右删除n个元素\r\n```js\r\n// 方案一：slice\r\nfunction dropRight(arr, n = 0) {\r\n  return n < arr.length ? arr.slice(0, arr.length - n) : [];\r\n}\r\ndropRight([1, 2, 3, 4, 5], 2);\r\n\r\n// 方案二: splice\r\nfunction dropRight(arr, n = 0) {\r\n  return arr.splice(0, arr.length - n);\r\n}\r\ndropRight([1, 2, 3, 4, 5], 2);\r\n\r\n// 方案三: slice另一种\r\nfunction dropRight(arr, n = 0) {\r\n  return arr.slice(0, -n);\r\n}\r\ndropRight([1, 2, 3, 4, 5], 2);\r\n\r\n// 方案四: 修改length\r\nfunction dropRight(arr, n = 0) {\r\n  arr.length = Math.max(arr.length - n, 0);\r\n  return arr;\r\n}\r\ndropRight([1, 2, 3, 4, 5], 2);\r\n```\r\n\r\n### 截取第一个符合条件的元素及其以后的元素\r\n\r\n```js\r\n// 方案一：slice + 循环\r\nfunction dropElements(arr, fn) {\r\n  while (arr.length && !fn(arr[0])) arr = arr.slice(1);\r\n  return arr;\r\n}\r\ndropElements([1, 2, 3, 4, 5, 1, 2, 3], (v) => v == 2);\r\n\r\n// 方案二：findIndex + slice\r\nfunction dropElements(arr, fn) {\r\n  return arr.slice(Math.max(arr.findIndex(fn), 0));\r\n}\r\ndropElements([1, 2, 3, 4, 5, 1, 2, 3], (v) => v === 3);\r\n\r\n// 方案三：splice + 循环\r\nfunction dropElements(arr, fn) {\r\n  while (arr.length && !fn(arr[0])) arr.splice(0, 1);\r\n  return arr;\r\n}\r\ndropElements([1, 2, 3, 4, 5, 1, 2, 3], (v) => v == 2);\r\n```\r\n\r\n### 返回数组中下标间隔nth的元素\r\n\r\n```js\r\n// 方案一：filter\r\nfunction everyNth(arr, nth) {\r\n  return arr.filter((v, i) => i % nth === nth - 1);\r\n}\r\neveryNth([1, 2, 3, 4, 5, 6, 7, 8], 2);\r\n\r\n// 方案二：方案一修改判断条件\r\nfunction everyNth(arr, nth) {\r\n  return arr.filter((v, i) => (i + 1) % nth === 0);\r\n}\r\neveryNth([1, 2, 3, 4, 5, 6, 7, 8], 2);\r\n```\r\n\r\n### 返回数组中第n个元素（支持负数）\r\n\r\n```js\r\n// 方案一：slice\r\nfunction nthElement(arr, n = 0) {\r\n  return (n >= 0 ? arr.slice(n, n + 1) : arr.slice(n))[0];\r\n}\r\nnthElement([1, 2, 3, 4, 5], 0);\r\nnthElement([1, 2, 3, 4, 5], -1);\r\n\r\n// 方案二：三目运算符\r\nfunction nthElement(arr, n = 0) {\r\n  return n >= 0 ? arr[0] : arr[arr.length + n];\r\n}\r\nnthElement([1, 2, 3, 4, 5], 0);\r\nnthElement([1, 2, 3, 4, 5], -1);\r\n```\r\n\r\n### 返回数组头元素\r\n```js\r\n// 方案一：\r\nfunction head(arr) {\r\n  return arr[0];\r\n}\r\nhead([1, 2, 3, 4]);\r\n\r\n// 方案二：\r\nfunction head(arr) {\r\n  return arr.slice(0, 1)[0];\r\n}\r\nhead([1, 2, 3, 4]);\r\n```\r\n\r\n### 返回数组末尾元素\r\n\r\n```js\r\n// 方案一：\r\nfunction last(arr) {\r\n  return arr[arr.length - 1];\r\n}\r\n\r\n// 方案二：\r\nfunction last(arr) {\r\n  return arr.slice(-1)[0];\r\n}\r\nlast([1, 2, 3, 4, 5]);\r\n```\r\n\r\n### 数组乱排\r\n\r\n```js\r\n// 方案一：洗牌算法\r\nfunction shuffle(arr) {\r\n  let array = arr;\r\n  let index = array.length;\r\n\r\n  while (index) {\r\n    index -= 1;\r\n    let randomInedx = Math.floor(Math.random() * index);\r\n    let middleware = array[index];\r\n    array[index] = array[randomInedx];\r\n    array[randomInedx] = middleware;\r\n  }\r\n\r\n  return array;\r\n}\r\nshuffle([1, 2, 3, 4, 5]);\r\n\r\n/**\r\n * 方案二：sort + random\r\n */\r\nfunction shuffle(arr) {\r\n  return arr.sort((n, m) => Math.random() - 0.5);\r\n}\r\nshuffle([1, 2, 3, 4, 5]);\r\n```\r\n\r\n### 伪数组转换为数组\r\n```js\r\n// Array.from将伪数组变成数组，就是只要有length的属性就可以转成数组\r\nArray.from({ length: 2 });\r\nlet name = \"javascript\";\r\nconsole.log(name.length); // 10\r\nlet arr = Array.from(name);\r\nconsole.log(arr); // [ 'j', 'a', 'v', 'a', 's', 'c', 'r', 'i', 'p', 't' ]\r\n// prototype.slice\r\nArray.prototype.slice.call({ length: 2, 1: 1 });\r\n// prototype.splice\r\nArray.prototype.splice.call({ length: 2, 1: 1 }, 0);\r\n// Array.of()将一组值转换成数组，类似于声明数组\r\nlet arr = Array.of(10);\r\nlet arr2 = Array.of(\"hello\", \"world\");\r\nconsole.log(arr); // [ 10 ] \r\nconsole.log(arr2); // [ 'hello', 'world' ]\r\n```\r\n\r\n### 数组重排序\r\n\r\n```js\r\nconst shuffle = (arr) => arr.sort(() => Math.random() - 0.5)\r\nconst arr = [1, 2, 3, 4, 5]\r\nconsole.log(shuffle(arr))\r\n```\r\n\r\n### 数组随机打乱顺序\r\n\r\n通过0.5-Math.random()得到一个随机数，再通过两次sort排序打乱的更彻底,但是这个方法实际上并不够随机，如果是企业级运用，建议使用第二种洗牌算法\r\n\r\n```js\r\nshuffle(arr) {\r\n      return arr.sort(() => 0.5 - Math.random()). sort(() => 0.5 - Math.random());\r\n },\r\n\r\nfunction shuffle(arr) {\r\n  for (let i = arr.length - 1; i > 0; i--) {\r\n    const randomIndex = Math.floor(Math.random() * (i + 1))\r\n    ;[arr[i], arr[randomIndex]] = [arr[randomIndex], arr[i]]\r\n  }\r\n  return arr\r\n}\r\n```\r\n### 把数组最后一项移到第一项\r\n\r\n```js\r\nfunction (arr){\r\n    return arr.push(arr.shift());\r\n}\r\n```\r\n\r\n### 把数组的第一项放到最后一项\r\n\r\n```js\r\nfunction(arr){\r\n  return arr.unshift(arr.pop());\r\n}\r\n```\r\n\r\n### 各种数组克隆方法\r\n数组克隆的方法其实特别多了，看看有没有你没见过的！\r\n\r\n```js\r\nconst clone = (arr) => arr.slice(0);\r\nconst clone = (arr) => [...arr];\r\nconst clone = (arr) => Array.from(arr);\r\nconst clone = (arr) => arr.map((x) => x);\r\nconst clone = (arr) => JSON.parse(JSON.stringify(arr));\r\nconst clone = (arr) => arr.concat([]);\r\nconst clone = (arr) => structuredClone(arr);\r\n```\r\n\r\n### 交换数组值的位置\r\n```js\r\nconst array = [12, 24, 48];\r\nconst swap0ldway = (arr, i, j) => {\r\n  const arrayCopy = [...arr];\r\n  let temp = arayCopy[i];\r\n  arrayCopy[i] = arrayCopy[j];\r\n\r\n  arrayCopy[j] = temp;\r\n  return arrayCopy;\r\n};\r\n\r\nconst swapNewWay = (arr, i, j) => {\r\n  const arrayCopy = [...arr];\r\n  [arrayCopy[0], arrayCopy[2]] = [arrayCopy[2], arrayCopy[0]];\r\n  return arrayCopy;\r\n};\r\n\r\nconsole.log(swap0ldWay(array, 0, 2)); // outputs: [48, 24, 12]\r\nconsole.log(swapNewWay(array, 0, 2)); // outputs: [48, 24, 12]\r\n```\r\n\r\n### 随机排列数组中的元素\r\n```js\r\nvar my_list = [1, 2, 3, 4, 5, 6, 7, 8, 9];\r\nconsole.log(my_list.sort(function() {\r\n    return Math.random() - 0.5\r\n}));// [4, 8, 2, 9, 1, 3, 6, 5, 7]\r\n```\r\n### 展平多维数组\r\n```js\r\nvar entries = [1, [2, 5], [6, 7], 9];\r\nvar flat_entries = [].concat(...entries);// [1, 2, 5, 6, 7, 9]\r\n```\r\n\r\n### 使用length调整大小 / 清空数组\r\n```js\r\n// 如果我们要调整数组的大小：\r\nvar entries = [1, 2, 3, 4, 5, 6, 7];\r\nconsole.log(entries.length);// 7\r\nentries.length = 4;\r\nconsole.log(entries.length);// 4\r\nconsole.log(entries);// [1, 2, 3, 4]\r\n// 如果我们要清空数组：\r\nvar entries = [1, 2, 3, 4, 5, 6, 7];\r\nconsole.log(entries.length);// 7\r\nentries.length = 0;\r\nconsole.log(entries.length);// 0\r\nconsole.log(entries);// []\r\n```\r\n\r\n## 常用方法\r\n\r\n### 栈方法\r\n\r\n后进先出\r\n\r\n#### push()\r\n\r\n可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度\r\n\r\n```js\r\nlet arr = [1, 2, 3];\r\narr.push(4);\r\nconsole.log(arr); // [ 1, 2, 3, 4 ]\r\nconsole.log(arr.length); // 4\r\n```\r\n\r\n#### pop()\r\n\r\n从数组末尾移除最后一项，减少数组的length值，然后返回移除的项\r\n\r\n```js\r\nlet arr = [1, 2, 3];\r\nlet delVal = arr.pop();\r\nconsole.log(arr); // [ 1, 2]\r\nconsole.log(delVal); // 3\r\n```\r\n\r\n### 队列方法\r\n\r\n先进先出\r\n\r\n#### shift()\r\n\r\n移除数组中的第一个项并返回该项，同时将数组长度减1\r\n\r\n```js\r\nlet arr = [1, 2, 3];\r\nlet delVal = arr.shift();\r\nconsole.log(delVal); // 1\r\nconsole.log(arr); // [ 2, 3 ]\r\nconsole.log(arr.length); // 2\r\n```\r\n\r\n#### unshift()\r\n\r\n在数组前端添加任意个项并返回新数组的长度\r\n\r\n```js\r\nlet arr = [1, 2, 3];\r\nlet arrLength = arr.unshift(0);\r\nconsole.log(arrLength); // 4\r\nconsole.log(arr); // [ 0, 1, 2, 3 ]\r\n```\r\n\r\n### 排序方法\r\n\r\n#### reverse()\r\n\r\n反转数组项的顺序\r\n\r\n```js\r\nlet arr = [1, 2, 3];\r\narr.reverse();\r\nconsole.log(arr); // [ 3, 2, 1 ]\r\n```\r\n\r\n#### sort()\r\n\r\n从小到大排序，但它的排序方法是根据数组转换字符串后来排序的\r\n\r\n```js\r\nlet arr = [1, 5, 10, 15];\r\nconsole.log(arr.sort()); // [ 1, 10, 15, 5 ] 原因：它们比较的是转换的字符串值\r\n// 从小到大排序\r\nconsole.log(arr.sort(compare)); // [ 1, 5, 10, 15 ]\r\nfunction compare(value1, value2) {\r\n  if (value1 < value2) {\r\n    return -1;\r\n  } else if (value1 > value2) {\r\n    return 1;\r\n  } else {\r\n    return 0;\r\n  }\r\n}\r\n```\r\n\r\n### 操作方法\r\n\r\n#### join()\r\n\r\nJavaScript数组中的join()方法是一个内置方法，通过连接数组的所有元素来创建并返回新字符串。join()方法将连接数组的项到字符串并返回该字符串。指定的分隔符用于分隔元素数组。默认分隔符是逗号(,)。\r\n\r\n```js\r\nconst elements = ['Fire', 'Air', 'Water'];\r\nconsole.log(elements.join());\r\n// expected output: \"Fire,Air,Water\"\r\nconsole.log(elements.join(''));\r\n// expected output: \"FireAirWater\"\r\nconsole.log(elements.join('-'));\r\n// expected output: \"Fire-Air-Water\"\r\n```\r\n\r\n#### concat()\r\n\r\n可以基于当前数组中的所有项创建一个新数组，不会影响原数组的值\r\n\r\n```js\r\nlet arr = [1, 2, 3];\r\nlet newArr = arr.concat([4, 5, 6], [7, 8, 9]);\r\nconsole.log(newArr); // [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]\r\nconsole.log(arr); // [1, 2, 3]\r\nconst array1 = ['a', 'b', 'c'];\r\nconst array2 = ['d', 'e', 'f'];\r\nconst array3 = array1.concat(array2);\r\n```\r\n\r\n#### slice()\r\n\r\n它能够基于当前数组中的一或多个项创建一个新数组\r\n\r\n- slice()方法可以接受一或两个参数，即要返回项的起始和结束位置\r\n- 在只有一个参数的情况下，slice()方法返回从该参数指定位置开始到当前数组末尾的所有项。\r\n- 如果有两个参数，该方法返回起始和结束位置之间的项——但不包括结束位置的项。\r\n- 注意，slice()方法不会影响原始数组\r\n\r\n```js\r\nlet arr = [1, 2, 3, 4];\r\nlet newArr = arr.slice(1, 2);\r\nconsole.log(newArr); // [ 2 ]\r\nlet newArr2 = arr.slice(1);\r\nconsole.log(newArr2); // [ 2, 3, 4 ]\r\n```\r\n\r\n#### splice()\r\n\r\n##### 删除\r\n\r\n可以删除任意数量的项，只需指定2个参数：要删除的第一项的位置和要删除的项数。例如，splice(0,2)会删除数组中的前两项。\r\n\r\n```js\r\nlet arr = [1, 2, 3, 4];\r\narr.splice(1, 2);\r\nconsole.log(arr); // [ 1, 4 ]\r\n```\r\n\r\n##### 插入\r\n\r\n可以向指定位置插入任意数量的项，只需提供3个参数：起始位置、0（要删除的项数）和要插入的项。如果要插入多个项，可以再传入第四、第五，以至任意多个项。例如，splice(2,0,“red”,“green”)会从当前数组的位置2开始插入字符串\"red\"和\"green\"。\r\n\r\n```js\r\nlet arr = [1, 2, 3, 4];\r\narr.splice(1, 0, \"java\", \"script\");\r\nconsole.log(arr); // [ 1, 'java', 'script', 2, 3, 4 ]\r\n```\r\n\r\n##### 替换\r\n\r\n可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定3个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。例如，splice(2,1,“red”,“green”)会删除当前数组位置2的项，然后再从位置2开始插入字符串\"red\"和\"green\"。\r\n\r\n```js\r\nlet arr = [1, 2, 3, 4];\r\narr.splice(1, 1, \"java\", \"script\");\r\nconsole.log(arr); // [ 1, 'java', 'script', 3, 4 ]\r\n```\r\n\r\n#### arr.fill(target,start,end)\r\n\r\n使用给定的值，填充一个数组,ps:填充完后会改变原数组\r\n\r\n- target – 待填充的元素\r\n- start – 开始填充的位置-索引\r\n- end – 终止填充的位置-索引(不包括该位置)\r\n\r\n```js\r\nlet arr = [1, 2, 3, 4];\r\nlet arr2 = [5, 6, 7, 8];\r\n// 全部填充5\r\narr.fill(5);\r\nconsole.log(arr); // [ 5, 5, 5, 5 ]\r\n// 从索引为1到3填充9\r\narr2.fill(9, 1, 3);\r\nconsole.log(arr2); // [ 5, 9, 9, 8 ]\r\n```\r\n\r\n#### Array.isArray(arr)\r\n\r\n判断传入的值是否为数组\r\n\r\n```js\r\nlet arr = [];\r\nlet obj = {};\r\nconsole.log(Array.isArray(arr)); // true\r\nconsole.log(Array.isArray(obj)); // false\r\n```\r\n\r\n在当前数组内部，将制定位置的数组复制到其他位置，会覆盖原数组项，返回当前数组\r\n参数:\r\n\r\n- target --必选 索引从该位置开始替换数组项\r\n- start --可选 索引从该位置开始读取数组项，默认为0，如果为负值，则从右往左读。\r\n- end --可选 索引到该位置停止读取的数组项，默认是Array.length,如果是负值，表示倒数\r\n\r\n```js\r\nlet arr = [1, 2, 3, 4, 5, 6];\r\n\r\nconsole.log(arr.copyWithin(2, 0)); // [1, 2, 1, 2, 3, 4]\r\nconsole.log(arr.copyWithin(2, 0, 4)); // [ 1, 2, 1, 2, 1, 2 ]\r\n```\r\n\r\n### 位置方法\r\n\r\n#### at()\r\n\r\n```js\r\nconst array1 = [5, 12, 8, 130, 44];\r\nlet index = 2;\r\nconsole.log(Using an index of ${index} the item returned is ${array1.at(index)});\r\n// expected output: \"Using an index of 2 the item returned is 8\"\r\nindex = -2;\r\nconsole.log(Using an index of ${index} item returned is ${array1.at(index)});\r\n```\r\n\r\n#### indexOf()和lastIndexOf()\r\n\r\n这两个方法都接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中，indexOf()方法从数组的开头（位置0）开始向后查找，lastIndexOf()方法则从数组的末尾开始向前查找。\r\n\r\n```js\r\nlet arr = [1, 2, 3, 2, 1];\r\n// 从0开始查询值为2的位置\r\nconsole.log(arr.indexOf(2)); // 1\r\n// 从索引为2开始查询值为2的位置\r\nconsole.log(arr.indexOf(2, 2)); // 3\r\n// 倒叙查询值为2的位置\r\nconsole.log(arr.lastIndexOf(2)); // 3\r\n// 倒叙查询值为2的位置\r\nconsole.log(arr.lastIndexOf(2, 2)); // 1\r\n```\r\n\r\n#### find()\r\n\r\n数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。\r\n\r\n```js\r\nlet arr = [1, 2, 3, 4, 5, 6];\r\nlet index = arr.find(val => val === 3);\r\nlet index2 = arr.find(val => val === 100);\r\nconsole.log(index); // 3\r\nconsole.log(index2); // undefined\r\nconst array1 = [5, 12, 8, 130, 44];\r\nconst found = array1.find(element => element > 10);\r\nconsole.log(found);\r\n```\r\n\r\n#### findIndex()\r\n\r\n和数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。\r\n\r\n```js\r\nlet arr = [1, 2, 3, 4, 5, 6];\r\nlet index = arr.findIndex(val => val === 3);\r\nlet index2 = arr.findIndex(val => val === 100);\r\n\r\nconsole.log(index); // 2\r\nconsole.log(index2); // -1\r\n```\r\n\r\n#### includes()\r\n\r\n方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。\r\n\r\n```js\r\nlet arr = [1, 2, 3, 4, 5, 6];\r\n\r\nconsole.log(arr.includes(3)); // true\r\nconsole.log(arr.includes(100)); // false\r\n```\r\n\r\n### 迭代方法\r\n\r\n#### every()\r\n\r\n对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true。\r\n\r\n```js\r\nlet arr = [1, 2, 3, 4, 5, 6];\r\n// 是否所有的值都大于3\r\nlet isTrue = arr.every(value => value > 3);\r\nconsole.log(isTrue); // false;\r\nconst isBelowThreshold = (currentValue) => currentValue < 40;\r\nconst array1 = [1, 30, 39, 29, 10, 13];\r\nconsole.log(array1.every(isBelowThreshold));\r\n```\r\n\r\n#### filter()\r\n\r\n对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组。\r\n\r\n```js\r\nlet arr = [1, 2, 3, 4, 5, 6];\r\n// 取数组中大于3的值重新组成新数组\r\nlet newArr = arr.filter(value => value > 3);\r\nconsole.log(newArr); // [ 4, 5, 6 ]\r\nconst words = ['spray', 'limit', 'elite', 'exuberant', 'destruction', 'present'];\r\nconst result = words.filter(word => word.length > 6);\r\nconsole.log(result);\r\n```\r\n\r\n#### forEach()\r\n\r\n对数组中的每一项运行给定函数。这个方法没有返回值。\r\n\r\n```js\r\nlet arr = [1, 2, 3, 4, 5, 6];\r\n// 迭代数组的每一项\r\narr.forEach((item, index) => {\r\n  console.log(item); // 1, 2, 3, 4, 5, 6\r\n})\r\narr.forEach(element => console.log(element));\r\n```\r\n\r\n#### map()\r\n\r\n对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。\r\n\r\n```js\r\nlet arr = [1, 2, 3, 4, 5, 6];\r\n// 迭代数组每个值加上100返回新数组\r\nlet newArr = arr.map(val => val + 100);\r\nconsole.log(newArr); // [ 101, 102, 103, 104, 105, 106 ]\r\nlet modifiedArr = arr.map(function(element){\r\n    return element *3;\r\n});\r\n```\r\n\r\n#### some()\r\n\r\n对数组中的每一项运行给定函数，如果该函数对任一项返回true，则返回true。\r\n\r\n```js\r\nlet arr = [1, 2, 3, 4, 5, 6];\r\n// 迭代数组的每一项，只要有一项符合条件就返回true\r\nlet isTrue = arr.some(val => val >= 5);\r\nlet isTrue2 = arr.some(val => val > 6);\r\nconsole.log(isTrue); // true\r\nconsole.log(isTrue2); // false\r\nconst array = [1, 2, 3, 4, 5];\r\n// checks whether an element is even\r\nconst even = (element) => element % 2 === 0;\r\nconsole.log(array.some(even));\r\n// expected output: true\r\n```\r\n\r\n#### reduce()和reduceRight()\r\n\r\n这两个方法都会迭代数组的所有项，然后构建一个最终返回的值。其中，reduce()方法从数组的第一项开始，逐个遍历到最后。而reduceRight()则从数组的最后一项开始，向前遍历到第一项。\r\n\r\n```js\r\nlet arr = [1, 2, 3, 4];\r\n// 从左到右累加结果\r\nlet result = arr.reduce((val1, val2) => {\r\n  return val1 + val2;\r\n});\r\nconsole.log(result); // 10\r\n```\r\n> [10个超级实用的reduce使用技巧](https://mp.weixin.qq.com/s/6Ks2Y1gkR50xrI9odDHVGg)\r\n\r\n#### entries()，keys()和values()\r\n\r\nES6提供三个新的方法——entries()，keys()和values()——用于遍历数组。它们都返回一个遍历器对象，可以用for…of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。\r\n\r\n```js\r\nlet arr = [1, 2, 3];\r\n// entries()是对键值对的遍历\r\nfor (let val of arr.entries()) {\r\n  console.log(val);\r\n  /**\r\n   [ 0, 1 ]\r\n   [ 1, 2 ]\r\n   [ 2, 3 ]\r\n   */\r\n}\r\n// keys()是对键名的遍历\r\nfor (let val of arr.keys()) {\r\n  console.log(val); // 0 1 2\r\n}\r\n// values()是对键值的遍历\r\nfor (let val of arr.values()) {\r\n  console.log(val); // 1 2 3\r\n}\r\n```","categories":[{"name":"JS","path":"api/categories/JS.json"}],"tags":[{"name":"代码实战","path":"api/tags/代码实战.json"}]}