{"title":"延时队列","slug":"延时队列","date":"2022-11-11T06:45:07.300Z","updated":"2023-07-04T06:06:15.335Z","comments":true,"path":"api/articles/延时队列.json","excerpt":null,"covers":"https://pic1.zhimg.com/v2-e3810d2595d2bee7f0c807d8efaac578_1440w.jpg","content":"\r\n\r\n## DelayQueue\r\n\r\n延时队列(DelayQueue)是一个无界的BlockingQueue，用于放置实现了Delayed接口的对象，其中的对象只能在其到期时才能从队列中取走。这种队列是有序的，即队头对象的延迟到期时间最长。注意：不能将null元素放置到这种队列中。\r\n\r\n\r\n> [demo](https://github.com/xmxe/demo/blob/master/study-demo/src/main/java/com/xmxe/study_demo/thread/juc/DelayQueueTest.java)\r\n\r\n\r\n```java\r\n/**\r\n * Poll():获取并移除队列的超时元素，没有则返回空\r\n * take():获取并移除队列的超时元素，如果没有则wait当前线程，直到有元素满足超时条件，返回结果。\r\n */\r\npublic class DelayQueueTest {\r\n    public static void main(String[] args) {\r\n        // 模拟5个订单 超时时间为5s 超过5s如果订单没有支付则判定为超时订单\r\n        OrderDelay oider1 = new OrderDelay(\"000001\",TimeUnit.MILLISECONDS.convert(20,TimeUnit.SECONDS));\r\n        OrderDelay oider2 = new OrderDelay(\"000002\",TimeUnit.MILLISECONDS.convert(17,TimeUnit.SECONDS));\r\n        OrderDelay oider3 = new OrderDelay(\"000003\",TimeUnit.MILLISECONDS.convert(32,TimeUnit.SECONDS));\r\n        OrderDelay oider4 = new OrderDelay(\"000004\",TimeUnit.MILLISECONDS.convert(31,TimeUnit.SECONDS));\r\n        OrderDelay oider5 = new OrderDelay(\"000005\",TimeUnit.MILLISECONDS.convert(28,TimeUnit.SECONDS));\r\n    \r\n        DelayQueue<OrderDelay> queue = new DelayQueue<OrderDelay>();\r\n\r\n        queue.put(oider1);\r\n        queue.put(oider2);\r\n        queue.put(oider3);\r\n        queue.put(oider4);\r\n        queue.put(oider5);\r\n        // 模拟订单支付\r\n        oider1.setType(1);oider4.setType(1);\r\n        long start = System.currentTimeMillis();\r\n        while(true){\r\n            try {\r\n                OrderDelay o = queue.take();\r\n                System.out.println(\"订单\"+o+\"的超时时间到了\"+(System.currentTimeMillis()-start));\r\n                // 根据订单状态执行操作\r\n                if(o.getType() == 0){\r\n\r\n                }else{\r\n                    // System.out.println(\"订单有效的是\"+o.getOrderId());\r\n                }\r\n                if(queue.isEmpty()) break;\r\n            } catch (InterruptedException e) {\r\n                e.printStackTrace();\r\n            }  \r\n        }\r\n        \r\n    }  \r\n// 3600分钟转换成小时是多少\r\n// System.out.println(TimeUnit.HOURS.convert(3600,TimeUnit.MINUTES));\r\n// 3600分钟转换成天是多少\r\n// System.out.println(TimeUnit.DAYS.convert(3600,TimeUnit.MINUTES));\r\n}\r\n\r\nclass OrderDelay implements Delayed {\r\n    // 订单id\r\n    private String orderId;\r\n    // 超时时间(纳秒)\r\n    private long timeout;\r\n    // 订单状态,超时取出对象后判定订单是否下单，否则将超时订单删除.type=1订单有效,type=0订单无效\r\n    private int type;\r\n \r\n    OrderDelay(String orderId, long timeout) {\r\n        this.orderId = orderId;\r\n        this.timeout = timeout + System.currentTimeMillis();\r\n    }\r\n \r\n    // compareTo方法必须提供与getDelay方法一致的排序\r\n    // 当生产者线程调用put之类的方法加入元素时，会触发Delayed接口中的compareTo方法进行排序，\r\n    // 也就是说队列中元素的顺序是按到期时间排序的，而非它们进入队列的顺序。排在队列头部的元素是最早到期的，越往后到期时间赿晚。\r\n    // 添加第一个元素不会触发排序\r\n    public int compareTo(Delayed other) {\r\n        if (other == this)  return 0;\r\n        OrderDelay t = (OrderDelay) other;\r\n        System.out.println(\"调用compareTo！比较的对象是\"+this.getOrderId()+\"和\"+t.getOrderId());\r\n        // 排序 排序的目的是将快要超时的对象放到队头;\r\n        long d = (this.getDelay(TimeUnit.MILLISECONDS) - t.getDelay(TimeUnit.MILLISECONDS));\r\n        return (d == 0) ? 0 : ((d < 0) ? -1 : 1);\r\n    }\r\n \r\n\r\n    // 返回距离你自定义的超时时间还有多少\r\n    // 如果此方法返回的值小0或者等于0，则消费者线程会从队列中取出此元素，并进行处理\r\n    @Override\r\n    public long getDelay(TimeUnit unit) {\r\n        long delay = unit.convert(timeout - System.currentTimeMillis(),TimeUnit.MILLISECONDS);\r\n        System.out.println(\"调用getDelay,订单:\"+getOrderId()+\"超时时间=\"+delay);\r\n        return delay;\r\n    }\r\n \r\n    @Override\r\n    public String toString() {\r\n        String str = String.format(\"对象~~~orderId:%s，type=%d,timeout=%d\", orderId,type,timeout);\r\n        return str;\r\n    }\r\n\r\n    public String getOrderId(){\r\n        return orderId;\r\n    }\r\n\r\n    public void setOrderId(String orderId){\r\n        this.orderId = orderId;\r\n    }\r\n\r\n    public int getType(){\r\n        return type;\r\n    }\r\n\r\n    public void setType(int type){\r\n        this.type = type;\r\n    }\r\n}\r\n\r\n\r\n// 将指定的元素插入到此延迟队列中。如果可以立即执行此操作而不违反容量限制，则在成功后返回true，如果当前没有可用空间，则抛出IllegalStateException。\r\nboolean add(E e)\r\n// 将指定集合中的所有元素添加到此队列中。\r\nboolean addAll(Collection<? extends E> c)\r\n// 从此延迟队列中原子地删除所有元素。\r\nvoid clear()\r\n// 从该队列中删除所有可用的元素，并将它们添加到给定的集合中。\r\nint drainTo(Collection<? super E> c)\r\n// 最多从该队列中删除给定数量的可用元素，并将它们添加到给定的集合中。\r\nint drainTo(Collection<? super E> c, int maxElements)\r\n// 返回此队列中所有元素（已过期和未过期）的迭代器。\r\nIterator<E> iterator()\r\n// 将指定的元素插入到此队列中，如果可以立即执行此操作，而不会违反容量限制，true在成功时 false如果当前没有可用空间，则返回false。\r\nboolean offer(E e)\r\n// 将指定的元素插入到此队列中，等待指定的等待时间（如有必要）才能使空间变得可用。\r\nboolean\toffer(E e, long timeout, TimeUnit unit)\r\n// 检索但不删除此队列的头，如果此队列为空，则返回null。\r\nE peek()\r\n// 检索并删除此队列的头，或者如果此队列没有已过期延迟的元素，则返回null。\r\nE poll()\r\n// 检索并删除此队列的头部，如果需要，等待具有到期延迟的元素可用于此队列，或指定的等待时间到期。\r\nE poll(long timeout, TimeUnit unit)\r\n// 将指定的元素插入到此延迟队列中。\r\nvoid put(E e)\r\n// 返回该队列最好可以（在没有存储器或资源约束）接受而不会阻塞，或附加的元素的数量.Integer.MAX_VALUE如果没有固有的限制。总是返回Integer.MAX_VALUE，因为DelayQueue没有容量限制。\r\nint remainingCapacity()\r\n// 从该队列中删除指定元素的单个实例（如果存在），无论其是否已过期。\r\nboolean remove(Object o)\r\n// 删除指定集合中包含的所有此集合的元素（可选操作）。\r\nboolean removeAll(Collection<?> c)\r\n// 返回此集合中的元素数。\r\nint size()\r\n// 检索并删除此队列的头部，如果需要，等待有一个延迟到期的元素在此队列上可用。\r\nE take()\r\n// 返回一个包含此队列中所有元素的数组。\r\nObject[] toArray()\r\n// 返回一个包含此队列中所有元素的数组;返回的数组的运行时类型是指定数组的运行时类型。\r\n<T> T[] toArray(T[] a)\r\n// 检索，但不删除，这个队列的头。\r\nE element()\r\n// 如果此集合包含指定的元素，则返回true。\r\nboolean contains(Object o)\r\n// 如果此集合包含指定集合中的所有元素，则返回true。\r\nboolean containsAll(Collection<?> c)\r\n// 如果此集合不包含元素，则返回true。\r\nboolean isEmpty()\r\n// 仅保留此集合中包含在指定集合中的元素（可选操作）\r\nboolean retainAll(Collection<?> c)\r\n// 返回此集合的字符串表示形式。\r\nString toString()\r\n\r\n```\r\n\r\n## 相关文章\r\n\r\n- [生成订单30分钟未支付，则自动取消，该怎么实现?](https://mp.weixin.qq.com/s/ijv_4_qWTrG-kA9jSbz1iw)\r\n- [一口气说出6种实现延时消息的方案](https://mp.weixin.qq.com/s/VcbZTsoD5-ioc4x7s6mj7Q)\r\n- [面试官：怎么不用定时任务实现关闭订单？](https://mp.weixin.qq.com/s/Oc188nkq4-s9ivt7Ki_M1A)\r\n- [再有人问你如何实现订单到期关闭，就把这篇文章发给他](https://mp.weixin.qq.com/s/BG1PqUWX0XwJX6aMCXCgvw)\r\n- [订单超时怎么处理？阿里用这种方案](https://mp.weixin.qq.com/s/pGZj1jVHKPhUJKlKNnm5CQ)","categories":[{"name":"Java","path":"api/categories/Java.json"}],"tags":[{"name":"代码实战","path":"api/tags/代码实战.json"}]}