{"title":"SQL Server函数","slug":"SQL Server函数","date":"2022-09-26T08:12:36.721Z","updated":"2023-04-18T06:00:24.550Z","comments":true,"path":"api/articles/SQL Server函数.json","excerpt":null,"covers":"https://picx.zhimg.com/v2-499cbcaf31cf035a9850972edb24939f_1440w.jpg","content":"\r\n\r\n## sql server行转列\r\n\r\n类似MySQL group_concat()使用stuff()\r\n\r\nstuff()将字符串插入到另一个字符串中。它从第一个字符串的开始位置删除指定长度的字符；然后将第二个字符串插入到第一个字符串的开始位置。\r\n\r\n```sql\r\nselect stuff('ABCDEFG',2,3,''hijk) = AhijkEFG\r\nSELECT id, value = stuff((SELECT ',' + value FROM temp t WHERE t.id = temp.id FOR xml path('')),1,1,'') FROM temp GROUP BY id\r\n\r\n-- 实例\r\nSELECT t.unit_id,t.value_param,t.code_param,conf.state\r\nFROM\r\n(SELECT \r\nunit_id,\r\nSTUFF((SELECT ',' + val1 FROM gs_pss_config b WHERE b.unit_id = a.unit_id AND b.conf_type = #{conf_type} FOR xml path('')),1,1,'')AS value_param,\r\nSTUFF((SELECT ',' + param_code FROM\tgs_pss_config c\tWHERE c.unit_id = a.unit_id\tAND c.conf_type = #{conf_type} FOR xml path('')),1,1,'')AS code_param\r\nFROM\r\ngs_pss_config a\r\nWHERE a.conf_type = #{conf_type} GROUP BY a.unit_id)t\r\nLEFT JOIN \r\ngs_yctp_unit_config conf on t.unit_id = conf.unit_id \r\n```\r\n\r\n\r\n## 统计数据考核密度\r\n\r\n```sql\r\nselect s.real_tag,s.tag_name,s.unit_id,\r\nsum(case when s.density = 0 then 1 else 0 end ) as density0,\r\nsum(case when s.density > 0 and s.density <=20 then 1 else 0 end ) as density20,\r\nsum(case when s.density > 20 and s.density <=50 then 1 else 0 end ) as density50,\r\nsum(case when s.density > 50 and s.density <=70 then 1 else 0 end ) as density70,\r\nsum(case when s.density > 70 and s.density < 100 then 1 else 0 end ) as density99,\r\nsum(case when s.density <=100 then 1 else 0 end ) as density100\r\nfrom\r\n(select * from gs_job_density where 1 =1 and start_time >=#{start_time} and end_time <=#{end_time}) s\r\ngroup by s.real_tag,s.tag_name,s.unit_id having 1 =1 and charindex(#{real_tag},real_tag)>0\r\norder by s.unit_id desc\r\nOFFSET ${start} ROW FETCH NEXT ${limit} rows only\r\n```\r\n\r\n## 批量添加/更新\r\n\r\n```sql\r\ninsert into tbl(a,b) values (1,2),(3,4),(5,6);\r\nupdate gs_job_pfr_mx SET val = \r\nCASE tag_code\r\nWHEN 'cals.GD_SH05_UUB00W0101Y' THEN '1.0'\r\nWHEN 'cals.GD_SH05_UUB00W0102Y' THEN '1.1'\r\nWHEN 'cals.GD_SH05_UUB00W0101D' THEN '1.2'\r\nWHEN 'cals.GD_SH05_UUB00W0102D' THEN '1.3'\r\nEND,\r\nTIME = GETDATE()\r\nWHERE tag_code IN('cals.GD_SH05_UUB00W0101Y', 'cals.GD_SH05_UUB00W0102Y', 'cals.GD_SH05_UUB00W0101D', 'cals.GD_SH05_UUB00W0102D')\r\n```\r\n\r\n## 分组排序\r\n\r\n```sql\r\nselect row_number() over(partition BY 分组字段 order by 排序字段) as rowNums,* from 表名\r\n\r\n-- 例：需要筛选两条数据，一条是每个区间段所有数据中最大的，另外一条是个数*10%的数值\r\nselect\r\nc.count,c.maxfhl,c.qjd,c.type,b.rownum,b.tag_name,b.fhl\r\nfrom\r\n(select count(qjd) as count,max(fhl) as maxfhl,qjd,type from gs_job_grade2 where tag_name = #{tag_name} GROUP BY qjd,type)c\r\njoin\r\n(select row_number() over(partition BY qjd,type order by fhl desc) as rownum,* from gs_job_grade2\r\nwhere tag_name = #{tag_name}) b\r\non c.qjd = b.qjd and c.type = b.type\r\nwhere b.rownum = CEILING(c.count*0.1) and c.type = #{type} and c.qjd = #{qjd}\r\norder by c.qjd,c.type\r\n\r\n-- 排序时添加序号列\r\nselect ROW_NUMBER()OVER(ORDER BY 用来排序的列的列名),XXX,XXX from XXX\r\n```\r\n\r\n\r\n## 差集、交集\r\n\r\n```sql\r\n-- 取差集\r\nselect Name from Person1\r\nexcept\r\nselect Name from Person2\r\n\r\n-- 取交集\r\nselect * from Person1\r\nInterSect\r\nselect * from Person2\r\n```\r\n\r\n\r\n## 函数\r\n\r\n```sql\r\nfloor() -- 返回小于或等于所给数字表达式的最大整数\r\nfloor(1.1)=1 floor(2)=2\r\n\r\nceiling() -- 返回大于或等于所给数字表达式的最小整数。\r\nceiling(1.1)=2 ceiling(2)=2\r\n\r\nround() -- 四舍五入\r\n\r\nsubstring()\r\nselect substring('abdcsef',1,3) abd\r\n\r\nreverse(express) -- 将字符串从尾部到头部排序\r\n\r\ncharindex(expression1,expression2[,start_location])获取某字符第一次出现的位置\r\nexpression1 必需 ---要查找的子字符串\r\nexpression2 必需 ---父字符串\r\nstart_location 可选 ---指定从父字符串开始查找的位置，默认位置从1开始\r\ncharindex(#{tag_name},table.tagname)\r\n```\r\n\r\n## SQL关联更新\r\n\r\n```sql\r\n-- SQL关联使用聚合函数更新sql存在更新不存在添加\r\n\r\nif exists (select * from dbo.users s where s.name='张三')\r\nupdate users set sex='男' where name = '张三'\r\nELSE\r\ninsert into users (name,sex) values ('张三','女')\r\n```\r\n\r\n## 转换数据类型的两种方式\r\n\r\n```sql\r\nselect * from TableName order by cast(colName as int);\r\n\r\nselect * from TableName order by convert(int,colName);\r\n```\r\n\r\n## 树形查询\r\n\r\n```sql\r\nwith cte_child(id,areaName,pid,level)\r\nas\r\n(\r\n --起始条件\r\nselect id,areaName,pid,0 as level from erp_area where id = 1 -- 优先列出第一节点查询条件或子节点查询条件\r\n\r\nunion all\r\n--递归条件\r\nselect a.id,a.areaName,a.pid,b.level+1 from erp_area a\r\ninner join cte_child b\r\non a.pid=b.id\r\n)\r\nselect * from cte_child \r\n```\r\n\r\n## 将文件中的数据插入数据库\r\n\r\n\r\n```sql\r\nBULK INSERT  [ schema_name ] . [ table_name ]\r\nFROM 'data_file'\r\n[ WITH (Arguments)]\r\n\r\n-- 例\r\nbulk insert dbo.tablename\r\nfrom 'D:\\abc.txt'\r\nWITH(\r\n    FIELDTERMINATOR = ',',\r\n    ROWTERMINATOR = '\\n',\r\n    DATAFILETYPE ='widechar',\r\n    KEEPNULLS\r\n)\r\n```\r\n**Arguments**\r\n\r\n- data_file：指定数据文件的full path，bulk insert命令将数据从该文件导入到Target Table中\r\n- ROWTERMINATOR = 'row_terminator'： 指定分隔行的字符，使用该字符来分割行（Row）\r\n- FIELDTERMINATOR = 'field_terminator'：指定分隔字段的字符，使用该字符来分割字段（Field或Column）\r\n- DATAFILETYPE = { 'char' | 'native'| 'widechar' | 'widenative' }：指定data file编码（Encoding）的类型，推荐使用widechar编码\r\n- CODEPAGE = { 'ACP' | 'OEM' | 'RAW' | 'code_page' }：如果data file中含有单字节（char或varchar）字符数据，使用CodePage参数指定字符列的CodePage\r\n- BATCHSIZE = batch_size：指定一个batch包含的数据行数量，在将数据复制到Table中时，每一个Batch作为一个单独的事务，如果一个batch复制失败，那么事务回滚。默认情况下，data file中的所有数据作为一个batch\r\n- CHECK_CONSTRAINTS：指定在执行bulk insert操作期间，必须检查插入的数据是否满足Target Table上的所有约束。如果没有指定CHECK_CONSTRAINTS选项，则所有CHECK和FOREIGN KEY约束都将被忽略，并且，在此操作之后，表上的所有约束将标记为不可信（not-trusted）\r\n- FIRE_TRIGGERS：指定是否启动Insert触发器，如果指定该选项，每个batch成功插入后，会执行Insert触发器；如果不指定该选项，不会执行Insert触发器\r\n- KEEPIDENTITY：指定将data file中的标识值插入到标识列（Identity Column）中，如果不指定KeepIdentity选项，Target Table中的ID列会自动分配唯一的标识值\r\n- KEEPNULLS：指定在执行bulk insert操作期间，空列（Empty Columns）应保留NULL值，而不是插入列的默认值\r\n- TABLOCK：指定在执行bulk insert操作期间，获取一个表级锁，持有表级锁，能够减少锁竞争(Lock Contention)，提高导入性能","categories":[{"name":"数据库","path":"api/categories/数据库.json"}],"tags":[]}