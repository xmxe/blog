{"title":"我的笔记","slug":"我的笔记","date":"2022-09-29T06:09:43.618Z","updated":"2024-03-29T00:40:22.919Z","comments":true,"path":"api/articles/我的笔记.json","excerpt":null,"covers":"https://pic1.zhimg.com/v2-2a72ccd8ac9a0c889b79d9ad021ef08e_r.jpg","content":"\r\n\r\n## 笔记\r\n\r\n### 代码块\r\n\r\n#### 静态代码块\r\n\r\n在类被加载的时候就运行了，而且只运行一次，并且优先于各种代码块以及构造函数。如果一个类中有多个静态代码块，会按照书写顺序依次执行。静态代码块不能存在任何方法体中静态代码块不能访问普通变量\r\n\r\n#### 构造代码块\r\n\r\n在创建对象时被调用，每次创建对象都会调用一次，但是优先于构造函数执行。需要注意的是，构造代码块不是优先于构造函数执行，而是依托于构造函数，也就是说，如果你不实例化对象，构造代码块是不会执行的\r\n\r\n#### 普通代码块\r\n\r\n和构造代码块的区别是，构造代码块是在类中定义的，而普通代码块是在方法体中定义的。且普通代码块的执行顺序和书写顺序一致\r\n\r\n静态代码块>构造代码块（类中定义）>构造函数>普通代码块(方法中定义)\r\n\r\n### 内部类\r\n\r\n#### 成员内部类\r\n\r\n也是最普通的内部类，它是外围类的一个成员，所以他是可以无限制的访问外围类的所有成员属性和方法，尽管是private的，但是外围类要访问内部类的成员属性和方法则需要通过内部类实例来访问。\r\n在成员内部类中要注意两点，第一：成员内部类中不能存在任何static的变量和方法；第二：成员内部类是依附于外围类的，所以只有先创建了外围类才能够创建内部类。\r\n\r\n```java\r\nOuterClass outerClass = new OuterClass();\r\nOuterClass.InnerClass innerClass = outerClass.new InnerClass();\r\ninnerClass.getOuterClass().display();\r\n```\r\n\r\n#### 局部内部类\r\n\r\n有这样一种内部类，它是嵌套在方法和作用域内的，对于这个类的使用主要是应用与解决比较复杂的问题，想创建一个类来辅助我们的解决方案，到那时又不希望这个类是公共可用的，所以就产生了局部内部类，局部内部类和成员内部类一样被编译，只是它的作用域发生了改变，它只能在该方法和属性中被使用，出了该方法和属性就会失效。\r\n\r\n#### 静态内部类\r\n\r\n使用static修饰的内部类我们称之为静态内部类，不过我们更喜欢称之为嵌套内部类。静态内部类与非静态内部类之间存在一个最大的区别，我们知道非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围内，但是静态内部类却没有。没有这个引用就意味着：\r\n1. 它的创建是不需要依赖于外围类的。\r\n2. 它不能使用任何外围类的非static成员变量和方法。\r\n3. 在静态内部类中可以存在静态成员\r\n4. 静态内部类只能访问外围类的静态成员变量和方法，不能访问外围类的非静态成员变量和方法\r\n5. 非静态内部类中不能存在静态成员，非静态内部类中可以调用外围类的任何成员,不管是静态的还是非静态的\r\n6. 静态内部类可以直接创建实例不需要依赖于外围类\r\n7. 非静态内部的创建需要依赖于外围类方位\r\n8. 非静态内部类的成员需要使用非静态内部类的实例new\r\n\r\n#### 匿名内部类\r\n\r\nnew父类构造器（参数列表）|实现接口（）{\r\n   //匿名内部类的类体部分\r\n}\r\n在这里我们看到使用匿名内部类我们必须要继承一个父类或者实现一个接口，当然也仅能只继承一个父类或者实现一个接口。同时它也是没有class关键字，这是因为匿名内部类是直接使用new来生成一个对象的引用。当然这个引用是隐式的。\r\n1. 使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能继承一个类或者实现一个接口。\r\n2. 匿名内部类中是不能定义构造函数的。\r\n3. 匿名内部类中不能存在任何的静态成员变量和静态方法。\r\n4. 匿名内部类为局部内部类，所以局部内部类的所有限制同样对匿名内部类生效。\r\n5. 匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。\r\n\r\n```java\r\nThread thread = new Thread(new Runnable() {\r\n\t@Override\r\n\tpublic void run() {\r\n\tSystem.out.println(title);\r\n\t}\r\n });\r\n```\r\n\r\n#### 使用内部类的优势\r\n\r\n封装性、实现多继承※、用匿名内部类实现回调功能、解决继承及实现接口出现同名方法的问题\r\n\r\n> [详解内部类](https://www.cnblogs.com/chenssy/p/3388487.html)\r\n> [深入理解Java：内部类](https://mp.weixin.qq.com/s/Is2Ka2R_PWZP3XZsUroLIg)\r\n> [Java内部类有坑,100%内存泄露！](https://mp.weixin.qq.com/s/u8rgIwoxnXLe8GPMrFbXpQ)\r\n\r\n### 元注解\r\n\r\n#### @Retention\r\n\r\n表示需要在什么级别保存该注释信息，用于描述注解的生命周期（即：被描述的注解在什么范围内有效）,取值（RetentionPoicy）有：\r\n\r\n1. SOURCE:在源文件中有效（即源文件保留）\r\n2. CLASS:在class文件中有效（即class保留）\r\n3. RUNTIME:在运行时有效（即运行时保留）\r\n\r\n#### @Target\r\n\r\n用于描述注解的使用范围（即：被描述的注解可以用在什么地方）,取值(ElementType)有：\r\n1. CONSTRUCTOR:用于描述构造器\r\n2. FIELD:用于描述域\r\n3. LOCAL_VARIABLE:用于描述局部变量\r\n4. METHOD:用于描述方法\r\n5. PACKAGE:用于描述包\r\n6. PARAMETER:用于描述参数\r\n7. TYPE:用于描述类、接口(包括注解类型)或enum声明\r\n8. ANNOTATION_TYPE:标明注解可以用于注解声明(应用于另一个注解上)\r\n9. TYPE_PARAMETER:表示该注解能写在类型参数的声明语句中也就是泛型上，类型参数声明如下：<T\\>，< T extends Person>\r\n10. TYPE_USE:表示注解可以在任何用到该类的地方使用\r\n\r\n#### @Inherited\r\n\r\n标记这个注解是继承于哪个注解类(默认注解并没有继承于任何子类)\r\n\r\n#### @Documented\r\n\r\n标记这些注解是否包含在用户文档中。\r\n\r\n#### @Repeatable\r\n\r\n重复注解,在java8中新增了一个方法getAnnotationsByType，用于获取可重复的注解,返回类型是数组\r\n\r\n> [你知道Java中的注解是如何工作的？](https://mp.weixin.qq.com/s/kx_111lekaIzkYYYAwjwxg)\r\n> [深入理解Java：注解](https://mp.weixin.qq.com/s?__biz=Mzg2MDYzODI5Nw==&amp;mid=2247493932&amp;idx=1&amp;sn=c8e75d1f75467f240ad749853eae4668&amp;source=41#wechat_redirect)\r\n> [JDK中注解的底层原来是这样实现的](https://mp.weixin.qq.com/s?__biz=Mzg2MDYzODI5Nw==&amp;mid=2247494076&amp;idx=2&amp;sn=ba12e71724444dfd8ce10297778682aa&amp;source=41#wechat_redirect)\r\n> [原来注解是这么实现的啊](https://mp.weixin.qq.com/s/Ggw-uPBmxZ0VDyACreMNOw)\r\n\r\n\r\n### 构建工具\r\n\r\n#### maven\r\n\r\n**常用命令**\r\n\r\n- mvn package、install、deploy区别\r\n**package**命令完成了项目编译、单元测试、打包功能，但没有把打好的可执行jar包（war包或其它形式的包）布署到本地maven仓库和远程maven私服仓库\r\n**install**命令完成了项目编译、单元测试、打包功能，同时把打好的可执行jar包（war包或其它形式的包）布署到本地maven仓库，但没有布署到远程maven私服仓库\r\n**deploy**命令完成了项目编译、单元测试、打包功能，同时把打好的可执行jar包（war包或其它形式的包）布署到本地maven仓库和远程maven私服仓库\r\n\r\n- compile(编译 打包)\r\ncompile是默认的范围；如果没有提供一个范围，那该依赖的范围就是编译范围。编译范围依赖在所有的classpath中可用，同时它们也会被打包。\r\n\r\n- provided(已提供 编译不打包)\r\nprovided意味着打包的时候可以不用包进去，别的设施(Web Container)会提供。事实上该依赖理论上可以参与编译，测试，运行等周期。相当于compile，但是在打包阶段做了exclude的动作。\r\n\r\n- runtime(运行时 不编译打包)\r\nruntime表示被依赖项目无需参与项目的编译，不过后期的测试和运行周期需要其参与。与compile相比，跳过编译而已。\r\n\r\n- test (测试)\r\ntest范围依赖在一般的编译和运行时都不需要，它们只有在测试编译和测试运行阶段可用。\r\n\r\n- system (系统)\r\nMaven不会在仓库中去寻找它。如果你将一个依赖范围设置成系统范围，你必须同时提供一个systemPath元素。注意该范围是不推荐使用的（建议尽量去从公共或定制的Maven仓库中引用依赖）\r\n\r\n- import(导入)\r\nimport仅支持在<dependencyManagement\\>中的类型依赖项上。它表示要在指定的POM<dependencyManagement\\>部分中用有效的依赖关系列表替换的依赖关系。该scope类型的依赖项实际上不会参与限制依赖项的可传递性。\r\n\r\n- <optional\\>标签\r\nprojectA依赖projectB,projectB依赖projectC时,当projectA在maven引入projectB时,如果projectB写上<optional\\>true</optional\\>时,则projectA不依赖projectC,即projectA可以自己选择是否依赖projectC,如果不写或者是false的时候,则projectA引入projectB时,也会引入projectC,默认<optional\\>的值为false,即子项目必须依赖.但是像引入parent继承情况时,像这样\r\n```xml\r\n<dependencyManagement>\r\n    <dependencies>\r\n        <dependency>\r\n            <groupId>joda-time</groupId>\r\n            <artifactId>joda-time</artifactId>\r\n            <version>2.9.9</version>\r\n            <optional>true</optional>\r\n        </dependency>\r\n    </dependencies>\r\n</dependencyManagement>\r\n```\r\noptional选项在统一控制版本的情况下会失效\r\n\r\n**Maven打包跳过测试的5种方法**\r\n\r\n(1) 命令行方式\r\n```bash\r\n# -DskipTests=true,不执行测试用例,但编译测试用例类生成相应的class文件至target/test-classes下。\r\nmvn package -DskipTests=true\r\n# -Dmaven.test.skip=true,不执行测试用例,也不编译测试用例类。\r\nmvn package -Dmaven.test.skip=true\r\n```\r\n(2) pom.xml\r\n```xml\r\n<build>\r\n    <plugins>\r\n        <!-- maven打包时跳过测试 -->\r\n        <plugin>\r\n            <groupId>org.apache.maven.plugins</groupId>\r\n            <artifactId>maven-surefire-plugin</artifactId>\r\n            <configuration>\r\n                <skip>true</skip>\r\n            </configuration>\r\n        </plugin>\r\n    </plugins>\r\n</build>\r\n```\r\n(3) IDEA图标Skip Tests。点击选中，再用LifeCycle中的打包就会跳过测试\r\n(4) 打开配置，找到Build,Exxcution,Deployment–>Build Tools–>Maven–>Runner，在VM option中添加-Dmaven.test.skip=true或者-DskipTests=true，就能在打包时跳过测试。\r\n(5) 打开配置，找到Build,Exxcution,Deployment–>Build Tools–>Maven–>Runner，在Properties中勾选Skip Test选项。\r\n\r\n> [说一个大家都知道的Spring Boot小细节](https://mp.weixin.qq.com/s/JD2wfLGXdujoc9DOJEZFpA)\r\n> [Maven(五)：resources、profiles标签的实践](https://mp.weixin.qq.com/s/Kt51X_VEeC_EQSw22pqB-A)\r\n> [Maven最全教程，看了必懂，99%的人都收藏了！](https://mp.weixin.qq.com/s/dEmCRy_9CtRPtOP4DViDHw)\r\n> [如何利用Maven将代码打包成第三方公共jar包？](https://mp.weixin.qq.com/s/vq6Id8g0IBRVM3xdPRYFbA)\r\n> [Maven中的classifier属性用过没？](https://mp.weixin.qq.com/s/ctjJBNHiflsTr5O4SffvHQ)\r\n\r\n#### Gradle\r\n\r\n- implementation，默认的scope,取代compile（已弃用）。implementation的作用域会让依赖在编译和运行时均包含在内，但是不会暴露在类库使用者的编译时。举例，如果我们的类库包含了gson，那么其他人使用我们的类库时，编译时不会出现gson的依赖。\r\n\r\n- api,和implementation类似，都是编译和运行时都可见的依赖。但是api允许我们将自己类库的依赖暴露给我们类库的使用者。\r\n\r\n- compileOnly和runtimeOnly，这两种顾名思义，一种只在编译时可见，一种只在运行时可见。而runtimeOnly和Maven的provided比较接近。runtimeOnly取代了runtime（不建议使用）\r\n\r\n- testImplementation，这种依赖在测试编译时和运行时可见，类似于Maven的test作用域。\r\n\r\n- testCompileOnly和testRuntimeOnly，这两种类似于compileOnly和runtimeOnly，但是作用于测试编译时和运行时。\r\n\r\n- compileClasspath延伸compile,compileOnly,implementation。编译类路径，在编译源代码时使用。由任务使用compileJava。runtimeClasspath延伸runtimeOnly,runtime,implementation，运行时类路径包含实现的元素以及仅运行时元素。\r\n\r\n- annotationProcessor编译期间使用的注释处理器。\r\n\r\n### String相关\r\n\r\n- String.intern()是一个Native方法，底层调用C++的StringTable::intern方法实现。当通过语句str.intern()调用intern()方法后，JVM就会在当前类的常量池中查找是否存在与str等值的String，若存在则直接返回常量池中相应Strnig的引用；若不存在，则会在常量池中创建一个等值的String，然后返回这个String在常量池中的引用,通俗的讲，是将字符串放入常量池中。是一种手动将字符串加入常量池中的方法\r\n- String.toUpperCase()会在内存中新建一个字符串并不会修改原来的字符串\r\n- String对象new出来的字符串是放在堆中，直接赋值的字符串是放在常量池中的。\r\n对字符串做拼接操作，即做“+”运算，分两种情况：\r\n①表达式右边是纯字符串常量，则存放在常量池中\r\n②表达式右边存在字符串引用，则存放在堆中\r\n```java\r\nString a = \"s\"; String b = \"b\";\r\nString c = a+b;//变量形式相加底层new String()不放常量池\r\nString d = \"s\"+\"b\";//非变量形式相加放到常量池\r\nString e = \"sb\";//放到常量池\r\nString f = new String(\"sb\");//不放常量池\r\nString g = f.intern();//手动放到常量池\r\nSystem.out.println(d==e);//true\r\nSystem.out.println(c==e);//false\r\nSystem.out.println(c==f);//false\r\nSystem.out.println(c==d);//false\r\nSystem.out.println(e==f);//false\r\nSystem.out.println(e==g);//true\r\n\r\nString s1 = new String(\"计算机\");\r\nString s2 = s1.intern();\r\nString s3 = \"计算机\";\r\nSystem.out.println(s2);//计算机\r\nSystem.out.println(s1 == s2);//false，因为一个是堆内存中的String对象一个是常量池中的String对象，\r\nSystem.out.println(s3 == s2);//true，因为两个都是常量池中的String对\r\n\r\nString str1 = \"str\";\r\nString str2 = \"ing\";\r\nString str3 = \"str\" + \"ing\";//常量池中的对象\r\nString str4 = str1 + str2; //在堆上创建的新的对象\r\nString str5 = \"string\";//常量池中的对象\r\nSystem.out.println(str3 == str4);//false\r\nSystem.out.println(str3 == str5);//true\r\nSystem.out.println(str4 == str5);//false\r\n\r\nString a = \"a\";\r\nString b = a;\r\nSystem.out.pringln(\"a == b\");true\r\n```\r\n\r\n- String字符串有长度限制，在编译期，要求字符串常量池中的常量不能超过65535，并且在javac执行过程中控制了最大值为65534。\r\n在运行期，长度不能超过Int的范围，否则会抛异常。\r\n\r\n- common-lang3包StringUtils\r\n```java\r\nisEmpty// 如果是null或者“”则返回true。\r\nisBlank// 如果是null或者“”或者空格或者制表符则返回true。isBlank判空更加准确。\r\n```\r\n\r\n> [java.lang.String的+号操作，这个谜终于要解开了！](https://mp.weixin.qq.com/s/ic5K1X6DQnBN37uv9cr-mg)\r\n> [基础面试，为什么面试官总喜欢问String？](https://mp.weixin.qq.com/s?__biz=Mzg2MDYzODI5Nw==&mid=2247493885&idx=1&sn=024118e8044ce958c0602db7aba2f916&source=41#wechat_redirect)\r\n> [深入Java源码剖析之字符串常量](https://mp.weixin.qq.com/s/YvHt9uKKOdYZDdipGJXQYA)\r\n> [浅谈Java中字符串的初始化及字符串操作类](https://mp.weixin.qq.com/s?__biz=MzkzODE3OTI0Ng==&mid=2247491285&idx=1&sn=c9373feb23075bbada302740ec1a1434&source=41#wechat_redirect)\r\n> [5个刁钻的String面试题！](https://mp.weixin.qq.com/s/xJnQq8voJvAyyyaBkrvc8A)\r\n> [为什么String是不可变的？](https://mp.weixin.qq.com/s/P-ijDf5IqtAwnFzDErQOyQ)\r\n> [90%的同学都没搞清楚的Java字符串常量池问题（图文并茂）](https://mp.weixin.qq.com/s/fwRcDog9_EU3nCEmDF_jcw)\r\n> [Java中你以为的String其实并不完全正确](https://mp.weixin.qq.com/s?__biz=Mzg2MDYzODI5Nw==&mid=2247494306&idx=1&sn=9184273c5833a9a363b4ebb85163c1a5&source=41#wechat_redirect)\r\n> [再议String-字符串常量池与String.intern()](https://mp.weixin.qq.com/s/TuGw1tDVj53hIurRfA360g)\r\n> [Java 9为何要将String的底层实现由char改成了byte?](https://mp.weixin.qq.com/s/AWVJIvOAMERmw7lU1th4iQ)\r\n> [关于Java字符串的全部，都在这份手册里了](https://mp.weixin.qq.com/s/iYO16IddRqAqn3D5VhURQQ)\r\n> [面试被问到了String相关的几道题，你能答上来吗？](https://mp.weixin.qq.com/s/wR-HmIn8nO2UICVmJeqgGw)\r\n\r\n### try、catch、finally\r\n\r\n1. try中的return语句先执行了但并没有立即返回，等到finally执行结束后再return\r\n2. finally块中的return语句会覆盖try块中的return返回\r\n3. 如果finally语句中没有return语句覆盖返回值，那么原来的返回值可能因为finally里的修改而改变也可能不变\r\n4. try块里的return语句在异常的情况下不会被执行，这样具体返回哪个看情况\r\n5. 当发生异常后，catch中的return执行情况与未发生异常时try中return的执行情况完全一样\r\n6. finally块的语句在try或catch中的return语句执行之后返回之前执行且finally里的修改语句可能影响也可能不影响try或catch中return已经确定的返回值，若finally里也有return语句则覆盖try或catch中的return语句直接返回。\r\n\r\n> [finally是在return之前还是之后执行](https://mp.weixin.qq.com/s/0fdehvtTYz8Off52YOT8Qg)\r\n> [面试官太难伺候？一个try-catch问出这么多花样](https://mp.weixin.qq.com/s/qYvMpbOXcJ77XQbK_MC8MA)\r\n\r\n### 几个经典问题\r\n\r\n#### equals和hashcode的关系\r\n\r\n1. 如果两个对象相同（即用equals比较返回true），那么它们的hashCode值一定要相同；\r\n2. 如果两个对象的hashCode相同，它们并不一定相同(即用equals比较返回false)\r\n\r\n#### 重写equals为什么需要重写hashcode\r\n\r\n比较对象先比较hashcode，hashcode相同在比较equals。如果equals为true而hashcode不同的话就会造成hashmap的key可能会重复，因为jdk判断hashmap的key是否为重复首先判断hashcode是否一致，不一致的话直接判定不是同一个对象，而equals则判定对象为一个对象违背了hashmap的设计原则，重写hashCode方法，是为了在一些算法中避免我们不想要的冲突和碰撞\r\n\r\n#### Java为什么不支持多重继承\r\n\r\n有两个类B和C继承自A；假设B和C都继承了A的方法并且进行了覆盖，编写了自己的实现；假设D通过多重继承继承了B和C，那么D应该继承B和C的重载方法，那么它应该继承的是B的还是C的？这就陷入了矛盾，所以Java不允许多重继承。\r\n\r\n#### Java8中的接口和抽象类到底还有啥区别？\r\n\r\n既然接口都能写默认方法了，那么还要抽象类干嘛呢？\r\n区别1：首先抽象类是一个“类”，而接口只是一个“接口”，两者的概念和应用场景不一样，这也是抽象类和接口的主要区别。\r\n区别2：即使在Java8中接口也能写实现方法了，但却不能写构造方法，而在抽象类是可以写构造方法的，意味着抽象类是参与类的实例化过程的，而接口则不是。抽象类不可以new\r\n区别3：抽象类可以有自己的各种成员变量，并且可以通过自己的非抽象方法进行改变，而接口中的变量默认全是public static final修饰的，意味着都是常量，并且不能被自己和外部修改。\r\n区别4：接口可以实现多继承，而抽象类只能单继承\r\n\r\n#### Comparable和Comparator区别\r\n\r\n- 一个类实现了Comparable接口，意味着该类的对象可以直接进行比较（排序），但比较（排序）的方式只有一种，很单一。一个类如果想要保持原样，又需要进行不同方式的比较（排序），就可以定制比较器（实现Comparator接口）。\r\n- Comparable接口在java.lang包下，而Comparator接口在java.util包下。\r\n- 如果对象的排序需要基于自然顺序，请选择Comparable，如果需要按照对象的不同属性进行排序，请选择Comparator\r\n\r\n#### 过滤器和拦截器的区别\r\n\r\n1. Filter需要在web.xml中配置，依赖于Servlet；Interceptor需要在SpringMVC中配置，依赖于框架；\r\n3. Filter的执行顺序在Interceptor之前\r\n3. 两者的本质区别：拦截器（Interceptor）是基于Java的反射机制，而过滤器（Filter）是基于函数回调。从灵活性上说拦截器功能更强大些，Filter能做的事情，都能做，而且可以在请求前，请求后执行，比较灵活。Filter主要是针对URL地址做一个编码的事情、过滤掉没用的参数、安全校验（比较泛的，比如登录不登录之类），太细的话，还是建议用interceptor。不过还是根据不同情况选择合适的。\r\n5. 拦截器可以访问action上下文、值栈里的对象，而过滤器不能访问。\r\n6. 在action的生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次。init(),destroy()各一次，dofilter()多次\r\n7. 拦截的请求范围不同,过滤器几乎可以对所有进入容器的请求起作用，而拦截器只会对Controller中请求或访问static目录下的资源请求起作用。\r\n8. 触发时机不同，过滤器Filter是在请求进入容器后，但在进入servlet之前进行预处理，请求结束是在servlet处理完以后。拦截器Interceptor是在请求进入servlet后，在进入Controller之前进行预处理的，Controller中渲染了对应的视图之后请求结束。\r\n\r\n> [过滤器、监听器、拦截器的区别](https://zhuanlan.zhihu.com/p/69060111?utm_source=wechat_timeline&amp;utm_medium=social&amp;utm_oi=1040923520439672832&amp;from=timeline)\r\n> [一口气说出过滤器和拦截器6个区别](https://mp.weixin.qq.com/s/PzQlCjLLM1fjPc0y4poQOw)\r\n> [SpringBoot过滤器、拦截器、监听器对比及使用场景](https://mp.weixin.qq.com/s/kZx10tnBJ8a6xtDgQsN1vQ)\r\n\r\n\r\n### 泛型\r\n\r\n- `List<? extends Object >`相当于`List<?>`\r\n在Java集合框架中，对于参数值是未知类型的容器类，只能读取其中元素，不能向其中添加元素,因为，其类型是未知，所以编译器无法识别添加元素的类型和容器的类型是否兼容，唯一的例外是NULL\r\n\r\n- `List<? extends T>`可以添加元素添加的元素为T或T的子类\r\n- `List<? super T>`可以添加元素添加的元素为T或T的父类\r\n\r\n> [为了让你理解Java泛型，费了好大心思](https://mp.weixin.qq.com/s/ilqFpf5kE0XzJnOv9SsX7Q)\r\n> [泛型中的T、E、K、V，还记得嘛？](https://mp.weixin.qq.com/s/5dWCpdyXNP5PeCZM8AQVAg)\r\n\r\n### CSRF和XSS的区别\r\n\r\n1. CSRF是跨站请求伪造;XSS是跨域脚本攻击。\r\n2. CSRF需要用户先登录网站A,获取cookie;XSS不需要登录。\r\n3. CSRF是利用网站A本身的漏洞,去请求网站A的api;XSS是向网站A注入JS代码,然后执行JS里的代码,篡改网站A的内容。（XSS利用的是站点内的信任用户，而CSRF则是通过伪装来自受信任用户的请求来利用受信任的网站。你可以这么理解CSRF攻击：攻击者盗用了你的身份，以你的名义向第三方网站发送恶意请求。）\r\n\r\n### web.xml详解\r\n\r\n**<context-param\\>** 元素含有一对参数名和参数值，用作应用的Servlet上下文初始化参数，参数名在整个Web应用中必须是惟一的，在web应用的整个生命周期中上下文初始化参数都存在，任意的Servlet和jsp都可以随时随地访问它。在JSP网页中可以使用下列方法来取得：\r\n\r\n```js\r\n${initParam.param_name}\r\n```\r\n若在Servlet可以使用下列方法来获得：\r\n```java\r\nString param_name=getServletContext().getInitParamter(\"param_name\");\r\n```\r\nServlet的ServletConfig对象拥有该Servlet的ServletContext的一个引用，所以可这样取得上下文初始化参数：\r\n```java\r\ngetServletConfig().getServletContext().getInitParameter()\r\n```\r\n也可以在Servlet中直接调用\r\n```java\r\ngetServletContext().getInitParameter()，\r\n```\r\n两者是等价的。\r\n\r\n**<listener\\>** 为web应用程序定义监听器，监听器用来监听各种事件，比如：application和session事件，所有的监听器按照相同的方式定义，功能取决去它们各自实现的接口，常用的Web事件接口有如下几个：\r\n\r\n1. ServletContextListener：用于监听Web应用的启动和关闭；\r\n2. ServletContextAttributeListener：用于监听ServletContext范围（application）内属性的改变；\r\n3. ServletRequestListener：用于监听用户的请求；\r\n4. ServletRequestAttributeListener：用于监听ServletRequest范围（request）内属性的改变；\r\n5. HttpSessionListener：用于监听用户session的开始和结束；\r\n6. HttpSessionAttributeListener：用于监听HttpSession范围（session）内属性的改变\r\n\r\n**<load-on-startup\\>1</load-on-startup/\\>**\r\nload-on-startup元素标记容器是否应该在web应用程序启动的时候就加载这个servlet，(实例化并调用其init()方法)。它的值必须是一个整数，表示servlet被加载的先后顺序。如果该元素的值为负数或者没有设置，则容器会当Servlet被请求时再加载。如果值为正整数或者0时，表示容器在应用启动时就加载并初始化这个servlet，值越小，servlet的优先级越高，就越先被加载。值相同时，容器就会自己选择顺序来加载创建Servlet实例有两个时机较小的优先加载\r\n\r\n\r\n### 解决跨域的几种方案\r\n\r\n服务器没有同源策略，浏览器的同源策略是为了保证浏览器的安全性，实际上跨域请求会将请求发送到服务器，只不过在返回数据的时候浏览器发出跨域警告\r\n\r\n1. JSONP\r\n2. CORS\r\n服务器中编写过滤器允许跨域访问\r\n```java\r\nHttpServletResponse httpResponse = (HttpServletResponse) response;\r\n//该字段必填。它的值要么是请求时Origin字段的具体值，要么是一个*，表示接受任意域名的请求\r\nhttpResponse.setHeader(\"Access-Control-Allow-Origin\", \"*\");\r\n//该字段必填。它的值是逗号分隔的一个具体的字符串(GET,POST...)或者*，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次\"预检\"请求\r\nhttpResponse.setHeader(\"Access-Control-Allow-Methods\", \"*\");\r\n//该字段可选，用来指定本次预检请求的有效期，单位为秒。在有效期间，不用发出另一条预检请求。\r\nhttpResponse.setHeader(\"Access-Control-Max-Age\", \"3600\");\r\nhttpResponse.setHeader(\"Access-Control-Allow-Headers\",\r\n\"Origin,X-Requested-With, Content-Type, Accept, Connection, User-Agent, Cookie\");\r\nhttpResponse.setHeader(\"Access-Control-Allow-Credentials\", \"true\");\r\nhttpResponse.setHeader(\"Content-type\", \"application/json\");\r\nhttpResponse.setHeader(\"Cache-Control\", \"no-cache, must-revalidate\");\r\nchain.doFilter(request,httpResponse);\r\n```\r\n3. 反向代理工具如nginx\r\n4. 服务器没有同源策略，使用HTTPClient等技术\r\n5. 控制器添加@CrossOrigin注解\r\n\r\n### 收藏文章\r\n\r\nJava\r\n\r\n- [java关键字名单](https://mp.weixin.qq.com/s?__biz=MzkzODE3OTI0Ng==&mid=2247491305&idx=2&sn=c8b3f2d88d16aa3ebb9f5b674dce0a55&source=41#wechat_redirect)\r\n- [Class.forName和ClassLoader到底有啥区别](https://mp.weixin.qq.com/s/qvKunFJfDuBesjJUIsJdXg)\r\n- [说说Java深拷贝和浅拷贝区别](https://mp.weixin.qq.com/s/GOSoJrArIQrctiP3ArG6lA)\r\n- [面试难缠的深拷贝浅拷贝，这次终于通透了](https://mp.weixin.qq.com/s/SQB4ZteKe7-fHFzL__6cSQ)\r\n- [简单聊聊对象浅拷贝和深拷贝，真不简单！](https://mp.weixin.qq.com/s/P1mlsdacKGF0vB566fqm3g)\r\n- [零拷贝技术在Java中为何这么牛](https://mp.weixin.qq.com/s/GSzbiVge-aoDHxYCzCTALw)\r\n- [什么是零拷贝？](https://mp.weixin.qq.com/s/Fsw01-dXjeS4X8I-zmu8hQ)\r\n- [天天都会写接口，但它的用途和好处有多少人能说得清楚？](https://mp.weixin.qq.com/s/R7JyIRnRYEEMNKZG-aEoMw)\r\n- [Java中的接口还可以这样用，你知道吗？](https://mp.weixin.qq.com/s/NN3Zy1RGpwWUIgaatAJ4HQ)\r\n- [10大Java面试难题，打趴无数面试者！](https://mp.weixin.qq.com/s/Fap6REHGxmnaHOPwp94iRA)※\r\n- [知名互联网公司Java开发岗面试知识点解析](https://mp.weixin.qq.com/s/efM15hYwgowrprWWNgbYjg)\r\n- [社招后端20问！](https://mp.weixin.qq.com/s/kbvWCme1T-_3_MaIvgH66g)\r\n- [Java面试题全梳理](https://mp.weixin.qq.com/s/3cqRu-STSX7aL_3kRQffTQ)\r\n- [oppo面试题](https://mp.weixin.qq.com/s/UZld1hKUgeBrYFrhQ_wjMQ)\r\n- [扪心自问！一百多道难搞的面试题，你能答对了多少](https://mp.weixin.qq.com/s/aj-WmrJsWnH2Utsbhurnbg)\r\n- [B站面试经历](https://mp.weixin.qq.com/s/ZbP8kBTKpnxKsogZyQL1nw)\r\n- [Java基础夺命连环16问](https://mp.weixin.qq.com/s/_JsVu1Vcj8kCl1gZc8tNXg)\r\n- [15个常见的Node.js面试问题及答案](https://mp.weixin.qq.com/s/-v3PCoVInPYpkhnO9y3SNQ)\r\n- [30道计网常考面试题含答案总结！血赚！](https://mp.weixin.qq.com/s/OY6oO-1dSxc9Flseal22zw)\r\n- [2W字！梳理50道经典计算机网络面试题（收藏版）](https://mp.weixin.qq.com/s/PlBwyJ4wpDeZ7J-PKw3sgA)\r\n- [蚂蚁金服一面：十道经典面试题解析](https://mp.weixin.qq.com/s/6KhtiAdDOljqQ4bzc7pSnw)\r\n- [美团面试题](https://mp.weixin.qq.com/s/2IUaDr5XRgWoVaGgPGsAxA)\r\n- [Java中经常被提到的SPI到底是什么](https://mp.weixin.qq.com/s/t92OtlMD_dwk1ldCVNvHBA)\r\n- [post为什么会发送两次请求？](https://mp.weixin.qq.com/s/rcYoIbgxHLsnXzKqmcKtSg)\r\n\r\n分布式\r\n\r\n- [Java分布式面试题集合](https://mp.weixin.qq.com/s/8L713J4zzv_PfDtfdR5CRA)\r\n- [分布式十二问！万字图文详解！](https://mp.weixin.qq.com/s/TnFsKK77uyfXkckt4m1Ctw)\r\n- [面试官：谈谈分布式一致性机制，我一脸懵逼。。](https://mp.weixin.qq.com/s/e1xvvdx8oOs8ykIMgSKiuw)\r\n- [面试绕不开的CAP理论，这篇文章帮你搞定！](https://mp.weixin.qq.com/s/tLfJdZ4BxlXY_wiV6-Hx8w)\r\n\r\n其他\r\n\r\n- [如何写出让CPU跑得更快的代码](https://mp.weixin.qq.com/s/g6bCfbyJ0NrtSAwN3Xooqw)\r\n- [程序在计算机中是如何运行起来的](https://mp.weixin.qq.com/s/Ek3gWfzrmWrRz8ypL76UTA)\r\n- [了解这些软件设计思想，你的思维至少上升一个段位](https://mp.weixin.qq.com/s/3dF8cy9LWh5A0oGWL2p35g)\r\n- [微信支付、支付宝最全接入指引，看完立刻就可以上手](https://mp.weixin.qq.com/s/emU6QyhRFXaBlkj9jerOMg)\r\n- [如何防止你的jar被反编译](https://mp.weixin.qq.com/s/AB1GN6UAsHW_nvctH_tuRQ)\r\n- [PageHelper使用中的一些坑](https://mp.weixin.qq.com/s/2FR4lmNdGmLP4qnD2F0Krw)\r\n- [一文参透分布式存储系统Ceph的架构设计、集群搭建](https://mp.weixin.qq.com/s/bt5Df-sY3QETgvGp3Kp8Yw)\r\n- [电商系统架构，常见的9个大坑](https://mp.weixin.qq.com/s/RnR3OyNA8PSz9CrCMP48kw)\r\n- [给定一个接口，要用户自定义动态实现并上传热部署](https://mp.weixin.qq.com/s/4Yr0J5MPvUQmDTseoJAILQ)\r\n- [说说布隆过滤器与布谷鸟过滤器及应用场景](https://mp.weixin.qq.com/s/q5p0v2R_FeYq2HwlrqL_xA)\r\n- [我们为什么要放弃RESTful，选择拥抱GraphQL](https://mp.weixin.qq.com/s/CsUIu48Yyqr0yiir4Xq4XA)\r\n- [轻松实现word、excel、ppt、txt等办公文件在线预览功能](https://mp.weixin.qq.com/s/m2e8dgW0NLgB9jzYd7nS2A)\r\n- [Twitter工程师从0到1教你设计百万级并发应用](https://mp.weixin.qq.com/s/RRBFnIsxp4zXd1_Wq67ivQ)\r\n\r\n下载\r\n\r\n- [apache旗下安装包](https://dlcdn.apache.org/)\r\n- [centos rpm包（cat /etc/centos-release）](http://vault.centos.org/)\r\n- [PLSQL历史版本下载](https://www.allroundautomations.com/registered-plsqldev/)\r\n- [onekey ghpst+win7 ghost](https://www.newxitong.com/)\r\n- [Chrome](https://www.google.cn/chrome/)\r\n\r\n工具\r\n\r\n- [阿里云开发者藏经阁](https://developer.aliyun.com/topic/ebook)\r\n- [Postman详细用法示例](https://mp.weixin.qq.com/s/ccRwb3SJBQl3Fhq8pDzl_A)\r\n- [简单的Postman，还能玩出花](https://mp.weixin.qq.com/s/YTacVjCl90CKcn8tIhM7bQ)\r\n- [pdf在线转换器(easypdf.com)](https://easypdf.com/cn)\r\n- [pdf工具（在线签名、转换等）](https://lightpdf.com/zh/)\r\n- [Linux端口转发](https://blog.csdn.net/Tomorrow_Yesterday/article/details/84605297)\r\n- [开源中国工具](https://tool.oschina.net/)\r\n- [QQ浏览器工具箱](https://tool.browser.qq.com/)\r\n- [amCharts3官方文档](https://www.amcharts.com/docs/v3/reference/)\r\n- [表格组件神器：bootstrap table](https://www.cnblogs.com/landeanfen/p/4993979.html)\r\n- [创建地图-百度地图生成器](http://api.map.baidu.com/lbsapi/creatmap/index.html)\r\n- [面向程序员的精品开源字体](https://mp.weixin.qq.com/s/Dz3Z1S6vIkBksPfVyq7ehQ)\r\n- [idea使用的30个小技巧](https://mp.weixin.qq.com/s/XsBqQwZBUHfwBJBLgd2NTw)\r\n\r\n\r\n排序算法\r\n\r\n> [Java实现的排序算法](https://github.com/xmxe/demo/tree/master/study-demo/src/main/java/com/xmxe/algorithm/sort)\r\n\r\n- [漫画：“排序算法”大总结](https://mp.weixin.qq.com/s/teOGQlslb6aP4AQrx7TTzA)\r\n- [因为排序不明白，被面试官锤了一顿](https://mp.weixin.qq.com/s/hQkdAMICGU2Akonl0upbag)\r\n- [史上最好的排序和数据结构入门](https://mp.weixin.qq.com/s/8iXAupQIdbRrcsFDuKwgHA)\r\n\r\n堆\r\n\r\n- [一文告诉你Java集合中「堆」的最佳打开方式](https://mp.weixin.qq.com/s/Wy-DgsZZAeZmI19ZskERRg)\r\n\r\n链表\r\n\r\n- [一口气搞懂「链表」，就靠这20+张图了](https://mp.weixin.qq.com/s/oyXrWMfOBRBClbCg1j9TyQ)\r\n\r\n栈\r\n\r\n- [面试官问我什么是「栈」，我随手画了10张图来解释](https://mp.weixin.qq.com/s/E3WDAksQV3qjS_O8ittfBA)\r\n\r\n哈希\r\n\r\n- [不能错过！简单易懂的哈希表总结](https://mp.weixin.qq.com/s/AgkHMhITtOTf9y3jrrxsfQ)\r\n- [学生物的女朋友都能看懂的哈希表总结](https://mp.weixin.qq.com/s?__biz=Mzg3Mzc0NjUzMQ==&mid=2247497071&idx=1&sn=3a67993e5e4634ddf0880e6c02a10d4e&source=41#wechat_redirect)\r\n- [如果世界上只有一种数据结构，我选择哈希！](https://mp.weixin.qq.com/s/YA5Pj6GTMFw0nrIOseMyRg)\r\n\r\n算法复杂度\r\n\r\n- [复杂度O、Θ、Ω、o、ω，别再傻傻分不清了！](https://mp.weixin.qq.com/s/HgsQUAGWG5GOs288thM8QA)\r\n- [看完这篇，还不清楚时间复杂度的，请来怼我](https://mp.weixin.qq.com/s/z_pSFJPaEdPsWtV9o-4tUQ)\r\n- [面试时候说的复杂度都是什么？](https://mp.weixin.qq.com/s/9ZFC_vlMa0bhrXhgvWx9pw)\r\n\r\n二叉树\r\n\r\n- [漫画：什么是平衡二叉树？](https://mp.weixin.qq.com/s/Tbx-VZxca8Z2U8VpXl6GoA)\r\n- [不怕面试被问了！二叉树算法大盘点](https://mp.weixin.qq.com/s/T4ObPeuFzdAbkW3R5q_vLA)\r\n- [看懂这篇文章，玩转二叉查找树](https://mp.weixin.qq.com/s?__biz=MzkzODE3OTI0Ng==&mid=2247491062&idx=1&sn=3baf32b14a438ea29273add1bbae134e&source=41#wechat_redirect)\r\n- [一文弄懂二叉树三种遍历](https://mp.weixin.qq.com/s/38j1f-UR1uakiav5sPoCIw)\r\n- [一文高效图解二叉树面试题](https://mp.weixin.qq.com/s/QEM6Arxny0HaUasGRoSxQw)\r\n- [3分钟看完关于树的故事](https://mp.weixin.qq.com/s?__biz=MzkzODE3OTI0Ng==&mid=2247491085&idx=2&sn=ad6b30d8feb980354f5131d21f3c34b8&source=41#wechat_redirect)\r\n\r\n红黑树\r\n\r\n- [漫画：什么是红黑树?](https://mp.weixin.qq.com/s/X3zYwQXxq93P_XUzFmKluQ)\r\n- [一口气写出了7k字的红黑树总结](https://mp.weixin.qq.com/s/uTkORM6bQeUT2XDHHmOc4A)\r\n- [漫画算法：5分钟搞明白红黑树到底是什么](https://mp.weixin.qq.com/s/MSB-vFGqNWB26kPydBJQmQ)\r\n- [用超强动静图详解红黑树，简单易懂](https://mp.weixin.qq.com/s/UjP3pHXWnlIf68cplj2RRw)\r\n- [红黑树是怎么实现的，看这篇真的就够了！](https://mp.weixin.qq.com/s?__biz=MzkzODE3OTI0Ng==&mid=2247491027&idx=1&sn=70566688d09508c7355cfef38b1453a5&source=41#wechat_redirect)\r\n- [什么是红黑树？看完这篇你就明白了！](https://mp.weixin.qq.com/s/9s6c1sPN7avqwxZC7BsVUQ)\r\n- [图文详解红黑树，还有谁不会](https://mp.weixin.qq.com/s/Xim1IUQmGT8hKelYZwUdLA)\r\n\r\nB树\r\n\r\n- [B-Tree和B+Tree的比较](https://mp.weixin.qq.com/s/woNW2EDgKKkYGS9B31Jxvg)\r\n\r\nTomcat\r\n\r\n- [面试官:Tomcat的生命周期是什么样子的？](https://mp.weixin.qq.com/s/b3MP9eTvfEdEKw-fL2jeTw)\r\n- [超详细的Tomcat性能监控及调优教程](https://mp.weixin.qq.com/s/3i8uRr-4EOpFizie2hmogA)\r\n- [Tomcat配置文件server.xml你有深入了解过没？](https://mp.weixin.qq.com/s?__biz=Mzg2MDYzODI5Nw==&mid=2247494066&idx=2&sn=14302c80a7c6e6480dd7553a5579ce06&source=41#wechat_redirect)\r\n- [一文拆解Tomcat高并发原理与性能调优](https://mp.weixin.qq.com/s/GR7iB5esMEczn687mwwc5Q)\r\n- [Tomcat调优和JVM参数优化](https://mp.weixin.qq.com/s/jmqqLbbOt3D--wksCigAOw)\r\n- [牛逼！硬核图解Tomcat整体架构](https://mp.weixin.qq.com/s/U49ZIWYRvIYYFkL-06aSXA)\r\n- [Tomcat深入理解](https://mp.weixin.qq.com/s?__biz=Mzg2MDYzODI5Nw==&mid=2247494316&idx=1&sn=fb6eb1b78ed195a977bdfbe92a7cc6f4&source=41#wechat_redirect)\r\n- [Tomcat请求处理流程](https://mp.weixin.qq.com/s/Miw5K0OyE4oytn4U65Hn5g)\r\n- [Tomcat有哪些组成部分？讲讲工作原理？](https://mp.weixin.qq.com/s/UilzaN7jQEza7wiwzw4bsg)\r\n- [教你用Java写一个自己的Tomcat容器，涨姿势了](https://mp.weixin.qq.com/s/RpMXgOi8WsMm19S4YOh1aw)\r\n\r\n## gist\r\n\r\n### Java相关\r\n\r\n#### fastjson转换\r\n\r\n```java\r\n// json = {\"a\":1,\"b\":2,\"c\":[\"d\":3,\"e\":4]}\r\n// json转JSONObject\r\nJSONObject a = json.getJSONObject(\"a\");\r\n// json转JSONArray\r\nJSONArray b = json.getJSONArray(\"c\");\r\n// json转对象\r\nMap<String,Object> map = JSONObject.parseObject(json.get(\"c\"),new TypeReference<Map<String,Object>>(){});\r\n// 将Java对象序列化为JSON字符串，支持各种各种Java基本类型和JavaBean,避免value为null时过滤掉字段\r\nJSONObject.toJSONString(data,SerializerFeature.WriteMapNullValue);\r\nJSON.parse() JSON.parseObject()JSON.parseArray()  json.get() ...\r\n```\r\n\r\n#### 获取路径\r\n\r\n```java\r\n// http://localhost:8080/demo/course/index.jsp\r\n// 返回：/demo\r\nrequest.getContextPath()\r\n// 返回当前页面所在目录下全名称:/course/index.jsp\r\nrequest.getServletPath()\r\n// 返回浏览器地址栏地址 http://localhost:8080/demo/course/index.jsp\r\nrequest.getRequestURL()\r\n// 返回包含工程名的当前页面全路径：/demo/course/index.jsp\r\nrequest.getRequestURI()\r\n// 返回 http://localhost:8080\r\nrequest.getScheme()+\"://\"+request.getServerName()+\":\"+ request.getServerPort()\r\n// 返回E:\\apache-tomcat-7.0.82\\webapps\\jnhouse\\\r\nrequest.getSession().getServletContext().getRealPath(File.separator)\r\n// 获取项目存放class文件的全路径 F:\\zhongzhu\\WebRoot\\WEB-INF\\classes\r\nThread.currentThread().getContextClassLoader().getResource(\"/\").getPath()\r\n//从classpath路径下获取资源并返回一个InputStream供读取文件\r\n(this)类名.class.getClassLoader().getResourceAsStream(\"name\")\r\n// 会在当前类所在的包结构下查找相应的资源\r\n类名.class.getResourceAsStream(\"name\")\r\n// 请求转发\r\nreturn “forward:forward2.html”;\r\n// 重定向\r\nreturn “redirect:redirect2.html”;\r\nrequest.getRequestDispatcher(\"url\").forward(request, response)\r\nresponse.sendRedirect(\"leader.htm\");\r\n\r\n```\r\n\r\n#### list操作\r\n\r\n```java\r\n// 交集 listA内容变为listA和listB都存在的对象 listB不变\r\nlistA.retainAll(listB)\r\n// 差集 listA中存在listB的内容去重 listB不变\r\nlistA.removeAll(listB)\r\n// 并集,为了去重，listA先取差集，然后追加全部的listB listB不变\r\nlistA.removeAll(listB) listA.addAll(listB)\r\n// 将一个list平均切割2块\r\nint sublistSize = (list.size() + 1) / 2;\r\nList<Integer> sublist1 = list.subList(0, sublistSize);\r\nList<Integer> sublist2 = list.subList(sublistSize, originalList.size());\r\n// 将切分后的两个子列表分别添加到新的ArrayList中\r\nresultList1.addAll(sublist1);\r\nresultList2.addAll(sublist2);\r\n```\r\n\r\n#### 代码分页\r\n\r\n```java\r\nInteger page = map.get(\"page\");\r\nInteger limit = map.get(\"rows\");\r\nInteger start = (page-1)*limit;\r\n//List<Map<String,Object>> subList = list.subList(start,start+limit>list.size()?list.size():start+limit)\r\nList<Map<String,Object>> subList = list.subList(start,Math.min(start+limit,list.size))\r\n```\r\n#### mybatis foreach批量添加/更新写法\r\n\r\n```xml\r\n<insert id=\"insertList\" parameterType=\"map\">\r\n begin try\r\n  insert into gs_job_pfr_mx (tag_code,val,time) values\r\n  <foreach collection=\"list\" item=\"item\" separator=\",\"  index=\"index\">\r\n   (#{item.tag},#{item.value},GETDATE())\r\n  </foreach>\r\n end try\r\n begin catch\r\n  update gs_job_pfr_mx set val =\r\n<foreach collection=\"list\" item=\"item\" separator=\" \"open=\"case tag_code\" close=\"end\">\r\n  when #{item.tag} then #{item.value}\r\n </foreach>,\r\n  time = GETDATE()\r\n  where tag_code in\r\n <foreach collection=\"list\" item=\"item\" separator=\",\" open=\"(\" close=\")\">\r\n    #{item.tag}\r\n  </foreach>\r\n end catch\r\n </insert>\r\n\r\n<!-- trim标签-->\r\n<update id=\"updateYsz\" parameterType=\"tblYsz\">\r\n    update tblysz set\r\n        <trim suffixOverrides=\",\">\r\n            <if test=\"name!=null\">name=#{name},</if>\r\n            <if test=\"jgdm!=null\">jgdm=#{jgdm},</if>\r\n            <if test=\"xz!=null\">xz=#{xz},</if>\r\n        </trim>\r\n     <where>id=#{id}</where>\r\n </update>\r\n\r\n<!-- choose标签 -->\r\n<select id=\"selectByIdOrName\" resultMap=\"BaseResultMap\" parameterType=\"com.homejim.mybatis.entity.Student\">\r\n    select\r\n    <include refid=\"Base_Column_List\" />\r\n    from student\r\n    where 1=1\r\n    <choose>\r\n      <when test=\"studentId != null\">\r\n        and student_id=#{studentId}\r\n      </when>\r\n      <when test=\"name != null and name != ''\">\r\n        and name=#{name}\r\n      </when>\r\n      <otherwise>\r\n        and 1=2\r\n      </otherwise>\r\n    </choose>\r\n  </select>\r\n\r\n<!-- resultMap-->\r\n<resultMap id=\"BaseResultMap\"type=\"com.xmxe.entity.User\">\r\n<id property=\"id\" column=\"id\" jdbcType=\"INTEGER\" javaType=\"java.lang.IntegerINTEGER\"/>\r\n<result property=\"username\" column=\"username\" jdbcType=\"VARCHAR\" javaType=\"java.lang.String\"/>\r\n<result property=\"password\" column=\"password\" jdbcType=\"VARCHAR\" javaType=\"java.lang.String\"/>\r\n</resultMap>\r\n\r\n<sql id=\"commonsSql\">\r\n\tid,username,password\r\n</sql>\r\n\r\n```\r\n\r\n> [MyBatis动态SQL](https://mp.weixin.qq.com/s/-aIum139UB_dt7OIaiccfA)\r\n> [10种超好用的MyBatis写法](https://mp.weixin.qq.com/s/G7JpSRbEAw0dDbSj3lneOw)\r\n\r\n#### mybatis连接数据库\r\n\r\n```java\r\nString mybatisConfig= \"mybatis-config.xml\";\r\nInputStream is = Resources.getResourceAsStream(mybatisConfig);\r\nSqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(is);\r\nSqlSession session = sessionFactory.openSession();\r\nsession.getMapper(Mapper.class).findByid();\r\n```\r\n\r\n#### 正则表达式\r\n\r\n匹配数字，包括小数\r\n```js\r\nvar patten = /^[+-]?(0|([1-9]\\d*))(\\.\\d+)?$/\r\n```\r\n[+-] 中括号表示其内的内容都是符合要求的匹配，所以这个表示“+”或\"-\"\r\nMatcher 类中group(0) 表示正则表达式中符合条件的字符串。\r\nMatcher 类中group(1) 表示正则表达式中符合条件的字符串中的第一个()中的字符串。\r\nMatcher 类中group(2) 表示正则表达式中符合条件的字符串中的第二个()中的字符串。\r\nMatcher 类中group(3) 表示正则表达式中符合条件的字符串中的第三个()中的字符串。\r\ngroup是针对()来说的，group(0)就是指的整个串，group(1)指的是第一个括号里的东西，group(2)指的第二个括号里的东西。\r\n```java\r\nString line = \"123ra9040 123123aj234 adf12322ad 222jsk22\";\r\nString pattern = \"(\\\\d+)([a-z]+)(\\\\d+)\";\r\n// 创建Pattern对象\r\nPattern r = Pattern.compile(pattern);\r\n// 现在创建matcher对象\r\nMatcher m = r.matcher(line);\r\n// m.find是否找到正则表达式中符合条件的字符串\r\nwhile (m.find()) {\r\n    // 拿到上面匹配到的数据\r\n    System.out.println(\"Found value: \" + m.group(0) );\r\n    System.out.println(\"Found value: \" + m.group(1) );\r\n    System.out.println(\"Found value: \" + m.group(2) );\r\n    System.out.println(\"Found value: \" + m.group(3) );\r\n}\r\n```\r\ngroup(0)对应着((//d+)([a-z]+)(//d+))所匹配的数据123ra9040或者123123aj234或者222jsk22\r\ngroup(2)输出的数据是group(0)中所匹配的数据,第二个括号的表达式,也就是([a-z]+)匹配到是数据ra或者aj或者jsk\r\ngroup(3)输出的数据是group(0)中所匹配的数据,第三个括号的表达式,也就是(//d+)匹配到是数据9040或者234或者22\r\n\r\nJS使用正则表达式\r\n```js\r\n// 可以和java正则表达式共用，如果不使用new RegExp()，则和java正则表达式书写方式有差异\r\nvar patten = new RegExp(\"...\")\r\npatten.text(要匹配的内容)\r\n```\r\n\r\n> [对正则表达式，这么多年你还在害怕吗](https://mp.weixin.qq.com/s/40UCh57rBu9LafTfjEQh1g)\r\n> [正则表达式手册](https://tool.oschina.net/uploads/apidocs/jquery/regexp.html)\r\n> [常用正则表达式最强整理（速查手册）](https://mp.weixin.qq.com/s/ABCqcJPNf1VJ7ByGrVlS_A)\r\n> [给懒人开发者的一份正则表达式指南](https://mp.weixin.qq.com/s/j5rAEyu1k4edpk5T8NuGFw)\r\n\r\n#### 冒泡排序\r\n\r\n```java\r\nint[] arr = {2,5,4,1};\r\nfor(int i=0;i<arr.length-1;i++){\r\n　　for(int j=0;j<arr.length-1-i;j++){\r\n　　　　if(arr[j]>arr[j+1]){\r\n　　　　　　int temp=arr[j];\r\n　　　　　　arr[j]=arr[j+1];\r\n　　　　　　arr[j+1]=temp;\r\n　　　　}\r\n　　}\r\n} \r\n```\r\n\r\n#### JDK8 base64转换\r\n\r\n```java\r\nString str = \"str\";\r\nString encoded = Base64.getEncoder().encodeToString(str.getBytes( StandardCharsets.UTF_8));\r\nString decoded = new String(Base64.getDecoder().decode(encoded), StandardCharsets.UTF_8);\r\n```\r\n\r\n#### poi excel\r\n\r\n```java\r\npublic void creatExcel(File file,String code,String ts){\r\n\tString[] header={\"有功功率\",\"时间\",\"pss输出信号\",\"时间\"};\r\n\tWorkbook wb = new XSSFWorkbook();\r\n\tSheet sheet = wb.createSheet(\"sheet1\");\r\n\tRow rowFirst = sheet.createRow(0);\r\n\tfor(int i = 0;i<header.length;i++){\r\n\t\tsheet.setColumnWidth(i, 5000);\r\n\t}\r\n\tfor(int i = 0;i<header.length;i++){\r\n\t\tCell cell = rowFirst.createCell(i);\r\n\t\tcell.setCellValue(header[i]);\r\n\t}\r\n\tfor(int i =0;i<maxSize;i++){\r\n\t\tRow row = sheet.createRow(i+1);\r\n\t\trow.createCell(0).setCellValue(\"\");\r\n\t\trow.createCell(1).setCellValue(\"\");\r\n\t\trow.createCell(2).setCellValue(\"\");\r\n\t\trow.createCell(3).setCellValue(\"\");\r\n\t}\r\n    try{// 指定本地文件流\r\n\t    OutputStream os = new FileOutputStream(file);\r\n        // excel写入\r\n        wb.write(os);\r\n        os.close();\r\n\t}catch(Exception e){\r\n\t\te.printStackTrace();\r\n\t}\r\n}\r\n\r\npublic void excel(HttpServletRequest request,HttpServletResponse response){\r\n\tString[] handers = {\"id\",\"书名\",\"作者\",\"价格\"};\r\n\tList<Book> list = masterMapper.querySome(null,1,5);\r\n\ttry{\r\n\t\tString filedisplay = \"test.xlsx\";\r\n\t\tfiledisplay = URLEncoder.encode(filedisplay, \"UTF-8\");\t\t\t\r\n\t\t//由浏览器指定下载路径\r\n\t\t//response.reset();\t\t\t\r\n\t\t//response.setContentType(\"application/x-download\");\r\n\t\t//response.setContentType(\"application/vnd.ms-excel;charset=utf-8\");\r\n\t\tresponse.addHeader(\"Content-Disposition\", \"attachment;filename=\"+ filedisplay);\r\n\t\trequest.setCharacterEncoding(\"UTF-8\");\r\n\t\tresponse.setContentType(\"APPLICATION/OCTET-STREAM\");\r\n\t\tresponse.setHeader(\"Content-Dispostion\",\"attachment;filename=\".concat(filedisplay));\r\n\t\t\t\r\n\t\tHSSFWorkbook wb = new HSSFWorkbook();//创建工作簿\r\n\t\tHSSFSheet sheet = wb.createSheet(\"操作\");//第一个sheet\r\n\t\tHSSFRow rowFirst = sheet.createRow(0);//第一个sheet第一行为标题\r\n\t\trowFirst.setHeight((short) 500);\r\n        HSSFCellStyle cellStyle = wb.createCellStyle();// 创建单元格样式对象\r\n        cellStyle.setAlignment(HorizontalAlignment.CENTER); // 居中\r\n        cellStyle.setVerticalAlignment(VerticalAlignment.CENTER);\r\n\t\tfor (int i = 0; i < handers.length; i++) {\r\n\t\t  sheet.setColumnWidth(i, 4000);// 设置列宽\r\n\t\t}\r\n\t\t//写标题了\r\n\t\tfor (int i = 0; i < handers.length; i++) {\r\n\t\t\t//获取第一行的每一个单元格\r\n\t\t\tHSSFCell cell = rowFirst.createCell(i);\r\n\t\t\t//往单元格里面写入值\r\n\t\t\tcell.setCellValue(handers[i]);\r\n\t\t\tcell.setCellStyle(cellStyle);\r\n\t\t}\r\n\t\tfor (int i = 0; i < list.size(); i++) {\r\n\t\t\tBook u = list.get(i);\t\t\t\r\n\t\t\t//创建数据行\r\n\t\t\tHSSFRow row = sheet.createRow(i + 1);\t\t\t\t\r\n\t\t\trow.setHeight((short) 400); // 设置每行的高度\r\n\t\t\t//设置对应单元格的值\r\n\t        row.createCell(0).setCellValue(u.getId());\r\n            row.getCell(0).setCellStyle(cellStyle);\r\n            row.createCell(1).setCellValue(u.getBookname());\r\n            row.getCell(1).setCellStyle(cellStyle);\r\n            row.createCell(2).setCellValue(u.getBookauthor());\r\n            row.getCell(2).setCellStyle(cellStyle);\r\n            row.createCell(3).setCellValue(u.getBookprice());\r\n            row.getCell(3).setCellStyle(cellStyle);\r\n\r\n\t}\r\n        OutputStream os = response.getOutputStream();\r\n        wb.write(os);\r\n        os.close();\r\n        wb.close();\r\n\t}catch(Exception e){\r\n\t\te.printStackTrace();\r\n\t}\r\n}\r\n```\r\n\r\n#### ServletRequest常用方法\r\n\r\n```java\r\nObject getAttribute(String name)\t\r\n// 以Object形式返回指定属性的值，如果不存在给定名称的属性，则返回null。\r\nEnumeration\tgetAttributeNames()\t\r\n// 返回包含此请求可用属性的名称的Enumeration。如果该请求没有可用的属性，则此方法返回一个空的Enumeration。\r\nString getCharacterEncoding()\t\r\n// 返回此请求正文中使用的字符编码的名称。如果该请求未指定字符编码，则此方法返回null\r\nvoid setCharacterEncoding(String env)\t\r\n// 重写此请求正文中使用的字符编码的名称。必须在使用getReader() 读取请求参数或读取输入之前调用此方法。否则，此方法没有任何效果。\r\nint getContentLength()\t\r\n// 返回请求正文的长度（以字节为单位），并使输入流可以使用它，如果长度未知，则返回-1。对于HTTP servlet，返回的值与CGI变量 CONTENT_LENGTH的值相同。\r\nString getContentType()\t\r\n// 返回请求正文的MIME类型，如果该类型未知，则返回null。对于HTTP servlet，返回的值与CGI变量CONTENT_TYPE的值相同。\r\nServletInputStream getInputStream()\t\r\n// 使用ServletInputStream以二进制数据形式获取请求正文。可调用此方法或getReader读取正文，而不是两种方法都调用。\r\nString getParameter(String name)\t\r\n// 以String形式返回请求参数的值，如果该参数不存在，则返回null。请求参数是与请求一起发送的额外信息。对于HTTP servlet，参数包含在查询字符串或发送的表单数据中。\r\nEnumeration\tgetParameterNames()\t\r\n// 返回包含此请求中所包含参数的名称的String对象的Enumeration。如果该请求没有参数，则此方法返回一个空的Enumeration。\r\nString[] getParameterValues(String name)\t\r\n// 返回包含给定请求参数拥有的所有值的String对象数组，如果该参数不存在，则返回null。\r\nMap<K, V> getParameterMap()\t\r\n// 返回此请求的参数的 java.util.Map。请求参数是与请求一起发送的额外信息。对于HTTP servlet，参数包含在查询字符串或发送的表单数据中。\r\nString getProtocol()\t\r\n// 以protocol/majorVersion.minorVersion的形式（例如HTTP/1.1）返回请求使用的协议的名称和版本。对于HTTP servlet，返回的值与CGI变量SERVER_PROTOCOL的值相同。\r\nString getScheme()\t\r\n// 返回用于发出此请求的方案的名称，例如http、https或ftp。不同方案具有不同的构造URL的规则，这一点已在RFC 1738中注明。\r\nString getServerName()\t\r\n// 返回请求被发送到的服务器的主机名。它是Host头值“:”（如果有）之前的那部分的值，或者解析的服务器名称或服务器IP地址。\r\nint\tgetServerPort()\t// 返回请求被发送到的端口号。它是Host头值“:”（如果有）之后的那部分的值，或者接受客户端连接的服务器端口。\r\nBufferedReader getReader()\t\r\n// 使用BufferedReader以字符数据形式获取请求正文。读取器根据正文上使用的字符编码转换字符数据。可调用此方法或getInputStream读取正文，而不是两种方法都调用。\r\nString getRemoteAddr()\t\r\n// 返回发送请求的客户端或最后一个代理的Internet Protocol (IP)地址。对于HTTP servlet，返回的值与CGI变量REMOTE_ADDR的值相同。\r\nString getRemoteHost()\t\r\n// 返回发送请求的客户端或最后一个代理的完全限定名称。如果引擎无法或没有选择解析主机名（为了提高性能），则此方法返回以点分隔的字符串形式的IP地址。对于HTTP servlet，返回的值与CGI变量REMOTE_HOST的值相同。\r\nvoid setAttribute(String name, Object o)\t\r\n// 存储此请求中的属性。在请求之间重置属性。此方法常常与RequestDispatcher一起使用。\r\nvoid removeAttribute(String name)\t\r\n// 从此请求中移除属性。此方法不是普遍需要的，因为属性只在处理请求期间保留。\r\nLocale getLocale()\t\r\n// 基于Accept-Language头，返回客户端将用来接受内容的首选Locale。如果客户端请求没有提供Accept-Language头，则此方法返回服务器的默认语言环境。\r\nEnumeration\tgetLocales()\t\r\n// 返回Locale对象的Enumeration，这些对象以首选语言环境开头，按递减顺序排列，指示基于Accept-Language头客户端可接受的语言环境。如果客户端请求没有提供Accept-Language头，则此方法返回包含一个Locale的Enumeration，即服务器的默认语言环境。\r\nboolean\tisSecure()\t\r\n// 返回一个boolean值，指示此请求是否是使用安全通道（比如HTTPS）发出的。\r\nRequestDispatcher getRequestDispatcher(String path)\t\r\n// 返回一个RequestDispatcher对象，它充当位于给定路径上的资源的包装器。可以使用RequestDispatcher对象将请求转发给资源，或者在响应中包含资源。资源可以是动态的，也可以是静态的。\r\nString getRealPath(String path)\t\r\n// 从Java Servlet API的版本2.1起，请改用ServletContext#getRealPath\r\nint getRemotePort()\t\r\n// 返回发送请求的客户端或最后一个代理的Internet Protocol (IP)源端口。\r\nString getLocalName()\t\r\n// 返回接收请求的Internet Protocol (IP)接口的主机名。\r\nString getLocalAddr()\t\r\n// 返回接收请求的接口的Internet Protocol (IP)地址。\r\nint getLocalPort()\t\r\n// 返回接收请求的接口的Internet Protocol (IP)端口号。\r\n```\r\n\r\n#### HttpServletRequest\r\n\r\n```java\r\nCookies\tgetCookies()\t\r\n// 返回包含客户端随此请求一起发送的所有Cookie对象的数组。\r\nlong getDateHeader(String name)\t\r\n// 以表示Date对象的long值的形式返回指定请求头的值。\r\nString getHeader(String name)\t\r\n// 以String的形式返回指定请求头的值。\r\nEnumeration\tgetHeaders(String name)\t\r\n// 以String对象的Enumeration的形式返回指定请求头的所有值。\r\nEnumeration\tgetHeaderNames()\t\r\n// 返回此请求包含的所有头名称的枚举。如果该请求没有头，则此方法返回一个空枚举。\r\nint getIntHeader(String name)\t\r\n// 以int的形式返回指定请求头的值。\r\nString getMethod()\t\r\n// 返回用于发出此请求的HTTP方法的名称，例如GET、POST或PUT。返回的值与CGI变量REQUEST_METHOD的值相同。\r\nString getPathInfo()\t\r\n// 返回与客户端发出此请求时发送的URL相关联的额外路径信息。额外路径信息位于servlet路径之后但在查询字符串之前，并且将以“/”字符开头。\r\nString getPathTranslated()\t\r\n// 返回在servlet名称之后但在查询字符串之前的额外路径信息，并将它转换为实际路径。返回的值与CGI变量PATH_TRANSLATED的值相同。\r\nString getContextPath()\t\r\n// 返回请求URI指示请求上下文的那一部分。请求URI中首先出现的总是上下文路径。路径以“/”字符开头但不以“/”字符结束。对于默认（根）上下文中的servlet，此方法返回“”。容器不会解码此字符串。\r\nString getQueryString()\t\r\n// 返回包含在请求URL中路径后面的查询字符串。如果URL没有查询字符串，则此方法返回null。返回的值与CGI变量QUERY_STRING的值相同。\r\nString getRequestedSessionId()\t\r\n// 返回客户端指定的会话ID。此值可能不同于此请求的当前有效会话的ID。如果客户端没有指定会话ID，则此方法返回null。\r\nString getRequestURL()\t\r\n// 重新构造客户端用于发出请求的URL。返回的URL包含一个协议、服务器名称、端口号、服务器路径，但是不包含查询字符串参数。\r\nString getServletPath()\t\r\n// 返回此请求调用servlet的URL部分。此路径以“/”字符开头，包括servlet名称或到servlet的路径，但不包括任何额外路径信息或查询字符串。返回的值与CGI变量SCRIPT_NAME的值相同。\r\nHttpSession\tgetSession(boolean create)\t\r\n// 返回与此请求关联的当前HttpSession，如果没有当前会话并且create为true，则返回一个新会话。\r\nHttpSession\tgetSession()\t\r\n// 返回与此请求关联的当前会话，如果该请求没有会话，则创建一个会话。\r\nboolean\tisRequestedSessionIdValid()\t\r\n// 检查请求的会话ID是否仍然有效。\r\nboolean\tisRequestedSessionIdFromCookie()\t\r\n// 检查请求的会话ID是否是作为cookie进入的。\r\nboolean\tisRequestedSessionIdFromURL()\t\r\n// 检查请求的会话ID是否是作为请求URL的一部分进入的。\r\n```\r\n\r\n#### 解决会话重放攻击demo\r\n\r\n```js\r\nvar random = Math.random()*1000000000000000;\r\n```\r\n```java\r\nString random = request.getParameter(\"random\");\r\nList list = (ArrayList)request.getSession().getAttribute(\"randoms\")\r\nif(list.contains(random)) {\r\n\treturn null;\r\n}\r\nlist.add(random);\r\nrequest.getSession().setAttribute(\"randoms\")\r\n```\r\n处理流程:请求带一个随机数，后台从session中取出存放这个随机数的list，判断list里面是否包含这个随机数，如果包含，证明请求被重复发送，不做处理，如果不包含，则证明是第一次请求，将随机数放进list放入session里面，之后处理业务逻辑\r\n\r\n### 前端相关\r\n\r\n#### jsp获取session数据\r\n\r\n```js\r\n<%=session.getAttribute(\"name\")%>\r\nor\r\n${sessionScope.name}\r\n```\r\n\r\n#### easyui combobox下拉框设置checkbox全选\r\n\r\n```js\r\nfunction initCombobox(id,data){\r\n\tvar value = \"\";\r\n\t//加载下拉框复选框\r\n\t$('#'+id).combobox({\r\n        data:data, //后台获取下拉框数据的url\r\n        method:'post',\r\n        panelHeight:200,//设置为固定高度，combobox出现竖直滚动条\r\n        valueField:'id',\r\n        textField:'text',\r\n        multiple:true,\r\n        editable:false,\r\n        formatter: function (row) { //formatter方法就是实现了在每个下拉选项前面增加checkbox框的方法\r\n            var opts = $(this).combobox('options');\r\n            var checkbox_id = row.check_id;\r\n            if(checkbox_id){\r\n            \treturn '<input type=\"checkbox\" class=\"combobox-checkbox\" id=\"' + checkbox_id +'\">' + row[opts.textField]\r\n            }\r\n            return '<input type=\"checkbox\" class=\"combobox-checkbox\">' + row[opts.textField]\r\n        },\r\n        onLoadSuccess: function () {//下拉框数据加载成功调用\r\n            var opts = $(this).combobox('options');\r\n            var target = this;\r\n            var values = $(target).combobox('getValues');//获取选中的值的values\r\n            $.map(values, function (value) {\r\n                var el = opts.finder.getEl(target, value);\r\n                el.find('input.combobox-checkbox')._propAttr('checked', true); \r\n            })\r\n        },\r\n        onSelect: function (row) { //选中一个选项时调用\r\n        \tvar opts = $(this).combobox('options');\r\n            //当点击所有时，则勾中所有的选项\r\n            if (row.text === \"全选\") {\r\n            \tvar data = $(\"#\"+id).combobox('getData');;\r\n            \tvar show_type = $(\"#show_type\").combobox('getValue');\r\n                for (var i = 0; i < data.length; i++) {\r\n                \t//获取选中的值的values\r\n                    $(\"#\"+id).val($(this).combobox('getValues'));\r\n                    // 选择全部和按照机组展示全选时才选中发电类型 机组类型 供热状态 否则不选择这三个\r\n                \tif(show_type != '6' && show_type != ''){\r\n                \t\tvar field = data[i][opts.valueField];\r\n                \t\tif(field == 'fdlx' || field == 'grqk' || field == 'unit_status'){\r\n                \t\t\tcontinue;\r\n                \t\t}\r\n                \t}\r\n        \t\t   //设置选中值所对应的复选框为选中状态\r\n                    var el = opts.finder.getEl(this, data[i][opts.valueField]);\r\n                    el.find('input.combobox-checkbox')._propAttr('checked', true);\r\n                }\r\n                var list = [];\r\n                $.map(opts.data, function (opt) {\t\r\n                \t// 选择全部和按照机组展示全选时才选中发电类型 机组类型 供热状态 否则不选择这三个\r\n                \tif(show_type != '6' && show_type != ''){\t\r\n                \t\tif(opt.id != 'fdlx' && opt.id != 'grqk' && opt.id != 'unit_status'){\r\n                \t\t\tlist.push(opt.id);\r\n                \t\t}\r\n                \t}else{\r\n                \t\tlist.push(opt.id);\r\n                \t}\r\n                    \r\n                });\r\n                $(\"#\"+id).combobox('setValues', list); // combobox全选\r\n            \r\n            } else {\r\n                //获取选中的值的values\r\n                $(\"#\"+id).val($(this).combobox('getValues'));\r\n    \t\t   //设置选中值所对应的复选框为选中状态\r\n                var el = opts.finder.getEl(this, row[opts.valueField]);\r\n                el.find('input.combobox-checkbox')._propAttr('checked', true);\r\n            }\r\n\r\n        },\r\n        onUnselect: function (row) {//不选中一个选项时调用\r\n            var opts = $(this).combobox('options');\r\n            if (row.text === \"全选\") {\r\n                var a = $(\"#\"+id).combobox('getData');\r\n                for (var i = 0; i < a.length; i++) {\r\n                \t $(\"#\"+id).val($(this).combobox('getValues'));\r\n                     var el = opts.finder.getEl(this, data[i][opts.valueField]);\r\n                     el.find('input.combobox-checkbox')._propAttr('checked', false);\r\n                }\r\n                $(\"#\"+id).combobox('clear');//清空选中项\r\n            } else {\r\n            \t //获取选中的值的values\r\n                $(\"#\"+id).val($(this).combobox('getValues'));\r\n                var el = opts.finder.getEl(this, row[opts.valueField]);\r\n                el.find('input.combobox-checkbox')._propAttr('checked', false);\r\n\r\n            }\r\n        }\r\n    });\r\n}\r\n```\r\n\r\n### 其他\r\n\r\n#### 二叉树遍历\r\n\r\n前序遍历A-B-D-F-G-H-I-E-C\r\n中序遍历F-D-H-G-I-B-E-A-C\r\n后序遍历F-H-I-G-D-E-B-C-A\r\n前序(根左右)，中序(左根右)，后序(左右根)\r\n\r\n![](/images/ecs.jpg)\r\n\r\n#### py import\r\n\r\n```python\r\nimport math\r\nprint math.pi\r\n# 等价于\r\nfrom math import pi\r\nprint pi\r\n```\r\n\r\n#### excel查看路径和文件名\r\n```\r\n在任一单元格输入=CELL(\"filename\")即可\r\n```\r\n\r\n#### windows杀掉进程\r\n\r\n```bash\r\ntaskkill /pid pid\r\n# /f 强制\r\n# /t 终止进程和他启用的子进程\r\ntaskkill /? # 查看相关用法\r\ntasklist # 查看所有进程\r\n```\r\n\r\n#### cron表达式\r\n\r\n3/12 第三分钟开始,每12分钟触发\r\n12,15,17 第12分钟、15分钟、17分钟触发\r\n3-19 看使用在哪个域 如果在minute域则表示在第3分钟到第19分钟每分钟触发一次 在second域则表示从第3秒到第19秒每秒触发一次\r\n24 43 2 ? 1-12 3 * 每周三2点43分24秒触发一次\r\n\r\n## 进制转换\r\n\r\n### 十进制转换二进制\r\n\r\n一直除以2最后的商+余数开始排序\r\n\r\n5/2=2余1，2/2 =1余0，所以5的二进制为101\r\n\r\n6/2=3余0，3/2=1余1，所以6的2进制是110\r\n\r\n### 二进制转换十进制\r\n\r\n1         0          1\r\n\r\n1* 2的2次方 + 0 * 2的1次方 + 1 * 2 的0次方 = 5\r\n\r\n### 运算符\r\n\r\n#### \"<<\"左移运算符\r\n\r\n**转换为二进制后左移 例:2<<3 即2的二进制左移三位**\r\n\r\n2的二进制为2/2=1余0 ， 10左移三位后补0 （00000010）（00010000）\r\n\r\nn<<3 可以转换为 n * 2 ^ 3\r\n\r\n#### \">>\"右移运算符\r\n\r\n**转换为二进制后右移 例:8>>3 即8的二进制右移三位**\r\n\r\n8的二进制为8/2=4余0 ,4/2=2余0, 2/2=1余0, 1000右移三位（删除后三位） （0000001000）（000000001）为1\r\n\r\nn>>3 可以转换为 n/2^3\r\n\r\n#### & 运算符\r\n\r\n如果相对应位都是1，则结果为1，否则为0\r\n\r\n#### | 运算符\r\n\r\n如果相对应位都是0，则结果为0，否则为1\r\n\r\n#### ^ 运算符\r\n\r\n如果相对应位值相同，则结果为0，否则为1\r\n\r\n#### 比较\r\n\r\n^: 可以不借助第三块空间的方式交换两个变量的值\r\n&: 在某些情况下可以取代%的运算\r\n\r\n某些情况：当我们拿着一个正数去%上2的n次方数的时候,其实结果等价于我们拿着这个正数&上2的n次方数-1的结果\r\n\r\nx % 2(n) == x & 2(n)-1\r\n\r\n17 % 4 == 17 & 3\r\n\r\n99 % 64 == 99 & 63\r\n\r\n### 文章\r\n\r\n- [你可能不知道的位运算技巧](https://mp.weixin.qq.com/s/INYjYfwhPU7uZcNmzBTpNQ)\r\n\r\n## 数据库相关知识点\r\n\r\n### SQL查询慢的原因\r\n\r\n1. sql没加索引\r\n2. sql索引不生效:\r\n    - 隐式的类型转换，索引失效,\r\n    - 查询条件包含or，可能导致索引失效,\r\n    - like通配符可能导致索引失效,\r\n    - 查询条件不满足联合索引的最左匹配原则,\r\n    - 在索引列上使用mysql的内置函数,\r\n    - 对索引进行列运算（如，+、-、\\*、/）,索引不生效,\r\n    - 索引字段上使用（!=或者<>），索引可能失效,\r\n    - 索引字段上使用is null,is not null，索引可能失效,\r\n    - 左右连接，关联的字段编码格式不一样,\r\n    - 优化器选错了索引\r\n3. limit深分页问题\r\n4. 单表数据量太大\r\n5. join或者子查询过多\r\n6. in元素过多\r\n7. 数据库在刷脏页\r\n8. order by文件排序\r\n9. 拿不到锁\r\n10. delete + in子查询不走索引！\r\n11. group by使用临时表\r\n12. 系统硬件或网络资源\r\n\r\n> [盘点MySQL慢查询的12个原因](https://mp.weixin.qq.com/s/qCA7hICMktxeYO7Jc0oVVg)\r\n\r\n### SQL优化\r\n\r\n1. 查询SQL尽量不要使用`select *`，而是select具体字段。\r\n    > [为啥不建议使用Select *？](https://mp.weixin.qq.com/s/2ActOr3bivQSMdyIZA5mbw)\r\n\r\n2. 如果知道查询结果只有一条或者只要最大/最小一条记录，建议用limit 1\r\n3. 应尽量避免在where子句中使用or来连接条件\r\n4. 优化limit分页\r\n5. 优化你的like语句\r\n6. 使用where条件限定要查询的数据，避免返回多余的行\r\n7. 尽量避免在索引列上使用mysql的内置函数\r\n8. 应尽量避免在where子句中对字段进行表达式操作，这将导致系统放弃使用索引而进行全表扫\r\n9. Inner join 、left join、right join，优先使用Inner join，如果是left join，左边表结果尽量小\r\n10. 应尽量避免在where子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描。\r\n11. 使用联合索引时，注意索引列的顺序，一般遵循最左匹配原则。\r\n12. 对查询进行优化，应考虑在where及order by涉及的列上建立索引，尽量避免全表扫描。\r\n13. 如果插入数据过多，考虑批量插入。\r\n14. 在适当的时候，使用覆盖索引。\r\n15. 慎用distinct关键字\r\n16. 删除冗余和重复索引\r\n17. 如果数据量较大，优化你的修改/删除语句。\r\n18. where子句中考虑使用默认值代替null。\r\n19. 不要有超过5个以上的表连接\r\n20. exist&in的合理利用\r\n21. 尽量用union all替换union\r\n22. 索引不宜太多，一般5个以内。\r\n23. 尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型\r\n24. 索引不适合建在有大量重复数据的字段上，如性别这类型数据库字段。\r\n25. 尽量避免向客户端返回过多数据量。\r\n26. 当在SQL语句中连接多个表时,请使用表的别名，并把别名前缀于每一列上，这样语义更加清晰\r\n27. 尽可能使用varchar/nvarchar代替char/nchar。\r\n28. 为了提高group by语句的效率，可以在执行到该语句前，把不需要的记录过滤掉。\r\n29. 如果字段类型是字符串，where时一定用引号括起来，否则索引失效\r\n30. 使用explain分析你SQL的计划\r\n\r\n> [SQL优化的N种方法](https://mp.weixin.qq.com/s/5zsHr2tKOOkRN6mFa65tvw)\r\n> [吐血整理！书写高质量SQL的30条建议](https://mp.weixin.qq.com/s/4ByWZVc5jVmuVcFqkkIC_A)\r\n> [MySQL数据量太大优化方案](https://mp.weixin.qq.com/s/Ky_jak-u7vCX4vXkAONN_w)\r\n> [Mysql数据库查询好慢，除了索引，还能因为什么？](https://mp.weixin.qq.com/s/qJkEgNRlUwBAe41IdtJ_hQ)\r\n> [MySQL常用优化指南，面试再也不怕了！](https://mp.weixin.qq.com/s/eoKViDLmAB3ZaPuGgsk_zQ)\r\n> [深入理解为什么MySQL全表扫描很慢？](https://mp.weixin.qq.com/s/Q9yb1Aa-PQCW1DguRzLUdg)\r\n> [专业解决MySQL查询速度慢与性能差！](https://mp.weixin.qq.com/s/Ow1vuBST7YUh5J5SYHT6dg)\r\n> [记一次神奇的SQL查询经历，group by慢查询优化](https://mp.weixin.qq.com/s/VmAD31GYPV8HcE-m2aIrnA)\r\n> [SQL子查询怎么优化？写的很深！](https://mp.weixin.qq.com/s/9RJxCqpKt0LTaSG0SHIttA)\r\n> [SQL优化极简法则，还有谁不会？](https://mp.weixin.qq.com/s/NS2trUx9nVN5gNquVVbruw)\r\n> [如何写出一手好SQL？很有必要！](https://mp.weixin.qq.com/s/Z1OOMWBqeF_QQBvhbwo-sw)\r\n> [每个后端都应该知道的八个提升SQL性能的Tips](https://mp.weixin.qq.com/s/9LIn8H78gNyYnKZrIHLbgA)\r\n> [10个经典场景带你玩转SQL优化](https://mp.weixin.qq.com/s/BgOFpBBVvvlx-Jq0ZQg3AQ)\r\n> [聊聊sql优化的15个小技巧](https://mp.weixin.qq.com/s/Cirhr8SmBzyllAI3nQTXag)\r\n> [阿里一面：SQL优化有哪些技巧？](https://mp.weixin.qq.com/s/ERpnzP4UvS-RUS2cmGmxKg)\r\n> [如何让JOIN跑得更快？](https://mp.weixin.qq.com/s/w5oy8tg8sQ3GB8hw4esVDw)\r\n> [SQL优化万能公式：5大步骤+10个案例](https://mp.weixin.qq.com/s/wjDNsGFYxfgK5oAn9kdN9Q)\r\n> [SQL优化21连击+思维导图](https://mp.weixin.qq.com/s/A8OM449_JhKPIZa4P3w08Q)\r\n\r\n\r\n### 水平拆分、垂直拆分\r\n\r\n- 水平拆分，就是把一个表的数据给弄到多个库的多个表里去，但是每个库的表结构都一样，只不过每个库表放的数据是不同的，所有库表的数据加起来就是全部数据。水平拆分的意义，就是将数据均匀放更多的库里，然后用多个库来扛更高的并发，还有就是用多个库的存储容量来进行扩容。\r\n- 垂直拆分，就是把一个有很多字段的表给拆分成多个表，或者是多个库上去。每个库表的结构都不一样，每个库表都包含部分字段。一般来说，会将较少的访问频率很高的字段放到一个表里去，然后将较多的访问频率很低的字段放到另外一个表里去。因为数据库是有缓存的，你访问频率高的行字段越少，就可以在缓存里缓存更多的行，性能就越好。这个一般在表层面做的较多一些。\r\n\r\n> [分库分表的四个面时连环炮问题](https://mp.weixin.qq.com/s/_wDGx0UfG2hXo80JvvpBAw)\r\n> [这四种情况下，才是考虑分库分表的时候！](https://mp.weixin.qq.com/s/jqry9LnCVBt64d_DdpRXJg)\r\n> [分库分表？如何做到永不迁移数据和避免热点？](https://mp.weixin.qq.com/s/fbZ8SpHh8ScV8Xt50PGb6A)\r\n> [这应该是最详尽的MySQL分库分表文章了](https://mp.weixin.qq.com/s/4eII2YyVA_snLn4kswtNcQ)\r\n> [好好的系统，为什么要分库分表？](https://mp.weixin.qq.com/s/Q6VbgQaz0NVFG-8L4GC7bQ)\r\n\r\n\r\n### 主键、外键\r\n\r\n- **主键（主码）**：主键用于唯一标识一个元组，不能有重复，不允许为空。一个表只能有一个主键。\r\n- **外键（外码）**：外键用来和其他表建立联系用，外键是另一表的主键，外键是可以有重复的，可以是空值。一个表可以有多个外键。\r\n\r\n#### 为什么不推荐使用外键与级联？\r\n\r\n对于外键和级联，阿里巴巴开发手册这样说到：\r\n\r\n> 【强制】不得使用外键与级联，一切外键概念必须在应用层解决。\r\n>\r\n> 说明:以学生和成绩的关系为例，学生表中的student_id是主键，那么成绩表中的student_id则为外键。如果更新学生表中的student_id，同时触发成绩表中的student_id更新，即为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群;级联更新是强阻塞，存在数据库更新风暴的风险;外键影响数据库的插入速度\r\n\r\n为什么不要用外键呢？大部分人可能会这样回答：\r\n\r\n1. **增加了复杂性**：a.每次做DELETE或者UPDATE都必须考虑外键约束，会导致开发的时候很痛苦,测试数据极为不方便;b.外键的主从关系是定的，假如那天需求有变化，数据库中的这个字段根本不需要和其他表有关联的话就会增加很多麻烦。\r\n2. **增加了额外工作**：数据库需要增加维护外键的工作，比如当我们做一些涉及外键字段的增，删，更新操作之后，需要触发相关操作去检查，保证数据的的一致性和正确性，这样会不得不消耗资源；（个人觉得这个不是不用外键的原因，因为即使你不使用外键，你在应用层面也还是要保证的。所以，我觉得这个影响可以忽略不计。）\r\n3. **对分库分表不友好**：因为分库分表下外键是无法生效的。\r\n4. ......\r\n\r\n我个人觉得上面这种回答不是特别的全面，只是说了外键存在的一个常见的问题。实际上，我们知道外键也是有很多好处的，比如：\r\n\r\n1. 保证了数据库数据的一致性和完整性；\r\n2. 级联操作方便，减轻了程序代码量；\r\n3. ......\r\n\r\n所以说，不要一股脑的就抛弃了外键这个概念，既然它存在就有它存在的道理，如果系统不涉及分库分表，并发量不是很高的情况还是可以考虑使用外键的。\r\n\r\n#### 关于数据库外键是否应该使用\r\n\r\n外键提供的几种在更新和删除时的不同行为都可以帮助我们保证数据库中数据的一致性和引用合法性，但是外键的使用也需要数据库承担额外的开销，在大多数服务都可以水平扩容的今天，高并发场景中使用外键确实会影响服务的吞吐量上限。在数据库之外手动实现外键的功能是可能的，但是却会带来很多维护上的成本或者需要我们在数据一致性上做出一些妥协。我们可以从可用性、一致性几个方面分析使用外键、模拟外键以及不使用外键的差异：不使用外键牺牲了数据库中数据的一致性，但是却能够减少数据库的负载；模拟外键将一部分工作移到了数据库之外，我们可能需要放弃一部分一致性以获得更高的可用性，但是为了这部分可用性，我们会付出更多的研发与维护成本，也增加了与数据库之间的网络通信次数；使用外键保证了数据库中数据的一致性，也将全部的计算任务全部交给了数据库；在大多数不需要高并发或者对一致性有较强要求的系统中，我们可以直接使用数据库提供的外键帮助我们对数据进行校验，但是在对一致性要求不高的、复杂的场景或者大规模的团队中，不使用外键也确实可以为数据库减负，而大团队也有更多的时间和精力去设计其他的方案，例如：分布式的关系型数据库。当我们考虑应不应该在数据库中使用外键时，需要关注的核心我们的数据库承担这部分计算任务后会不会影响系统的可用性，在使用时也不应该一刀切的决定用或者不用外键，应该根据具体的场景做决策，我们在这里介绍了两个使用外键时可能遇到的问题：RESTRICT外键会在更新和删除关系表中的数据时对外键约束的合法性进行检查，保证外键不会引用到不存在的记录；CASCADE外键会在更新和删除关系表中的数据时触发对关联记录的更新和删除，在数据量较大的数据库中可能会有数量级的放大效果\r\n\r\n### 数据库三大范式\r\n\r\n数据库范式有3种：\r\n\r\n- 1NF(第一范式)：属性不可再分。\r\n- 2NF(第二范式)：1NF的基础之上，消除了非主属性对于码的部分函数依赖。\r\n- 3NF(第三范式)：3NF在2NF的基础之上，消除了非主属性对于码的传递函数依赖。\r\n\r\n#### 1NF(第一范式)\r\n\r\n属性（对应于表中的字段）不能再被分割，也就是这个字段只能是一个值，不能再分为多个其他的字段了。**1NF是所有关系型数据库的最基本要求**，也就是说关系型数据库中创建的表一定满足第一范式。\r\n\r\n#### 2NF(第二范式)\r\n\r\n2NF在1NF的基础之上，消除了非主属性对于码的部分函数依赖。如下图所示，展示了第一范式到第二范式的过渡。第二范式在第一范式的基础上增加了一个列，这个列称为主键，非主属性都依赖于主键。\r\n\r\n![第二范式](https://oss.javaguide.cn/github/javaguide/csdn/bd1d31be3779342427fc9e462bf7f05c.png)\r\n\r\n一些重要的概念：\r\n\r\n- **函数依赖（functionaldependency）**：若在一张表中，在属性（或属性组）X的值确定的情况下，必定能确定属性Y的值，那么就可以说Y函数依赖于X，写作X→Y。\r\n- **部分函数依赖（partialfunctionaldependency）**：如果X→Y，并且存在X的一个真子集X0，使得X0→Y，则称Y对X部分函数依赖。比如学生基本信息表R中（学号，身份证号，姓名）当然学号属性取值是唯一的，在R关系中，（学号，身份证号）->（姓名），（学号）->（姓名），（身份证号）->（姓名）；所以姓名部分函数依赖与（学号，身份证号）；\r\n- **完全函数依赖（Fullfunctionaldependency）**：在一个关系中，若某个非主属性数据项依赖于全部关键字称之为完全函数依赖。比如学生基本信息表R（学号，班级，姓名）假设不同的班级学号有相同的，班级内学号不能相同，在R关系中，（学号，班级）->（姓名），但是（学号）->(姓名)不成立，（班级）->(姓名)不成立，所以姓名完全函数依赖与（学号，班级）；\r\n- **传递函数依赖**：在关系模式R(U)中，设X，Y，Z是U的不同的属性子集，如果X确定Y、Y确定Z，且有X不包含Y，Y不确定X，（X∪Y）∩Z=空集合，则称Z传递函数依赖(transitivefunctionaldependency)于X。传递函数依赖会导致数据冗余和异常。传递函数依赖的Y和Z子集往往同属于某一个事物，因此可将其合并放到一个表中。比如在关系R(学号,姓名,系名，系主任)中，学号→系名，系名→系主任，所以存在非主属性系主任对于学号的传递函数依赖。。\r\n\r\n#### 3NF(第三范式)\r\n\r\n3NF在2NF的基础之上，消除了非主属性对于码的传递函数依赖。符合3NF要求的数据库设计，基本上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。比如在关系R(学号,姓名,系名，系主任)中，学号→系名，系名→系主任，所以存在非主属性系主任对于学号的传递函数依赖，所以该表的设计，不符合3NF的要求。\r\n\r\n#### 总结\r\n\r\n- 1NF：数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，不能在一列中存放多个属性。例如员工信息表，不能在信息一列中放入电话，住址等信息，应该单独设计成电话、住址各一列\r\n- 2NF：每个表必须有主键(Primary key),其他数据元素与主键一一对应。通常称这种关系为函数依赖(Functional dependence)关系，即表中其他数据元素都依赖于主键,或称该数据元素惟一地被主键所标识,例如学生表（学生id，姓名，成绩，合格状态），其中合格状态这一列不依赖于学生信息，而依赖于成绩，所以不符合第二范式\r\n- 3NF:要求一个数据库表中不包含已在其它表中已包含的非主关键字信息,例如学生表（学生id，姓名，班级id，班级位置）班级表(班级id，班级名，班级位置)，学生表里已经有了班级的id，可以推断出班级位置，无需在学生表里存入班级位置信息\r\nBCNF:所有非主属性对每一个候选键都是完全函数依赖；所有的主属性对每一个不包含它的候选键，也是完全函数依赖；没有任何属性完全函数依赖于非候选键的任何一组属性\r\n\r\n注意事项：\r\n1. 第二范式与第三范式的本质区别：在于有没有分出两张表。\r\n第二范式是说一张表中包含了多种不同实体的属性，那么必须要分成多张表，第三范式是要求已经分好了多张表的话，一张表中只能有另一张标的ID，而不能有其他任何信息，（其他任何信息，一律用主键在另一张表中查询）。\r\n2. 必须先满足第一范式才能满足第二范式，必须同时满足第一第二范式才能满足第三范式。\r\n三大范式只是一般设计数据库的基本理念，可以建立冗余较小、结构合理的数据库。如果有特殊情况，当然要特殊对待，数据库设计最重要的是看需求跟性能，需求>性能>表结构。所以不能一味的去追求范式建立数据库。\r\n\r\n### 五大约束\r\n\r\n数据库中的五大约束包括：\r\n1. 主键约束（Primay Key Coustraint）唯一性，非空性；\r\n2. 唯一约束 （Unique Counstraint）唯一性，可以空，但只能有一个\r\n3. 默认约束 (Default Counstraint)该数据的默认值；\r\n4. 外键约束 (Foreign Key Counstraint)需要建立两表间的关系；\r\n5. 非空约束（Not Null Counstraint）:设置非空约束，该字段不能为空。\r\n\r\n### select for update加锁\r\n\r\n总结一下select...for update加锁的情况：\r\n\r\n主键字段：加行锁。\r\n唯一索引字段：加行锁。\r\n普通索引字段：加间隙锁。\r\n主键范围：加多个行锁。\r\n唯一索引范围，加多个行锁。\r\n普通字段：加间隙锁，看着像表锁。。\r\n查询空数据：加间隙锁。\r\n如果事务1加了行锁，一直没有释放锁，事务2操作相同行的数据时，会一直等待直到超时。\r\n如果事务1加了表锁，一直没有释放锁，事务2不管操作的是哪一行数据，都会一直等待直到超时。\r\n\r\n此外，有些小伙伴，可能会好奇，直接执行update语句，也会加行锁，为什么还需要使用for update关键字加行锁呢？\r\n答：for update关键字是加在select语句中的，它从查到那行数据开始，直到事务提交，整个过程中都会加锁。\r\n\r\n而直接执行update语句，是在更新数据的时候加锁，二者有本质的区别。\r\n\r\n### 相关文章\r\n\r\n- [数据库面试题（函数和存储过程区别）](https://mp.weixin.qq.com/s/gCT048J16KO3ucNtzvAWxA)\r\n- [吊打面试官？2020年数据库高频面试题|原力计划](https://mp.weixin.qq.com/s/zx2PY8A_L5wnVc7goMY5WQ)\r\n- [JDBC查询各种姿势（普通、流式、游标）](https://mp.weixin.qq.com/s?__biz=Mzg2MDYzODI5Nw==&mid=2247494238&idx=1&sn=e44bf7e2ba678a562246e8831d5d8dc4&source=41#wechat_redirect)\r\n- [1.2W字的SQL语法速成手册](https://mp.weixin.qq.com/s/AUXNm2LyVl4NtKGEzBaWFg)\r\n- [使用uuid作为数据库主键，被技术总监怼了一顿！](https://mp.weixin.qq.com/s/BhMjFRqlDYKQNaCKj2tnkQ)\r\n- [一直认为count(1)比count(\\*)效果高，被同事鄙视了。](https://mp.weixin.qq.com/s/zdxkbtHxdgGtgck1zjZmWw)\r\n- [我说用count(\\*)统计行数，面试官让我回去等消息..](https://mp.weixin.qq.com/s/7ipMLtkeJhCAtxKlEvOFzw)\r\n- [8种常见SQL错误用法](https://mp.weixin.qq.com/s/Siyd8kkZEsSV5g0D2qsCHg)\r\n- [常见的SQL面试题：经典50例](https://mp.weixin.qq.com/s/SZnwP5Guu4RraxBI6l6nFg)\r\n- [一文搞定关系数据库设计要领，值得收藏！](https://mp.weixin.qq.com/s/NbZnNOZTUZaavEAKD-CSYw)\r\n- [常用数据库SQL命令详解（上）](https://mp.weixin.qq.com/s/hd7-IjhRW5DyWZi9MdEG0w)\r\n- [常用数据库SQL命令详解（下）](https://mp.weixin.qq.com/s/gidYvMFQGM8VaiQkP_9IjQ)\r\n- [输入SQL到返回数据，到底发生了什么？](https://mp.weixin.qq.com/s/jhej5m8qs0isEzJC-SpLfA)\r\n- [一条SQL查询语句是如何执行的？](https://mp.weixin.qq.com/s/M9PmFMmXToJOMyzVWj0Z5g)\r\n- [数据库主键一定要自增吗？有哪些场景不建议自增？](https://mp.weixin.qq.com/s/Xu_SfM-DzKarybGpspwIHA)\r\n- [慢SQL，压垮团队的最后一根稻草](https://mp.weixin.qq.com/s/2ea_no_oonNb58OqInRn5g)\r\n- [聊聊数据库建表的15个小技巧](https://mp.weixin.qq.com/s/03lD4P0rE909Kkvm_7vLNg)\r\n- [百亿级数据分库分表后怎么分页查询？](https://mp.weixin.qq.com/s/FPdl_-jqgeIXSGOh-MQNFQ)\r\n- [加密的手机号，如何模糊查询？](https://mp.weixin.qq.com/s/PhGDmIumM0nmp8CA6nuzfQ)\r\n- [为什么SQL查询以%开头索引就失效了呢](https://mp.weixin.qq.com/s/C1tokV2zikn69KmaJtgU5Q)\r\n\r\n## 怎么保证幂等性\r\n\r\n### 幂等性的几种方案\r\n\r\n- 唯一索引，防止新增脏数据\r\n- 前端限制:页面的提交按钮只能被点击提交一次\r\n  后端解决方案：\r\n    1. 集群环境：采用token加redis（redis单线程的，处理需要排队）\r\n    2. 单JVM环境：采用token加redis或token加jvm内存\r\n    3. 处理流程：请求前先生成token，重复代表处理过.数据提交前向授权系统申请token，系统根据相关信息生成token并判断是否可以返回（根据代码逻辑将生成的token与已生成且保存的token做对比，token一致的话代表已经生成了一次，本次不允许返回），将生成的token放到redis或jvm内存，并设置token的有效时间，返回给客户端\r\n  \r\n      ![](images/mideng.jpg)\r\n       客户端携带token请求服务端，服务端查询redis，如果有的话处理请求并删除token，没有的话代表非法请求不做处理\r\n\r\n> 现在很多系统处理请求已经不做是否登陆的校验，而是根据用户名密码申请token，将token保存到cookie或者Local Storage或者form隐藏域，请求时携带token，服务端校验处理请求\r\n> [Token多平台身份认证架构设计思路](https://mp.weixin.qq.com/s/X4J56Y2dLzkBVwCC2hlmaQ)\r\n> [Token登录认证详解](https://blog.csdn.net/GreenSky_Test/article/details/116056661)\r\n\r\n- 悲观锁获取数据的时候加锁获取\r\n```sql\r\nselect * from table_xxx where id='xxx' for update;\r\n```\r\n注意：id字段一定是主键或者唯一索引\r\n悲观锁使用时一般伴随事务一起使用，数据锁定时间可能会很长，根据实际情况选用\r\n\r\n- 乐观锁:乐观锁只是在更新数据那一刻锁表，其他时间不锁表，所以相对于悲观锁，效率更高。乐观锁的实现方式多种多样可以通过version或者其他状态条件：\r\n```sql\r\n-- 通过版本号实现\r\nupdate table_xxx set name=#name#,version=version+1 where version=#version#\r\n-- 通过条件限制\r\nupdate tablexxx set avaiamount=avaiamount-#subAmount# where avaiamount-#subAmount# >= 0\r\n```\r\n\r\n- 分布式锁\r\n\r\n- 状态机幂等\r\n在设计单据相关的业务，或者是任务相关的业务，肯定会涉及到状态机(状态变更图)，就是业务单据上面有个状态，状态在不同的情况下会发生变更，一般情况下存在有限状态机,如果状态机已经处于下一个状态，这时候来了一个上一个状态的变更，理论上是不能够变更的，这样的话，保证了有限状态机的幂等。注意：订单等单据类业务，存在很长的状态流转，一定要深刻理解状态机，对业务系统设计能力提高有很大帮助\r\n\r\n- 利用唯一请求编号去重，借用Redis做这个去重——只要这个唯一请求编号在redis存在，证明处理过，那么就认为是重复的\r\n\r\n#### 幂等性相关文章\r\n\r\n- [拒绝接口裸奔！开放API接口签名验证！](https://mp.weixin.qq.com/s/eVHScVN2kcuZaokzs6-QxA)\r\n- [面试问：你的项目是如何处理重复请求/并发请求的？](https://mp.weixin.qq.com/s/BENMPLwH8WG60UVL5vXj0A)\r\n- [Spring Boot实现接口幂等性的4种方案](https://mp.weixin.qq.com/s/nza76CX-UJxspSTl52B8eQ)\r\n- [高并发下如何保证接口的幂等性？](https://mp.weixin.qq.com/s/3FJQYVoh_MDXBT0wHoKksQ)\r\n- [分布式幂等性如何保证](https://mp.weixin.qq.com/s/Hd4T8aqrx8gTmkLRyl7hcA)\r\n- [消息幂等（去重）通用解决方案，写得真好](https://mp.weixin.qq.com/s/Rax8Qb-DrYNpkbc6eTtRlg)\r\n- [面试官：给我一个避免消息重复消费的解决方案？](https://mp.weixin.qq.com/s/aKStFQXAlFF-1dOax5xg4Q)\r\n- [处理接口幂等性的两种常见方案|手把手教你](https://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247497775&amp;idx=1&amp;sn=02f389bfbdb280314e4db32660cd5bc5&amp;scene=21#wechat_redirect)\r\n- [如何防止订单重复支付？](https://mp.weixin.qq.com/s/ryhX9usir_d-O8eJuItWzA)\r\n- [保证接口数据安全的10种方案](https://mp.weixin.qq.com/s/aQwcHv36y0Du4w9HxT5FSw)\r\n- [如何防止接口重复提交？（上）](https://mp.weixin.qq.com/s/6WIlEnyYtpO50hAsO4EFNg)\r\n- [如何防止接口重复提交？（中）](https://mp.weixin.qq.com/s/RrMGoR4DgC7esfWjsX0-Lg)\r\n- [如何防止接口重复提交？（下）](https://mp.weixin.qq.com/s/Wedb1MyybIXdQEp5xvnxLw)\r\n- [并发扣款，如何保证一致性](https://mp.weixin.qq.com/s/2bhhEM8UG8AgIga0RxpW3g)\r\n- [一种非侵入式幂等性的Java实现](https://mp.weixin.qq.com/s/bktHm67TBWnNi6-xsM3-NA)\r\n- [如何防止被恶意刷接口？](https://mp.weixin.qq.com/s/3iQB9mx550lLIbfUIs4Hkg)\r\n\r\n### 微服务系统如何设计一个安全的API\r\n\r\n1. 身份认证问题\r\n一般情况下服务端均会向客户端颁发appId、partnerId等类似于标识用户身份的唯一ID，此ID关联用户密钥，一旦服务端异常或者受到工具，可以追溯来源，调整ID状态或者来强制下线用户\r\n2. 信息泄露问题\r\n信息泄露主要是要控制报文在网络传输中不要明文传输，根据对称和非对称加密算法的特点，目前主流的做法是使用混合加密，主要流程是，服务端创建RSA密钥对，将公钥传输给客户端，同时客户端创建AES密钥，使用AES密钥加密明文得到密文，接着使用公钥加密AES密钥，最后将加密后的AES密钥和密文传输到服务端。服务端使用自己的私钥解密加密后的AES密钥得到AES密钥，接着使用AES密钥解密密文得到明文\r\n3. 请求被篡改问题\r\n防止请求被篡改主要是要做好加签和验签\r\n4. 重放攻击问题\r\n黑客监听到请求后，重复请求攻击服务端，服务端如何识别是非法请求\r\n在请求参数中增加timestamp、randomString参数【此参数是从服务端实时请求的】，服务端在接收到请求后timestamp时间戳和服务端相差1分中之内的才放行，接着判断randomString是否已经存在，如果存在则不响应\r\n\r\n### 秒杀\r\n\r\n#### 步骤\r\n\r\n写脚本肯定需要知道步骤是什么，然后才能用代码去复刻下来嘛。\r\n\r\n1、下载浏览器驱动，这里我用的是chrome浏览器，先看一下自己的版本号，在设置可以看到。\r\n\r\n然后在[网站](http://chromedriver.storage.googleapis.com/index.html)找好对应的版本去下载\r\n\r\n2、接下来就是设置秒杀时间\r\n\r\n3、打开浏览器输入淘宝网址\r\n\r\n4、登录账号，进入购物车页面\r\n\r\n5、点击选择按钮\r\n\r\n6、秒杀时间到了，立刻下单！\r\n\r\n#### 操作开始\r\n\r\n导入依赖：\r\n\r\n```xml\r\n<dependency>\r\n      <groupId>org.seleniumhq.selenium</groupId>\r\n      <artifactId>selenium-java</artifactId>\r\n      <version>3.141.59</version>\r\n</dependency>\r\n```\r\n\r\n下面是完整的代码\r\n\r\n```java\r\npublic void taoBao() throws Exception {\r\n    // 浏览器驱动路径\r\n    System.setProperty(\"webdriver.chrome.driver\",\"D:\\\\JDK\\\\chromedriver.exe\");\r\n    // 设置秒杀时间\r\n    SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss SSSSSSSSS\");\r\n    Date date = sdf.parse(\"2022-04-14 14:07:00 000000000\");\r\n    // 1、打开浏览器\r\n    ChromeDriver browser = new ChromeDriver();\r\n    Actions actions = new Actions(browser);\r\n    // 2、输入网址\r\n    browser.get(\"https://www.taobao.com\");\r\n    Thread.sleep(3000);\r\n    // 3、点击登录\r\n    browser.findElement(By.linkText(\"亲，请登录\")).click();\r\n    Thread.sleep(2000);\r\n    // 4、扫码登录\r\n    browser.findElement(By.className(\"icon-qrcode\")).click();\r\n    Thread.sleep(4000);\r\n    // 5、进入购物车页面\r\n    browser.get(\"https://cart.taobao.com/cart.htm\");\r\n    Thread.sleep(3000);\r\n    // 6、点击选择第一个按钮\r\n    browser.findElement(By.xpath(\"//*[@id=\\\"J_Order_s_2207407355826_1\\\"]/div[1]/div/div/label\")).click();\r\n    Thread.sleep(2000);\r\n    while (true){\r\n        //当前时间\r\n        Date now = new Date();\r\n        System.out.println(now);\r\n        if(now.after(date)){\r\n            if(browser.findElement(By.linkText(\"结 算\")).isEnabled()){\r\n                browser.findElement(By.linkText(\"结 算\")).click();\r\n                System.out.println(\"结算成功\");\r\n                break;\r\n            }\r\n\r\n        }\r\n    }\r\n    Thread.sleep(5000);\r\n}\r\n```\r\n\r\n这里说一下会遇到的问题：\r\n\r\n1. 这里使用的是扫码登录，需要用手机淘宝扫码进行登录\r\n2. Thread.sleep(4000);就是系统休息4秒钟，如果扫码登录时间大于4秒会报错，可以根据电脑网速来设置\r\n3. browser.findElement(By.xpath(\"xxx\")).click();这个是选择购物车第一个商家的所有商品，里面xxx需要更改。当然其他参数怎么修改可以根据这个对应来修改。\r\n\r\n进入购物车页面后按F12，然后点左上角那个箭头，然后选择店铺左边的按钮，这样下面代码块就对应到了指定的代码位置\r\n\r\n![图片](https://img-blog.csdnimg.cn/b2f3301c394e498eaa8fb7bb87477317.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6L6w5YWuaW5n,size_20,color_FFFFFF,t_70,g_se,x_16)\r\n\r\n右键这一行，然后选择copy→Copy XPath，这个XPath就是browser.findElement(By.xpath(\"xxx\")).click();的xxx内容\r\n\r\n![图片](https://img-blog.csdnimg.cn/c816562669b74a729443ff134c5f0b07.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6L6w5YWuaW5n,size_20,color_FFFFFF,t_70,g_se,x_16)\r\n\r\n如果以上操作都没有问题，那么你就可以启动程序啦！！成功后你会发现，脚本居然如此简单！！\r\n\r\n- [面试官：你给我画一下秒杀系统的架构图](https://mp.weixin.qq.com/s/EYx78REElJE3ASm1PCG2aw)\r\n- [秒杀场景的九个细节，细思极恐！](https://mp.weixin.qq.com/s/Uq0zM_ceoFupYDKqqpvR4Q)\r\n- [秒杀系统设计最全攻略](https://mp.weixin.qq.com/s/2LpNQTmSFu0InYnC-Q7bJA)\r\n- [下次二面再回答不好“秒杀系统“设计原理，我就捶死自己...](https://mp.weixin.qq.com/s/YHhbonAxNntonTo-UhDV6Q)\r\n- [如何设计订单系统](https://mp.weixin.qq.com/s/AtXswrVQPGD_jfSqzKe_qQ)\r\n- [千万级高并发秒杀系统设计套路](https://mp.weixin.qq.com/s/KmPY2NOfpftFi6TpVSW23Q)\r\n\r\n\r\n### 相关文章\r\n\r\n- [生成订单30分钟未支付，则自动取消，该怎么实现?](https://mp.weixin.qq.com/s/ijv_4_qWTrG-kA9jSbz1iw)\r\n- [一口气说出6种实现延时消息的方案](https://mp.weixin.qq.com/s/VcbZTsoD5-ioc4x7s6mj7Q)\r\n- [面试官：怎么不用定时任务实现关闭订单？](https://mp.weixin.qq.com/s/Oc188nkq4-s9ivt7Ki_M1A)\r\n- [再有人问你如何实现订单到期关闭，就把这篇文章发给他](https://mp.weixin.qq.com/s/BG1PqUWX0XwJX6aMCXCgvw)\r\n- [订单超时怎么处理？阿里用这种方案](https://mp.weixin.qq.com/s/pGZj1jVHKPhUJKlKNnm5CQ)\r\n- [怎么实现订单30分钟未支付自动取消？我有5种实现方案！](https://mp.weixin.qq.com/s/xQwOdiDGfTelXJQUp0id-g)\r\n\r\n## 反射\r\n\r\n### 何为反射\r\n\r\n如果说大家研究过框架的底层原理或者咱们自己写过框架的话，一定对反射这个概念不陌生。反射之所以被称为框架的灵魂，主要是因为它赋予了我们在运行时分析类以及执行类中方法的能力。通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。\r\n\r\n### 反射的应用场景\r\n\r\n像咱们平时大部分时候都是在写业务代码，很少会接触到直接使用反射机制的场景。但是，这并不代表反射没有用。相反，正是因为反射，你才能这么轻松地使用各种框架。像Spring/SpringBoot、MyBatis等等框架中都大量使用了反射机制。这些框架中也大量使用了动态代理，而动态代理的实现也依赖反射。比如下面是通过JDK实现动态代理的示例代码，其中就使用了反射类`Method`来调用指定的方法。\r\n\r\n\r\n```java\r\npublic class DebugInvocationHandler implements InvocationHandler {\r\n    /**\r\n     * 代理类中的真实对象\r\n     */\r\n    private final Object target;\r\n\r\n    public DebugInvocationHandler(Object target) {\r\n        this.target = target;\r\n    }\r\n\r\n\r\n    public Object invoke(Object proxy, Method method, Object[] args) throws InvocationTargetException, IllegalAccessException {\r\n        System.out.println(\"before method \" + method.getName());\r\n        Object result = method.invoke(target, args);\r\n        System.out.println(\"after method \" + method.getName());\r\n        return result;\r\n    }\r\n}\r\n```\r\n\r\n另外，像Java中的一大利器注解的实现也用到了反射。为什么你使用Spring的时候，一个@Component注解就声明了一个类为Spring Bean呢？为什么你通过一个@Value注解就读取到配置文件中的值呢？究竟是怎么起作用的呢？这些都是因为你可以基于反射分析类，然后获取到类/属性/方法/方法的参数上的注解。你获取到注解之后，就可以做进一步的处理。\r\n\r\n### 反射机制的优缺点\r\n\r\n**优点**：可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利\r\n\r\n**缺点**：让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。\r\n\r\n> 相关阅读：[Java Reflection:Why is it so slow?](https://stackoverflow.com/questions/1392351/java-reflection-why-is-it-so-slow)\r\n> [原文链接](https://javaguide.cn/java/basis/reflection.html)\r\n\r\n\r\n### 相关文章\r\n\r\n- [Java反射机制你还不会？那怎么看Spring源码？](https://mp.weixin.qq.com/s/jV9kE2ajB40f3fOU_lT9ng)\r\n- [Java反射是什么？看这篇绝对会了！](https://mp.weixin.qq.com/s/QbacsQwTyvBJi12LYPNKJw)\r\n- [学会这篇反射，我就可以去吹牛逼了。](https://mp.weixin.qq.com/s/Dyg4qSqiyjSJTne8yvUYpQ)\r\n- [深入理解Java：类加载机制及反射](https://mp.weixin.qq.com/s/kTYLjg_FlKBdAAQQvSAF9g)\r\n","categories":[],"tags":[{"name":"随笔","path":"api/tags/随笔.json"}]}