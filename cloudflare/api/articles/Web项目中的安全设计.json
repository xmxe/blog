{"title":"Web项目中的安全设计","slug":"Web项目中的安全设计","date":"2025-11-27T09:23:21.800Z","updated":"2025-12-01T07:08:04.135Z","comments":true,"path":"api/articles/Web项目中的安全设计.json","excerpt":null,"covers":"https://img95.699pic.com/photo/32213/1132.jpg_wh860.jpg","content":"\r\n\r\n## 完整性校验\r\n\r\n**描述**\r\n\r\n数据传输完整性是指数据在传输过程中，不被未授权的篡改或在篡改后能够被迅速发现。\r\n\r\n**防护建议**\r\n\r\n1. 传输过程中数据做整体加密处理（该方案存在一定风险，若攻击者拥有系统访问权限，可在数据未解密的情况下直接篡改加密数据，进行提权操作，固未从根本上解决数据完整性问题，建议采用方案2）\r\n2. 数据签名校验：建立客户端和服务端全流程校验和处理机制，有效解决数据在请求和响应传输过程中被篡改的问题，提高数据双向传输完整性，用以保障信息系统安全。为保证数据的完整性，约定uid为密钥（uid的生成和传输机制详见[uid的生成和传输方案](#uid的生成和传输方案)）用于签名计算。\r\n\r\n系统应采用校验码技术或密码技术保证鉴别信息和重要业务数据等敏感信息在传输过程中的完整性。\r\n    ①等保三级要求：系统鉴别信息和重要业务数据等敏感信息在传输过程中应采用国家密码主管部门要求的加密算法（SM3等）对其进行数据完整性校验\r\n    ②等保二级要求：系统中的鉴别信息和重要业务数据等敏感信息在传输过程中应采用校验码技术或密码技术（MD5、SHA等）对其进行数据完整性校验\r\n\r\n**请求传输完整性校验实现方案**\r\n\r\n（1）客户端从localstorage中读取加固参数uid和时间差△timestamp（服务器时间与客户端时间的时间差），并计算请求发送时的服务端当前时间戳为:客户端当前时间+△timestamp。\r\n（2）客户端使用散列算法对请求数据data和关键加固参数uid，timestamp进行签名计算，以国密算法SM3举例：`clientSM3=SM3(sort(data+salt+timestamp))`,sort的含义是将参数值按照字母字典排序，然后从小到大拼接成一个字符串。\r\n（3）将签名clientSM3和时间戳以参数或自定义header的形式随请求发送给服务器。\r\n（4）服务端收到请求，判断请求中是否存在clientSM3和时间戳参数，若不存在则请求无效，并向客户端返回请求无效；若存在，则读取并继续执行。\r\n（5）服务端验证时间戳参数，服务端当前时间timestamp_now-timestamp是否大于60s或<-5s（默认一次HTTP请求从发出到到达服务器的时间是不会超过60s的，且不会小于0，考虑到计算机精度和多网关业务场景，故判断条件为>60s或<-5s）。若大于60s或<-5s，则请求无效；反之为有效请求，。\r\n（6）服务端验证clientSM3参数，服务端根据请求的会话标识读取该用户的uid参数，并记录请求中的timestamp、请求数据data，调用签名生成算法，得到`serverSM3=SM3(sort(data+uid+timestamp))`，验证serverSM3是否等于clientSM3，若不一致，则请求无效，并向客户端返回数据请求被篡改；若一致说明数据未篡改，进行下一步业务处理。\r\n\r\n![](images/请求传输完整性.png)\r\n\r\n**响应传输完整性校验实现方案**\r\n\r\n（1）服务端返回响应前根据会话标识读取该用户的uid参数，并获取当前服务端时间timestamp\r\n（2）服务端使用散列算法对响应数据data和salt值进行签名计算，以国密SM3举例：`serverSM3=SM3(sort(data+uid+timestamp))`,sort的含义是将参数值按照字母字典排序，然后从小到大拼接成一个字符串。\r\n（3）将签名serverSM3和timestamp以参数或自定义header的形式随响应发送给客户端。\r\n（4）客户端收到响应后判断响应中是否存在serverSM3和timestamp参数，若不存在则响应无效，客户端不再解析该响应；若存在，则读取并继续执行。\r\n（5）验证timestamp参数，客户端当前时间timestamp_now-timestamp是否大于60s或<-5s（默认一次HTTP响应从发出到到达客户端的时间是不会超过60s的，且不会小于0，考虑到计算机精度和多网关业务场景，故判断条件为>60s或<-5s）。若大于60s或<-5s，则响应无效；反之则继续执行。\r\n（6）验证serverSM3参数，客户端读取该用户的盐值uid，并记录响应中的timestamp、响应数据data，调用签名生成算法，得到clientSM3=SM3(sort(data+salt+timestamp))，验证clientSM3是否等于serverSM3，若不一致，则响应无效，说明响应数据被篡改；若一致说明数据未篡改，响应正常，则客户端对响应解析并进行下一步处理。\r\n\r\n![](images/响应传输完整性.png)\r\n\r\n**简明扼要**\r\n\r\n1、传输过程中数据加密处理\r\n2、数据签名校验：为保证数据的完整性，约定uid为密钥（仅一次会话周期有效，且仅客户端和服务端知道，在传输中不可见）用于签名计算，客户端发送请求时，将请求内容与uid结合计算出签名；服务端接收到请求后，也按相同算法计算出签名。如果相等，则请求来自可信任客户端，且请求是完整的。\r\n    ①客户端使用哈希算法对请求中数据和salt值进行签名计算（本方案中uid取为salt值）sign_client=md5(sort(data+uid)),sort的含义是将参数值按照字母字典排序，然后从小到大拼接成一个字符串。\r\n    ②将签名sign_client以参数的形式发送给服务器\r\n    ③服务器收到数据之后，根据用户会话读取uid，对数据使用相同的哈希算法进行签名计算sign_server=md5(sort(data+uid))\r\n    ④验证sign_client和sign_server是否一致，若一致则说明数据没有经过篡改，执行响应操作，若不一致，则签名校验异常，数据经过篡改视为无效请求。\r\n\r\n![](images/完整性校验流程.png)\r\n\r\n**代码实现**\r\n\r\n```java\r\n// Spring拦截器实现\r\nimport java.net.URLDecoder;\r\nimport java.util.Arrays;\r\nimport java.util.Enumeration;\r\nimport java.util.Map;\r\nimport java.util.Objects;\r\n\r\nimport javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpServletResponse;\r\n\r\nimport org.bouncycastle.crypto.digests.SM3Digest;\r\nimport org.bouncycastle.util.encoders.Hex;\r\nimport org.springframework.util.Assert;\r\nimport org.springframework.web.method.HandlerMethod;\r\nimport org.springframework.web.servlet.handler.HandlerInterceptorAdapter;\r\n\r\nimport cn.hutool.core.net.URLEncodeUtil;\r\n\r\n/**\r\n * 数据完整性校验\r\n */\r\npublic class IntegralityCheckInterceptor extends HandlerInterceptorAdapter {// implements HandlerInterceptor\r\n\r\n\tpublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\r\n\t\t\r\n\t\tif (handler instanceof HandlerMethod) {\r\n//            HandlerMethod handlerMethod = (HandlerMethod) handler;\r\n\t\t       String [] white ={\"downLoadFromFTP\"};\r\n\t\t        String path =request.getServletPath();\r\n\t\t        for (int i = 0; i < white.length; i++) {\r\n\t\t            if(path.indexOf(white[i])!=-1){\r\n\t\t            \treturn true;\r\n\t\t            }\r\n\t\t        }\r\n        \t//客户端时间+△timestamp，即发送请求时的服务端的当前时间\r\n\t\t\ttry {\r\n                Long timestamp = Long.valueOf(request.getHeader(\"timestamp\"));\r\n                // 客户端使用散列算法对请求数据data和关键加固参数uid，timestamp进行签名计算\r\n                String clientSM3 = request.getHeader(\"clientSM3\");\r\n                if(Objects.nonNull(timestamp) && Objects.nonNull(clientSM3)){\r\n                    // 失效时间\r\n                    int seconds = 60;\r\n                    // 服务器当前时间\r\n                    long currentTime = System.currentTimeMillis();\r\n                    long timeDiff = currentTime - timestamp;\r\n                    // 默认一次HTTP请求从发出到到达服务器的时间是不会超过60s的，且不会小于0，考虑到计算机精度和多网关业务场景，故判断条件为>60s或<-5s\r\n                    if(timeDiff > seconds * 1000 || timeDiff < -5 * 1000){\r\n                        return false;\r\n                    }\r\n\r\n                    // 验证clientSM3参数\r\n                    // 服务端根据请求的会话标识读取该用户的uid参数\r\n                    String uid = (String) request.getSession().getAttribute(\"uid\");\r\n                    Assert.notNull(uid);\r\n\r\n                    // 请求数据data\r\n                    String data = \"\";\r\n                    Map<String,String[]> paramMap = request.getParameterMap();\r\n                    if(paramMap!=null && !paramMap.isEmpty()){\r\n                        StringBuilder sb = new StringBuilder();\r\n                        for(Map.Entry<String, String[]> entry : paramMap.entrySet()){\r\n                            String key = entry.getKey();\r\n                            String[] value = entry.getValue();\r\n                            for(String paramValue : value){\r\n                                sb.append(key);\r\n                                sb.append(\"=\");\r\n                                String param = paramValue.replaceAll(\" \",\"\");\r\n                                String deparam;\r\n                                try {\r\n                                    deparam = URLDecoder.decode(param,\"UTF-8\");\r\n                                }catch (Exception e){\r\n                                    return true;\r\n                                }\r\n                                // String deparam = URLDecoder.decode(param,\"UTF-8\");\r\n                                sb.append(deparam);\r\n                                sb.append(\"&\");\r\n                            }          \t\t\t\r\n                        }\r\n                        String strParam = sb.substring(0, sb.length()-1).toString();\r\n                        data = URLEncodeUtil.encodeAll(strParam);\r\n                    }\t\r\n                    // 调用签名算法serverSM3=SM3(sort(data+uid+timestamp))\r\n                    char[] c = (data+uid+timestamp).toCharArray();\r\n                    Arrays.sort(c);\r\n                    String sort = String.valueOf(c);\r\n                    String serverSM3 = generateSM3HASH(sort);\r\n                    if(serverSM3.equalsIgnoreCase(clientSM3)){\r\n                        return true;\r\n                    }\r\n                }\r\n\t\t\t}catch (Exception e){\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\tStringBuffer url = request.getRequestURL();\r\n\t\t\treturn false;\r\n        } else {\t\r\n            return super.preHandle(request, response, handler);\r\n        }\r\n\t}\r\n\t\r\n\t//摘要计算\r\n    public static String generateSM3HASH(String src) {\r\n        byte[] md = new byte[32];\r\n        byte[] msg1 = src.getBytes();\r\n        //System.out.println(Util.byteToHex(msg1));\r\n        SM3Digest sm3 = new SM3Digest();\r\n        sm3.update(msg1, 0, msg1.length);\r\n        sm3.doFinal(md, 0);\r\n        String s = new String(Hex.encode(md));\r\n        return s.toUpperCase();\r\n    }\r\n}\r\n\r\n```\r\n\r\n```js\r\n// jQuery ajaxhook.min.js插件实现\r\n// 接口拦截-数据完整性校验-防重放策略\r\n(function () {\r\n    // 字母字典排序\r\n    const dictSort = (str) => {\r\n        const strArr = String(str).split('');\r\n        return strArr.sort().join('');\r\n    };\r\n    const randomStr = (len = 36) => {\r\n        let randStr = function () {\r\n            var array = new Uint32Array(1);\r\n            window.crypto.getRandomValues(array);\r\n            return  array[0].toString();\r\n        };\r\n        let str = randStr();\r\n        do {\r\n            str += randStr();\r\n        } while (str.length < len)\r\n        return str.substr(0, len);\r\n    };\r\n    ah.proxy({\r\n        // 请求发起前进入\r\n        onRequest: (config, handler) => {\r\n            if (config.url===\"update.do\"){\r\n                handler.next(config);\r\n            }else if (config.url===\"add.do\"){\r\n                handler.next(config);\r\n            }else {\r\n                let body = config.body || '';\r\n                // 兼容formdata上传文件\r\n                if (body?.constructor.name === 'FormData') {\r\n                    const formDataStr = {};\r\n                    body.forEach((val, key) => formDataStr[key] = val);\r\n                    delete formDataStr.file;\r\n                    body = Object.keys(formDataStr).map(it => `${it}=${formDataStr[it]}`).join('&');\r\n                }\r\n                const url = config.url;\r\n                let getUrl = url.includes('?') ? url.split('?')[1] : '';\r\n                let data = ''\r\n                if(body){\r\n                    if(getUrl){\r\n                        body = body + \"&\" + getUrl;\r\n                    }\r\n                }else{\r\n                    body += getUrl\r\n                }\r\n                if(body === '{}') body = ''\r\n                let decodeURI = decodeURIComponent(body).replace(/\\+/g,\"\")\r\n                data = encodeURIComponent(decodeURI)\r\n                const uid = localStorage.getItem('uid');\r\n                // 获取时间差值\r\n                const timestamp = localStorage.getItem('timestamp') || 0;\r\n                // serverTime = now - 差值\r\n                const serverTimestamp = new Date().getTime() - Number(timestamp);\r\n                // 参数按字母字典sort排序\r\n                const clientVal = dictSort(data + uid + serverTimestamp);\r\n                // sm3加密\r\n                const clientSM3 = sm3(clientVal);\r\n                config.headers.clientSM3 = clientSM3;\r\n                config.headers.timestamp = serverTimestamp;\r\n                // 防重放策略参数\r\n                const nonce_client = randomStr();\r\n                const sign_client = sm3(serverTimestamp + nonce_client + uid);\r\n                config.headers.nonce_client = nonce_client;\r\n                config.headers.sign_client = sign_client;\r\n                handler.next(config);\r\n            }\r\n\r\n        },\r\n        onError: (err, handler) => {\r\n            handler.next(err);\r\n        },\r\n        onResponse: (response, handler) => {\r\n            handler.next(response);\r\n        }\r\n    })\r\n})();\r\n\r\n```\r\n## 防重放\r\n\r\n**描述**\r\n\r\n重放攻击（ReplayAttacks），是指攻击者发送一个目的主机已接收过的包，来达到欺骗系统的目的。\r\n\r\n主机A要给服务器B发送数据请求，重放攻击可由发起者A或攻击者C发起。\r\n※若由发起者A发起，A会恶意重复发送数据请求；\r\n※若由攻击者C发起，攻击者可利用网络监听或者其他方式盗取用户数据请求，再重发该请求给服务器。\r\n\r\n**防护建议**\r\n\r\n1. 验证码机制\r\n设置验证码，一次有效，每次请求更新新的验证码。适用于登录过程。优点：简单易实现。缺点：影响用户使用。\r\n2. 随机数机制（挑战与应答的机制）\r\n客户端请求服务器时，服务器生成一个随机数返回给客户端，客户端带上这个随机数访问服务器，服务器比对客户端的这个参数，若相同，说明正确，不是重放攻击。\r\n方案漏洞：\r\n将获取随机数的请求和正常数据请求放到请求集合中，并设置全局变量。将响应返回的随机数赋值给全局变量，然后再将全局变量的值赋值给数据请求从而可保证每个请求均带入有效的随机数，重放该请求集合，从而达到重放攻击的目的。\r\n\r\n![](images/随机数防重放.png)\r\n\r\n3. 时间戳+nonce+签名验证（推荐使用方案）\r\n客户端发送请求时带上当前时间戳，并生成随机nonce，同时签名（签名是为了防止会话被劫持，时间戳和nonce参数被篡改)，服务端对请求时间戳、nonce及签名进行验证，一致则认为是有效请求，否则视为无效请求。\r\n\r\n参数说明\r\n\r\n|   参数    |  类型   |                             说明                             |\r\n| :-------: | :-----: | :----------------------------------------------------------: |\r\n|   sign    | String  | 请求加密签名，sign的计算结合了请求中的timestamp、nonce、uid以及**加密的消息体**（加入消息体计算sign，可保证请求数据完整性校验）。 |\r\n| timestamp | Integer | 时间戳，首次访问系统从服务端获取，与nonce结合使用，用于防止请求重放攻击。 |\r\n|   nonce   | String  |     随机数，与timestamp结合使用，用于防止请求重放攻击。      |\r\n|    uid    |  Sting  | 用于计算签名和加密数据的key，与用户会话相关且生命周期与之一致，由服务端生成，经加密传输到客户端。 |\r\n\r\n**详细解决方案**\r\n\r\n1. 用户访问系统，向服务端请求当前系统时间\r\n2. 客户端接收服务端返回的当前系统时间timestamp_server，并计算出与当前客户端时间的差值△timestamp，将其存入浏览器localstorage中。（加固相关信息存储到localstorage中而不是sessionstorage中，是为了防止客户端浏览器跨页面操作时获取不到相关参数）后续时间戳参数均带入客户端时间+△timestamp，即发送请求时的服务端的当前时间\r\n3. 客户端生成仅一次有效的随机字符串nonce_client（防止60s内的攻击）\r\n4. 客户端读取uid（uid由服务端生成，并与用户会话相关，后续完整性校验以及敏感信息传输中均使用到该uid，uid的生成和传输过程详见[uid的生成和传输方案](#uid的生成和传输方案)）\r\n5. 客户端调用签名算法，`sign_client=hash(timestamp+nonce_client+uid)`，sign_client、timestamp、nonce_client三个参数（一般放到自定义header中）随请求发送到服务端（做签名计算是为了防止nonce和timestamp被篡改，uid字段不随请求发送防止中间人劫持）\r\n6. 服务端收到请求后，读取参数值timestamp、nonce_client、sign_client,并对这三个参数做非空判断，若不为空则进行步骤7\r\n7. 验证timestamp参数，服务端当前时间timestamp_now-timestamp是否大于60s或<-5s（默认一次HTTP请求从发出到到达服务器的时间是不会超过60s的，且不会小于0，考虑到计算机精度和多网关业务场景，故判断条件为>60s或<-5s）。若大于60s或<-5s，则请求无效；反之为有效请求，则进行步骤8\r\n8. 验证nonce_client参数，nonce_client在服务端缓存中是否存在，如果存在则请求无效，视为重放攻击；若不存在则进行步骤9，并将nonce_client记录在服务端缓存中，失效时间一般设置为60s\r\n9. 验证sign_client参数，服务端根据请求的会话标识读取该用户的uid参数，并记录前端传回的timestamp、nonce_client参数，调用签名生成算法，得到`sign_server=hash（timestamp+nonce_client+uid）`，验证sign_server是否等于sign_client，若一致，说明参数未被篡改，请求有效，进行请求业务处理流程；若不一致，说明参数被篡改，将请求丢弃。\r\n\r\n防重放机制图示\r\n![](images/防重放机制图.png)\r\n\r\n**代码实现**\r\n\r\n```java\r\n// Spring拦截器实现\r\nimport java.util.Enumeration;\r\nimport java.util.Objects;\r\nimport java.util.concurrent.TimeUnit;\r\n\r\nimport com.google.common.cache.*;\r\n\r\nimport javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpServletResponse;\r\n\r\nimport org.bouncycastle.crypto.digests.SM3Digest;\r\nimport org.bouncycastle.util.encoders.Hex;\r\nimport org.springframework.web.method.HandlerMethod;\r\nimport org.springframework.web.servlet.handler.HandlerInterceptorAdapter;\r\n\r\n/**\r\n * 重放攻击漏洞\r\n */\r\npublic class ReplayAttackInterceptor extends HandlerInterceptorAdapter {\r\n\tpublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\r\n\t\tif (handler instanceof HandlerMethod) {\t  \r\n//            HandlerMethod handlerMethod = (HandlerMethod) handler;\r\n\t\t\t// 白名单\r\n\t\t\tString [] white ={\"/update\",\"/add\"};\r\n\t\t\tEnumeration<String> names = request.getParameterNames();\r\n\t\t\tString path =request.getServletPath();\r\n\t\t\tfor (int i = 0; i < white.length; i++) {\r\n\t\t\t\tif(path.indexOf(white[i])!=-1){\r\n\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n            if(!\"GET\".equalsIgnoreCase(request.getMethod())){\r\n            \t//客户端时间+△timestamp，即发送请求时的服务端的当前时间\r\n    \t\t\tLong timestamp = Long.valueOf(request.getHeader(\"timestamp\"));\r\n    \t\t\t// 客户端生成的仅一次有效的随机字符串\r\n    \t\t\tString nonce_client = request.getHeader(\"nonce_client\");\r\n    \t\t\t// 客户端签名算法\r\n    \t\t\tString sign_client = request.getHeader(\"sign_client\");\r\n    \t\t\t\r\n    \t\t\tif(Objects.nonNull(timestamp) && Objects.nonNull(nonce_client) && Objects.nonNull(sign_client)){\r\n    \t\t\t\t// 失效时间\r\n                \tint seconds = 60;\r\n                \t// 服务器当前时间\r\n                \tlong currentTime = System.currentTimeMillis();\r\n                \tlong timeDiff = currentTime - timestamp;\r\n                \t// 默认一次HTTP请求从发出到到达服务器的时间是不会超过60s的，且不会小于0，考虑到计算机精度和多网关业务场景，故判断条件为>60s或<-5s\r\n                \tif(timeDiff > seconds*1000 || timeDiff < -5*1000){\r\n                \t\treturn false;\r\n                \t}\r\n                \t// 验证nonce_client参数\r\n                \tif(Objects.nonNull(GuavaCache.get(nonce_client))){\r\n                \t\treturn false;\r\n                \t}\r\n                \tGuavaCache.put(nonce_client, nonce_client);\r\n                \t// 验证sign_client参数\r\n                \t// 服务端根据请求的会话标识读取该用户的uid参数\r\n                \tString uid = (String)request.getSession().getAttribute(\"uid\");\r\n                \t// 调用签名算法sign_server=hash（timestamp+nonce_client+uid）\r\n                \tString sign_server = generateSM3HASH(timestamp+nonce_client+uid);\r\n                \t\r\n                \tif(sign_server.equalsIgnoreCase(sign_client)) {\r\n                \t\treturn true;\r\n                \t}\r\n    \t\t\t}\r\n    \t\t\t// StringBuffer url = request.getRequestURL();\r\n    \t\t\treturn false;   \r\n            }\r\n        \treturn true;\r\n            \r\n        } else {\r\n            return super.preHandle(request, response, handler);\r\n        }\r\n\t}\r\n\t//摘要计算\r\n    public static String generateSM3HASH(String src) {\r\n        byte[] md = new byte[32];\r\n        byte[] msg1 = src.getBytes();\r\n        //System.out.println(Util.byteToHex(msg1));\r\n        SM3Digest sm3 = new SM3Digest();\r\n        sm3.update(msg1, 0, msg1.length);\r\n        sm3.doFinal(md, 0);\r\n        String s = new String(Hex.encode(md));\r\n        return s.toUpperCase();\r\n    }\r\n    static class GuavaCache {\r\n        // 缓存项最大数量\r\n        private static final long GUAVA_CACHE_SIZE = 100000;\r\n        // 缓存时间(秒)\r\n        private static final long GUAVA_CACHE_SECONDS = 60;\r\n        // 缓存操作对象\r\n        private static LoadingCache<String, Object> GLOBAL_CACHE = null;\r\n        \r\n        static {\r\n            GLOBAL_CACHE = loadCache(new CacheLoader<String, Object>() {\r\n                @Override\r\n                public String load(String key) {\r\n                    // get键 值不存在时，加载新值到该键中\r\n                    return null;\r\n                }\r\n            });\r\n        }\r\n        \r\n        private static LoadingCache<String, Object> loadCache(CaceLoader<String, Object> cacheLoader) {\r\n            LoadingCache<String, Object> cache = CacheBuilder.newBuilder()\r\n                .maxmumSize(GUAVA_CACHE_SIZE)\r\n                .expireAfterAccess(GUAVA_CACHE_SECONDS, TimeUnit.SECONDS)\r\n                .expireAfterWrite(GUAVA_CACHE_SECONDS, TimeUnit.SECONDS)\r\n                // 移除缓存\r\n                .removalListener(new RemovalListener<String, Object>() {\r\n                    @Override\r\n                    public void onRemoval(RemovalNotification<String, Object> arg0) {\r\n                        // 相关逻辑\r\n                    }\r\n                }).recordStats().build(cacheLoader);\r\n            \r\n            return cache;\r\n        }\r\n        \r\n        /**\r\n         * 添加缓存\r\n         */\r\n        public static void put(String key, Object value) {\r\n            GLOBAL_CACHE.put(key,value);\r\n        } \r\n        \r\n        /**\r\n         * 当get键值不存在时，加载CacheLoader load()方法 加载新值到改键中 当return null 时会抛异常\r\n         */\r\n        public static Object get(String key) {\r\n            try{\r\n                return GLOBAL_CACHE.get(key);\r\n            }catch(Exception e){\r\n                return null;\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## uid的生成和传输方案\r\n\r\n**uid的使用场景**\r\n\r\nuid作为重放攻击解决方案中计算签名的盐值、也是完整性校验中计算签名的盐值，同时也是用作对称加密的密钥（敏感数据加密传输），因此uid的生成和访问机制尤为重要。\r\n本方案综合考虑了uid的传输安全、防止中间人劫持，可保证每个用户每个会话周期内的uid均不同，且无法伪造。\r\n1. 用户首次访问系统后，请求服务端公钥（非对称加密算法生成的公私钥）\r\n2. 服务端生成与用户会话相关的公私钥对（会话周期内有效），将公钥publickey_server发送给客户端（为防止攻击者分析并收集加固信息，服务端公钥随其他响应信息一起传回客户端，不单独发送）\r\n3. 客户端接收响应后将publickey_server存储到localstorage中（加固相关信息存储到localstorage中而不是sessionstorage中，是为了防止客户端浏览器跨页面操作时获取不到相关参数）\r\n4. 客户端生成公私钥对，用服务端公钥对客户端公钥进行加密`encryptpublickey_client=SM2.encrypt(publickey_client，publickey_server)`，并将加密后的客户端公钥发送到服务端\r\n5. 服务端接收请求后使用服务端私钥对其解密，获取明文客户端公钥`publickey_client=SM2.decrypt(encryptpublickey_client，privatekey_server)`\r\n6. 服务端生成与用户会话相关的随机数uid（会话周期有效），并使用客户端公钥对uid进行加密后发送到客户端，`encryptuid=SM2.encrypt(uid，publickey_client)`\r\n7. 客户端接收响应数据后，用客户端私钥对其进行解密得到明文uid，`uid=SM2.decrypt(encryptuid，privatekey_client)`，并将uid本地localstorage中保存待后续使用。\r\n\r\n注意：若系统使用SSL机制，则服务端生成uid后可直接返回给客户端，无需进行手动加解密过程。\r\n\r\n详见下图所示\r\n![](images/uid的生成和传输方案.png)\r\n\r\n简明扼要前后端登录国密加解密:\r\n1. 服务端根据用户会话生成密钥对\r\n2. 客户端获取服务端公钥，保存至localStorage\r\n3. 客户端生成密钥对，通过服务端公钥加密客户端公钥然后发送到服务端。\r\n4. 服务端通过服务端私钥解密获取客户端公钥\r\n5. 服务端生成uid(数据完整性校验、防重返时使用)，通过客户端公钥加密uid返回给客户端\r\n6. 客户端通过客户端私钥解密uid，进行放重放、完整性校验使用。\r\n\r\n**代码实现**\r\n\r\n```java\r\n// 适配sm-crypto的SM2Util.java\r\nimport org.bouncycastle.crypto.engines.SM2Engine;\r\nimport org.bouncycastle.crypto.params.ECPrivateKeyParameters;\r\nimport org.bouncycastle.crypto.params.ECPublicKeyParameters;\r\nimport org.bouncycastle.crypto.params.ParametersWithRandom;\r\nimport org.bouncycastle.jce.provider.BouncyCastleProvider;\r\nimport org.bouncycastle.crypto.util.PrivateKeyFactory;\r\nimport org.bouncycastle.crypto.util.PublicKeyFactory;\r\nimport org.bouncycastle.util.encoders.Hex;\r\n\r\nimport java.nio.charset.StandardCharsets;\r\nimport java.security.*;\r\nimport java.security.spec.PKCS8EncodedKeySpec;\r\nimport java.security.spec.X509EncodedKeySpec;\r\nimport java.util.Arrays;\r\nimport java.util.Base64;\r\n\r\npublic class SM2Util {\r\n\r\n    static {\r\n        Security.addProvider(new BouncyCastleProvider());\r\n    }\r\n\r\n    /**\r\n     * 获取密钥对\r\n     */\r\n    public static KeyPair generateSM2KeyPair() throws Exception {\r\n        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(\"EC\", \"BC\");\r\n        keyGen.initialize(new java.security.spec.ECGenParameterSpec(\"sm2p256v1\"));\r\n        return keyGen.generateKeyPair();\r\n    }\r\n    /**\r\n     * 获取未压缩公钥Hex（供前端使用）\r\n     * 当需要将公钥发送给前端使用时调用此方法\r\n     */\r\n    public static String getUncompressedPubKeyHex(PublicKey pubKey) {\r\n        java.security.interfaces.ECPublicKey ecPub = (java.security.interfaces.ECPublicKey) pubKey;\r\n        java.security.spec.ECPoint w = ecPub.getW();\r\n        return \"04\"\r\n                + paddedHex(w.getAffineX().toByteArray())\r\n                + paddedHex(w.getAffineY().toByteArray());\r\n    }\r\n\r\n    private static String paddedHex(byte[] bytes) {\r\n        String s = new java.math.BigInteger(1, bytes).toString(16);\r\n        while (s.length() < 64) s = \"0\" + s;\r\n        return s;\r\n    }\r\n\r\n    /**\r\n     * 获取私钥的PKCS#8 DER编码（Base64）—— 可直接硬编码复用\r\n     */\r\n    public static String getPrivateKeyPkcs8Base64(PrivateKey privateKey) {\r\n        return Base64.getEncoder().encodeToString(privateKey.getEncoded());\r\n    }\r\n\r\n    /**\r\n     * 从前端公钥Hex字符串加载公钥\r\n     * 获取前端公钥加密数据调用此方法\r\n     */\r\n    public static PublicKey loadPublicKeyFromHex(String publicKeyHex) throws Exception {\r\n        byte[] publicKeyBytes = Hex.decode(publicKeyHex);\r\n        \r\n        // 如果是04开头的未压缩格式，直接使用\r\n        if (publicKeyBytes[0] == 0x04) {\r\n            // 使用X509编码格式\r\n            String x509Base64 = getX509PublicKeyBase64(publicKeyBytes);\r\n            return loadPublicKeyFromBase64(x509Base64);\r\n        }\r\n        \r\n        throw new IllegalArgumentException(\"不支持的公钥格式\");\r\n    }\r\n\r\n    /**\r\n     * 将未压缩公钥转换为X509格式\r\n     */\r\n    private static String getX509PublicKeyBase64(byte[] uncompressedPublicKey) throws Exception {\r\n        // 这里需要将未压缩公钥转换为X509格式\r\n        // 简化处理：直接使用BouncyCastle的KeyFactory\r\n        KeyFactory keyFactory = KeyFactory.getInstance(\"EC\", \"BC\");\r\n        java.security.spec.ECPoint point = new java.security.spec.ECPoint(\r\n            new java.math.BigInteger(1, Arrays.copyOfRange(uncompressedPublicKey, 1, 33)),\r\n            new java.math.BigInteger(1, Arrays.copyOfRange(uncompressedPublicKey, 33, 65))\r\n        );\r\n        java.security.spec.ECParameterSpec ecSpec = new java.security.spec.ECParameterSpec(\r\n            new java.security.spec.EllipticCurve(\r\n                new java.security.spec.ECFieldFp(new java.math.BigInteger(\"FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF\", 16)),\r\n                new java.math.BigInteger(\"FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFC\", 16),\r\n                new java.math.BigInteger(\"28E9FA9E9D9F5E344D5A9E4BCF6509A7F39789F515AB8F92DDBCBD414D940E93\", 16)\r\n            ),\r\n            new java.security.spec.ECPoint(\r\n                new java.math.BigInteger(\"32C4AE2C1F1981195F9904466A39C9948FE30BBFF2660BE1715A4589334C74C7\", 16),\r\n                new java.math.BigInteger(\"BC3736A2F4F6779C59BDCEE36B692153D0A9877CC62A474002DF32E52139F0A0\", 16)\r\n            ),\r\n            new java.math.BigInteger(\"FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFF7203DF6B21C6052B53BBF40939D54123\", 16),\r\n            1\r\n        );\r\n        java.security.spec.ECPublicKeySpec pubKeySpec = new java.security.spec.ECPublicKeySpec(point, ecSpec);\r\n        return Base64.getEncoder().encodeToString(keyFactory.generatePublic(pubKeySpec).getEncoded());\r\n    }\r\n\r\n    /**\r\n     * 从Base64加载公钥\r\n     */\r\n    public static PublicKey loadPublicKeyFromBase64(String x509Base64) throws Exception {\r\n        byte[] x509 = Base64.getDecoder().decode(x509Base64);\r\n        X509EncodedKeySpec spec = new X509EncodedKeySpec(x509);\r\n        KeyFactory keyFactory = KeyFactory.getInstance(\"EC\", \"BC\");\r\n        return keyFactory.generatePublic(spec);\r\n    }\r\n\r\n    /**\r\n     * 使用前端公钥加密（返回C1C3C2格式Hex字符串，与前端sm-crypto兼容）\r\n     */\r\n    public static String encryptForFrontend(String plainText, PublicKey publicKey) throws Exception {\r\n        // 创建公钥参数\r\n        ECPublicKeyParameters pubKeyParam = (ECPublicKeyParameters)\r\n                PublicKeyFactory.createKey(publicKey.getEncoded());\r\n\r\n        // 加密必须使用ParametersWithRandom\r\n        SecureRandom random = new SecureRandom();\r\n        ParametersWithRandom params = new ParametersWithRandom(pubKeyParam,random);\r\n\r\n        // 使用C1C2C3模式加密\r\n        SM2Engine engine = new SM2Engine(SM2Engine.Mode.C1C2C3);\r\n        engine.init(true, params);\r\n\r\n        byte[] plainBytes = plainText.getBytes(StandardCharsets.UTF_8);\r\n        byte[] cipherBytes = engine.processBlock(plainBytes, 0, plainBytes.length);\r\n\r\n        // 转换为C1C3C2格式（前端期望的格式）\r\n        byte[] c1c3c2 = convertC1C2C3ToC1C3C2(cipherBytes);\r\n        return Hex.toHexString(c1c3c2);\r\n    }\r\n\r\n    /**\r\n     * 使用服务端私钥解密前端发来的使用服务端公钥加密的数据\r\n     */\r\n    public static String decryptFromFrontend(String encryptedHex, PrivateKey privateKey) throws Exception {\r\n        byte[] cipherBytes = Hex.decode(encryptedHex);\r\n        // 根据第一个字节判断格式\r\n        int firstByte = cipherBytes[0] & 0xFF;\r\n\r\n        if (firstByte == 0x04) {\r\n            System.out.println(\"检测到未压缩格式 (04开头) - 使用C1C3C2转C1C2C3\");\r\n            return decryptC1C3C2(cipherBytes, privateKey);\r\n        } else if (firstByte == 0x02 || firstByte == 0x03) {\r\n            System.out.println(\"检测到压缩格式 (\" + String.format(\"%02x\", firstByte) + \"开头) - 直接解密\");\r\n            return decryptCompressed(cipherBytes, privateKey);\r\n        } else {\r\n            System.out.println(\"检测到未知格式，尝试自动处理\");\r\n            return tryAllFormats(cipherBytes, privateKey);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * C1C3C2 → C1C2C3 转换\r\n     */\r\n    public static byte[] convertC1C3C2ToC1C2C3(byte[] c1c3c2) {\r\n        int c1Len = 65; // 未压缩点：0x04 + 32x + 32y\r\n        int c3Len = 32; // SM3 digest (32字节)\r\n        int totalLen = c1c3c2.length;\r\n        int c2Len = totalLen - c1Len - c3Len;\r\n\r\n        // 验证长度\r\n        if (totalLen < c1Len + c3Len) {\r\n            throw new IllegalArgumentException(\"密文长度无效: \" + totalLen + \"，至少需要 \" + (c1Len + c3Len) + \" 字节\");\r\n        }\r\n\r\n        // System.out.println(\"C1C3C2转换详情:\");\r\n        // System.out.println(\"  - 总长度: \" + totalLen);\r\n        // System.out.println(\"  - C1长度: \" + c1Len);\r\n        // System.out.println(\"  - C3长度: \" + c3Len);\r\n        // System.out.println(\"  - C2长度: \" + c2Len);\r\n\r\n        // 分割各部分\r\n        byte[] c1 = Arrays.copyOfRange(c1c3c2, 0, c1Len);           // 公钥点\r\n        byte[] c3 = Arrays.copyOfRange(c1c3c2, c1Len, c1Len + c3Len); // SM3哈希\r\n        byte[] c2 = Arrays.copyOfRange(c1c3c2, c1Len + c3Len, totalLen); // 实际加密数据\r\n\r\n        // 重组为 C1C2C3\r\n        byte[] c1c2c3 = new byte[totalLen];\r\n        System.arraycopy(c1, 0, c1c2c3, 0, c1Len);           // C1\r\n        System.arraycopy(c2, 0, c1c2c3, c1Len, c2Len);       // C2\r\n        System.arraycopy(c3, 0, c1c2c3, c1Len + c2Len, c3Len); // C3\r\n\r\n        System.out.println(\"C1C3C2 → C1C2C3 转换完成\");\r\n        return c1c2c3;\r\n    }\r\n\r\n    /**\r\n     * 反向转换：C1C2C3 → C1C3C2\r\n     */\r\n    public static byte[] convertC1C2C3ToC1C3C2(byte[] c1c2c3) {\r\n        int c1Len = 65; // 未压缩点\r\n        int c3Len = 32; // SM3 digest\r\n        int totalLen = c1c2c3.length;\r\n        int c2Len = totalLen - c1Len - c3Len;\r\n\r\n        if (totalLen < c1Len + c3Len) {\r\n            throw new IllegalArgumentException(\"密文长度无效: \" + totalLen);\r\n        }\r\n\r\n        byte[] c1 = Arrays.copyOfRange(c1c2c3, 0, c1Len);\r\n        byte[] c2 = Arrays.copyOfRange(c1c2c3, c1Len, c1Len + c2Len);\r\n        byte[] c3 = Arrays.copyOfRange(c1c2c3, c1Len + c2Len, totalLen);\r\n\r\n        byte[] c1c3c2 = new byte[totalLen];\r\n        System.arraycopy(c1, 0, c1c3c2, 0, c1Len);\r\n        System.arraycopy(c3, 0, c1c3c2, c1Len, c3Len);\r\n        System.arraycopy(c2, 0, c1c3c2, c1Len + c3Len, c2Len);\r\n\r\n        return c1c3c2;\r\n    }\r\n\r\n    /**\r\n     * 未压缩格式解密（04开头）\r\n     */\r\n    private static String decryptC1C3C2(byte[] cipherBytes, PrivateKey privateKey) throws Exception {\r\n        // C1C3C2 → C1C2C3\r\n        byte[] c1c2c3 = convertC1C3C2ToC1C2C3(cipherBytes);\r\n\r\n        ECPrivateKeyParameters privKeyParam = (ECPrivateKeyParameters)\r\n                PrivateKeyFactory.createKey(privateKey.getEncoded());\r\n\r\n        // 使用C1C2C3模式解密\r\n        SM2Engine engine = new SM2Engine(SM2Engine.Mode.C1C2C3);\r\n        engine.init(false, privKeyParam);\r\n\r\n        byte[] plainBytes = engine.processBlock(c1c2c3, 0, c1c2c3.length);\r\n        return new String(plainBytes, StandardCharsets.UTF_8);\r\n    }\r\n\r\n    /**\r\n     * 压缩格式解密（02或03开头）\r\n     */\r\n    private static String decryptCompressed(byte[] cipherBytes, PrivateKey privateKey) throws Exception {\r\n        ECPrivateKeyParameters privKeyParam = (ECPrivateKeyParameters) PrivateKeyFactory.createKey(privateKey.getEncoded());\r\n\r\n        // 压缩格式通常直接使用C1C2C3模式\r\n        SM2Engine engine = new SM2Engine(SM2Engine.Mode.C1C2C3);\r\n        engine.init(false, privKeyParam);\r\n\r\n        byte[] plainBytes = engine.processBlock(cipherBytes, 0, cipherBytes.length);\r\n        return new String(plainBytes, StandardCharsets.UTF_8);\r\n    }\r\n\r\n    // 尝试所有可能的格式\r\n    private static String tryAllFormats(byte[] cipherBytes, PrivateKey privateKey) {\r\n        // 原有的尝试逻辑\r\n        String[] methods = {\r\n                \"原始数据(C1C2C3)\",\r\n                \"原始数据(C1C3C2)\",\r\n                \"添加04前缀(C1C2C3)\",\r\n                \"添加04前缀并转C1C2C3\"\r\n        };\r\n\r\n        byte[][] testData = {\r\n                cipherBytes, // 原始\r\n                cipherBytes, // 原始（不同模式）\r\n                addPrefix(cipherBytes, (byte) 0x04), // 加04\r\n                convertC1C3C2ToC1C2C3(addPrefix(cipherBytes, (byte) 0x04)) // 加04并转换\r\n        };\r\n\r\n        SM2Engine.Mode[] modes = {\r\n                SM2Engine.Mode.C1C2C3,\r\n                SM2Engine.Mode.C1C3C2,\r\n                SM2Engine.Mode.C1C2C3,\r\n                SM2Engine.Mode.C1C2C3\r\n        };\r\n\r\n        for (int i = 0; i < methods.length; i++) {\r\n            try {\r\n                ECPrivateKeyParameters privKeyParam = (ECPrivateKeyParameters)\r\n                        PrivateKeyFactory.createKey(privateKey.getEncoded());\r\n\r\n                SM2Engine engine = new SM2Engine(modes[i]);\r\n                engine.init(false, privKeyParam);\r\n\r\n                byte[] plainBytes = engine.processBlock(testData[i], 0, testData[i].length);\r\n                String result = new String(plainBytes, StandardCharsets.UTF_8);\r\n\r\n                System.out.println(\"✓ \" + methods[i] + \" 解密成功: \" + result);\r\n                return result;\r\n            } catch (Exception e) {\r\n                e.printStackTrace();\r\n                System.out.println(\"✗ \" + methods[i] + \" 失败: \" + e.getMessage());\r\n            }\r\n        }\r\n        throw new RuntimeException(\"所有解密尝试都失败\");\r\n    }\r\n\r\n    private static byte[] addPrefix(byte[] data, byte prefix) {\r\n        byte[] result = new byte[data.length + 1];\r\n        result[0] = prefix;\r\n        System.arraycopy(data, 0, result, 1, data.length);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * 从Base64加载私钥\r\n     */\r\n    public static PrivateKey loadPrivateKeyFromBase64(String pkcs8Base64) throws Exception {\r\n        byte[] pkcs8 = Base64.getDecoder().decode(pkcs8Base64);\r\n        PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(pkcs8);\r\n        KeyFactory keyFactory = KeyFactory.getInstance(\"EC\", \"BC\");\r\n        return keyFactory.generatePrivate(spec);\r\n    }\r\n\r\n    /**\r\n     * 测试方法\r\n     */\r\n    public static void main(String[] args) throws Exception {\r\n        // 服务端生成密钥对\r\n        KeyPair keyPair = generateSM2KeyPair();\r\n        // 发送前端需要的服务端密钥\r\n        String frontPublicKey = getUncompressedPubKeyHex(keyPair.getPublic());\r\n        // 后端私钥转换，易于保存\r\n        String privateKeyBase64 = getPrivateKeyPkcs8Base64(keyPair.getPrivate());\r\n        System.out.println(\"前端公钥: \" + frontPublicKey);\r\n        System.out.println(\"后端私钥: \" + privateKeyBase64);\r\n\r\n        // 测试数据\r\n        String encryptedHex = \"043aa90069a8ff7a4b4ab45a3a96e2bd6a3d6c0fd12f03d9332cff0c070c6a3baac1914697438318055fc1e72bc558720129d835fd6800c01420fdb83676f2f63cbaa165612f346e859c23b6b1b463bdc3be69406326570ab2df496890bfd55cd5a072cc26eea04bd83f2609a6\";\r\n        String privateKeyBase642 = \"MIGTAgEAMBMGByqGSM49AgEGCCqBHM9VAYItBHkwdwIBAQQgDSd+qEfDfdciXKEODn9fN5c7CfO6VsHlL765JEnePnmgCgYIKoEcz1UBgi2hRANCAAQFxSaO5eXZtgUKiRq383CDUvanY+7kmvOD/tMTajbOO7nmEqYOij2GWo9uN3mNgus7uy18isn39jQU/SeSBjbr\";\r\n\r\n        try {\r\n            PrivateKey privateKey = loadPrivateKeyFromBase64(privateKeyBase642);\r\n            String decryptedText = decryptFromFrontend(encryptedHex, privateKey);\r\n            System.out.println(\"解密成功! 结果: \" + decryptedText);\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        }\r\n\r\n        // 测试加密解密\r\n        String plainText = \"Hello, SM2加密测试!\";\r\n        System.out.println(\"原始文本: \" + plainText);\r\n\r\n        // 使用前端公钥加密\r\n        PublicKey publicKey = loadPublicKeyFromHex(frontPublicKey);\r\n        String encrypted = encryptForFrontend(plainText, publicKey);\r\n        System.out.println(\"加密结果: \" + encrypted);\r\n\r\n        // 使用后端私钥解密\r\n        PrivateKey privateKey = loadPrivateKeyFromBase64(privateKeyBase64);\r\n        String decrypted = decryptFromFrontend(encrypted, privateKey);\r\n        System.out.println(\"解密结果: \" + decrypted);\r\n\r\n        System.out.println(\"加解密验证: \" + plainText.equals(decrypted));\r\n    }\r\n\r\n    // <script src=\"https://cdn.jsdelivr.net/npm/sm-crypto@0.3.2/dist/sm2.min.js\"></script>\r\n    // let currentPublicKey = \"0405c5268ee5e5d9b6050a891ab7f3708352f6a763eee49af383fed3136a36ce3bb9e612a60e8a3d865a8f6e37798d82eb3bbb2d7c8ac9f7f63414fd27920636eb\";\r\n    // const encryptData = sm2.doEncrypt(plainText, currentPublicKey);\r\n}\r\n```\r\n\r\n```js\r\n// smutils.js\r\nexport function SM4Util() {\r\n    // 和后端key一致\r\n    this.secretKey=\"jjr9bez13evljita\";\r\n    // 当时用CBC模式的时候\r\n    this.iv = \"ZkR_SiNoSOFT=568\";\r\n    this.hexString = false;\r\n\r\n    // ECB模式加密\r\n    this.encryptData_ECB=function(plainText){\r\n        try{\r\n            const sm4 = new SM4();\r\n            const ctx = new SM4_Context();\r\n            ctx.isPadding = true;\r\n            ctx.mode = sm4.SM4_ENCRYPT;\r\n            const keyBytes = this.stringToByte(this.secretKey);\r\n            sm4.sm4_setkey_enc(ctx, keyBytes);\r\n            const encrypted = sm4.sm4_crypt_ecb(ctx, this.stringToByte(plainText));\r\n            const cipherText = base64js.fromByteArray(encrypted);\r\n            if (cipherText != null && cipherText.trim().length > 0)\r\n            {\r\n                cipherText.replace(/(\\s*|\\t|\\r|\\n)/g, \"\");\r\n            }\r\n            return cipherText;\r\n        }catch (e){\r\n            return null;\r\n        }\r\n    }\r\n    //解密_ECB\r\n    this.decryptData_ECB = function(cipherText) {\r\n        try {\r\n            let sm4 = new SM4();\r\n            let ctx = new SM4_Context();\r\n            ctx.isPadding = true;\r\n            ctx.mode = sm4.SM4_ENCRYPT;\r\n            let keyBytes = this.stringToByte(this.secretKey);\r\n            sm4.sm4_setkey_dec(ctx, keyBytes);\r\n            let decrypted = sm4.sm4_crypt_ecb(ctx, base64js.toByteArray(cipherText));\r\n            return this.byteToString(decrypted);\r\n        } catch (e) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    // CBC模式加密\r\n    this.encryptData_CBC=function(plainText){\r\n        try{\r\n            const sm4 = new SM4();\r\n            const ctx = new SM4_Context();\r\n            ctx.isPadding = true;\r\n            ctx.mode = sm4.SM4_ENCRYPT;\r\n\r\n            const keyBytes = this.stringToByte(this.secretKey);\r\n            const ivBytes = this.stringToByte(this.iv);\r\n\r\n            sm4.sm4_setkey_enc(ctx, keyBytes);\r\n            const encrypted = sm4.sm4_crypt_cbc(ctx, ivBytes, this.stringToByte(plainText));\r\n            const cipherText = base64js.fromByteArray(encrypted);\r\n            if (cipherText != null && cipherText.trim().length > 0)\r\n            {\r\n                cipherText.replace(/(\\s*|\\t|\\r|\\n)/g, \"\");\r\n            }\r\n            return cipherText;\r\n        }\r\n        catch ( e)\r\n        {\r\n            return null;\r\n        }\r\n    }\r\n    //解密_CBC\r\n    this.decryptData_CBC = function(cipherText) {\r\n        try {\r\n            let sm4 = new SM4();\r\n            let ctx = new SM4_Context();\r\n            ctx.isPadding = true;\r\n            ctx.mode = sm4.SM4_ENCRYPT;\r\n            let keyBytes = this.stringToByte(this.secretKey);\r\n            let ivBytes = this.stringToByte(this.iv);\r\n            sm4.sm4_setkey_dec(ctx, keyBytes);\r\n            let decrypted = sm4.sm4_crypt_cbc(ctx, ivBytes, base64js.toByteArray(cipherText));\r\n            return this.byteToString(decrypted);\r\n        } catch (e) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    this.stringToByte=function(str) {\r\n        const bytes = [];\r\n        let len, c;\r\n        len = str.length;\r\n        for(let i = 0; i < len; i++) {\r\n            c = str.charCodeAt(i);\r\n            if(c >= 0x010000 && c <= 0x10FFFF) {\r\n                bytes.push(((c >> 18) & 0x07) | 0xF0);\r\n                bytes.push(((c >> 12) & 0x3F) | 0x80);\r\n                bytes.push(((c >> 6) & 0x3F) | 0x80);\r\n                bytes.push((c & 0x3F) | 0x80);\r\n            } else if(c >= 0x000800 && c <= 0x00FFFF) {\r\n                bytes.push(((c >> 12) & 0x0F) | 0xE0);\r\n                bytes.push(((c >> 6) & 0x3F) | 0x80);\r\n                bytes.push((c & 0x3F) | 0x80);\r\n            } else if(c >= 0x000080 && c <= 0x0007FF) {\r\n                bytes.push(((c >> 6) & 0x1F) | 0xC0);\r\n                bytes.push((c & 0x3F) | 0x80);\r\n            } else {\r\n                bytes.push(c & 0xFF);\r\n            }\r\n        }\r\n        return bytes;\r\n    }\r\n\r\n\r\n    this.byteToString=function(arr) {\r\n        if(typeof arr === 'string') {\r\n            return arr;\r\n        }\r\n        let str = '',\r\n            _arr = arr;\r\n        for(let i = 0; i < _arr.length; i++) {\r\n            const one = _arr[i].toString(2),\r\n                v = one.match(/^1+?(?=0)/);\r\n            if(v && one.length === 8) {\r\n                const bytesLength = v[0].length;\r\n                let store = _arr[i].toString(2).slice(7 - bytesLength);\r\n                for(let st = 1; st < bytesLength; st++) {\r\n                    store += _arr[st + i].toString(2).slice(2);\r\n                }\r\n                str += String.fromCharCode(parseInt(store, 2));\r\n                i += bytesLength - 1;\r\n            } else {\r\n                str += String.fromCharCode(_arr[i]);\r\n            }\r\n        }\r\n        return str;\r\n    }\r\n}\r\n```\r\n\r\n## CORS\r\n\r\n**描述**\r\n\r\n前后端分离的项目，为了保证正常访问，需设置跨域，由于配置不当：\t\r\n1. CORS服务端的`Access-Control-Allow-Origin`设置为了\\*，并且`Access-Control-Allow-Credentials`设置为false。\r\n2. `Access-Control-Allow-Origin`设置不是固定的，而是根据用户跨域请求数据的Origin来定。不管`Access-Control-Allow-Credentials`设置为了true还是false，任何网站都可以发起请求，并读取对这些请求的响应。\r\n\r\n上述两种情况任何一个网站都可以发送跨域请求来获得CORS服务端上的数据，从而造成跨域漏洞。\r\n\r\n**防护建议**\r\n\r\n1. 配置白名单，仅允许指定的源来跨域请求服务器端的资源，并且服务器会响应。\r\n`Access-Control-Allow-Origin: https://xxxx.com`\r\n```nginx\r\n# 定义合法的Origin列表 解决跨域问题\r\nmap $http_origin $allowed_origin {\r\n    default 0;\r\n    \"~……http://10\\.37\\.169\\.111(:[0-9+])?$\" $http_origin;\r\n    \"\" 1;\r\n    \"null\" 1; # 允许没有Origin的情况\r\n}\r\nlocation / {\r\n    # ...其他配置\r\n    if ($allowed_origin = 0) {\r\n        return 403 \"Invalid Origin\";\r\n    }\r\n    add_header Access-Control-Allow-Origin $allowed_origin;\r\n}\r\n```\r\n2. @CrossOrigin注解解决跨域问题，在需要允许跨域访问的接口或者类加上该注解就可以，如果用@RequestMapping，则要指定get，或post等才有起效。\r\n`@CrossOrigin(origins=\"http://localhost:4000\")`\r\n\r\n## XSS\r\n\r\n**描述**\r\n\r\nXSS的全称是跨站脚本攻击。它是一种将恶意脚本注入到其他用户信任的网站中的攻击方式。\r\n\r\n1. 反射型XSS\r\n2. 存储型XSS\r\n3. DOM型XSS\r\n\r\n**代码实现**\r\n```java\r\n// 存储型xss\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.springframework.util.StreamUtils;\r\n\r\nimport javax.servlet.ReadListener;\r\nimport javax.servlet.ServletInputStream;\r\nimport javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpServletRequestWrapper;\r\nimport java.io.BufferedReader;\r\nimport java.io.ByteArrayInputStream;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.util.*;\r\nimport java.util.regex.Pattern;\r\n\r\n@Slf4j\r\npublic class XssAndSqlHttpServletRequestWrapper extends HttpServletRequestWrapper {\r\n\r\n    HttpServletRequest orgRequest = null;\r\n    private Map<String, String[]> parameterMap;\r\n    /**\r\n     * 用于保存读取body中数据\r\n      */\r\n    private final byte[] body;\r\n\r\n    /**\r\n     * sql keywords pattern\r\n     */\r\n    private static String[] sqlKeywords = {\"and\", \"or\", \"insert\", \"select\", \"delete\", \"update\", \"count\", \"chr\", \"mid\", \"master\", \"truncate\", \"char\", \"declare\", \"backup\", \"script\", \"exec\"};\r\n\r\n\r\n    /**\r\n     * xss pattern\r\n     */\r\n    private static Pattern[] patterns = {\r\n        // Avoid anything between script tags\r\n        Pattern.compile(\"<[\\r\\n| | ]*script[\\r\\n| | ]*>(.*?)</[\\r\\n| | ]*script[\\r\\n| | ]*>\", Pattern.CASE_INSENSITIVE),\r\n        // Remove any lonesome <script ...> tag\r\n        Pattern.compile(\"<[\\r\\n| | ]*script(.*?)>\", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL),\r\n        // Remove any lonesome </script> tag\r\n        Pattern.compile(\"</[\\r\\n| | ]*script[\\r\\n| | ]*>\", Pattern.CASE_INSENSITIVE),\r\n        // Avoid anything in a src=\"http://www.xxx.com/xx/java/...\" type of expression\r\n        Pattern.compile(\"src[\\r\\n| | ]*=[\\r\\n| | ]*[\\\\\\\"|\\\\\\'](.*?)[\\\\\\\"|\\\\\\']\", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL),\r\n        // Avoid eval(...) expressions\r\n        Pattern.compile(\"eval\\\\((.*?)\\\\)\", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL),\r\n        // Avoid e-xpression(...) expressions\r\n        Pattern.compile(\"e-xpression\\\\((.*?)\\\\)\", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL),\r\n        // Avoid javaScript:... expressions\r\n        Pattern.compile(\"javascript[\\r\\n| | ]*:[\\r\\n| | ]*\", Pattern.CASE_INSENSITIVE),\r\n        // Avoid vbScript:... expressions\r\n        Pattern.compile(\"vbscript[\\r\\n| | ]*:[\\r\\n| | ]*\", Pattern.CASE_INSENSITIVE),\r\n        // Avoid onload= expressions\r\n        Pattern.compile(\"onload(.*?)=\", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL),\r\n        // 特殊字符,不使用的特殊字符直接过滤掉，如果需要使用，不在这里配置，在下面转换为全角\r\n        Pattern.compile(\"[|&;$%@',\\\"<>()+*\\\\r\\\\n\\\\\\\\]\"),\r\n        Pattern.compile(\"(0x0a)|(0x0d)\"),\r\n        // 关键字\r\n        Pattern.compile(addSqlKeyWords(sqlKeywords), Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL)\r\n    };\r\n\r\n    private static String addSqlKeyWords(String[] map) {\r\n        StringBuilder sb = new StringBuilder();\r\n        for (String key: map) {\r\n            sb.append(\"(\").append(key).append(\" )\").append(\"|\");\r\n        }\r\n        sb.deleteCharAt(sb.length() - 1);\r\n        return sb.toString();\r\n    }\r\n\r\n    public XssAndSqlHttpServletRequestWrapper(HttpServletRequest request) throws IOException {\r\n        super(request);\r\n        orgRequest = request;\r\n        parameterMap = request.getParameterMap();\r\n        body = StreamUtils.copyToByteArray(request.getInputStream());\r\n    }\r\n\r\n    // 重写几个HttpServletRequestWrapper中的方法↓\r\n\r\n    /**\r\n     * 获取所有参数名\r\n     *\r\n     * @return 返回所有参数名\r\n     */\r\n    @Override\r\n    public Enumeration<String> getParameterNames() {\r\n        Vector<String> vector = new Vector<String>(parameterMap.keySet());\r\n        return vector.elements();\r\n    }\r\n\r\n    /**\r\n     * 覆盖getParameter方法，将参数名和参数值都做xss & sql过滤。<br/>\r\n     * 如果需要获得原始的值，则通过super.getParameterValues(name)来获取<br/>\r\n     * getParameterNames,getParameterValues和getParameterMap也可能需要覆盖\r\n     */\r\n    @Override\r\n    public String getParameter(String name) {\r\n        String[] results = parameterMap.get(name);\r\n        if (results == null || results.length <= 0) {\r\n            return null;\r\n        } else {\r\n            String value = results[0];\r\n            if (value != null) {\r\n                value = xssEncode(value);\r\n            }\r\n            return value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 获取指定参数名的所有值的数组，如：checkbox的所有数据 接收数组变量 ，如checkobx类型\r\n     */\r\n    @Override\r\n    public String[] getParameterValues(String name) {\r\n        String[] results = parameterMap.get(name);\r\n        if (results == null || results.length <= 0) {\r\n            return null;\r\n        } else {\r\n            int length = results.length;\r\n            for (int i = 0; i < length; i++) {\r\n                results[i] = xssEncode(results[i]);\r\n            }\r\n            return results;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 覆盖getHeader方法，将参数名和参数值都做xss & sql过滤。<br/>\r\n     * 如果需要获得原始的值，则通过super.getHeaders(name)来获取<br/>\r\n     * getHeaderNames 也可能需要覆盖\r\n     */\r\n    @Override\r\n    public String getHeader(String name) {\r\n\r\n        String value = super.getHeader(name);\r\n        if (value != null) {\r\n            value = xssEncode(value);\r\n        }\r\n        return value;\r\n    }\r\n\r\n    /**\r\n     * 将容易引起xss & sql漏洞的半角字符直接替换成全角字符\r\n     *\r\n     * @param s\r\n     * @return\r\n     */\r\n    private static String xssEncode(String s) {\r\n        if (s == null || s.isEmpty()) {\r\n            return s;\r\n        } else {\r\n            s = stripXSSAndSql(s);\r\n        }\r\n        StringBuilder sb = new StringBuilder(s.length() + 16);\r\n        for (int i = 0; i < s.length(); i++) {\r\n            char c = s.charAt(i);\r\n            switch (c) {\r\n                case '>':\r\n                    // 转义大于号\r\n                    sb.append(\"＞\");\r\n                    break;\r\n                case '<':\r\n                    // 转义小于号\r\n                    sb.append(\"＜\");\r\n                    break;\r\n                case '\\'':\r\n                    // 转义单引号\r\n                    sb.append(\"＇\");\r\n                    break;\r\n                case '\\\"':\r\n                    // 转义双引号\r\n                    sb.append(\"＂\");\r\n                    break;\r\n                case '&':\r\n                    // 转义&\r\n                    sb.append(\"＆\");\r\n                    break;\r\n                case '#':\r\n                    // 转义#\r\n                    sb.append(\"＃\");\r\n                    break;\r\n                case '(':\r\n                    // 转义#\r\n                    sb.append(\"（\");\r\n                    break;\r\n                case ')':\r\n                    // 转义#\r\n                    sb.append(\"）\");\r\n                    break;\r\n                case ';':\r\n                    // 转义#\r\n                    sb.append(\"；\");\r\n                    break;\r\n                default:\r\n                    sb.append(c);\r\n                    break;\r\n            }\r\n        }\r\n        return sb.toString();\r\n    }\r\n\r\n    /**\r\n     * 获取最原始的request\r\n     *\r\n     * @return\r\n     */\r\n    public HttpServletRequest getOrgRequest() {\r\n        return orgRequest;\r\n    }\r\n\r\n    /**\r\n     * 获取最原始的request的静态方法\r\n     *\r\n     * @return\r\n     */\r\n    public static HttpServletRequest getOrgRequest(HttpServletRequest req) {\r\n        if (req instanceof XssAndSqlHttpServletRequestWrapper) {\r\n            return ((XssAndSqlHttpServletRequestWrapper) req).getOrgRequest();\r\n        }\r\n\r\n        return req;\r\n    }\r\n\r\n    /**\r\n     * 防止xss跨脚本攻击（替换，根据实际情况调整）\r\n     */\r\n\r\n    public static String stripXSSAndSql(String value) {\r\n        if (value != null) {\r\n            for (Pattern pattern : patterns) {\r\n                value = pattern.matcher(value).replaceAll(\"\");\r\n            }\r\n        }\r\n        return value;\r\n    }\r\n\r\n    public boolean checkXSSAndSql(String value) {\r\n        if (value != null) {\r\n            for (Pattern pattern : patterns) {\r\n                if (pattern.matcher(value).find()) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public final boolean checkParameter() {\r\n        Map<String, String[]> submitParams = new HashMap(parameterMap);\r\n        Set<String> submitNames = submitParams.keySet();\r\n        for (String submitName : submitNames) {\r\n            Object submitValues = submitParams.get(submitName);\r\n            if ((submitValues instanceof String)) {\r\n                if (checkXSSAndSql((String) submitValues)) {\r\n                    return true;\r\n                }\r\n            } else if ((submitValues instanceof String[])) {\r\n                for (String submitValue : (String[]) submitValues) {\r\n                    if (checkXSSAndSql(submitValue)) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    @Override\r\n    public BufferedReader getReader() throws IOException {\r\n        return new BufferedReader(new InputStreamReader(getInputStream()));\r\n    }\r\n\r\n    @Override\r\n    public ServletInputStream getInputStream() throws IOException {\r\n        final ByteArrayInputStream bais = new ByteArrayInputStream(body);\r\n        return new ServletInputStream() {\r\n\r\n            @Override\r\n            public int read() throws IOException {\r\n                return bais.read();\r\n            }\r\n\r\n            @Override\r\n            public boolean isFinished() {\r\n                return false;\r\n            }\r\n\r\n            @Override\r\n            public boolean isReady() {\r\n                return false;\r\n            }\r\n\r\n            @Override\r\n            public void setReadListener(ReadListener arg0) {}\r\n        };\r\n    }\r\n}\r\n\r\n// 过滤器中实现\r\n@WebFilter(\"/*\")  // 过滤所有请求\r\npublic class XSSFilter implements Filter {\r\n    \r\n    @Override\r\n    public void init(FilterConfig filterConfig) throws ServletException {\r\n        // 初始化代码\r\n    }\r\n    \r\n    @Override\r\n    public void doFilter(ServletRequest request, ServletResponse response, \r\n                         FilterChain chain) throws IOException, ServletException {\r\n        \r\n        HttpServletRequest httpRequest = (HttpServletRequest) request;\r\n        \r\n        // 创建包装器\r\n        HttpServletRequest wrappedRequest = new XssAndSqlHttpServletRequestWrapper(httpRequest);\r\n        \r\n        // 继续过滤器链，传递包装后的请求\r\n        chain.doFilter(wrappedRequest, response);\r\n    }\r\n    \r\n    @Override\r\n    public void destroy() {\r\n        // 清理代码\r\n    }\r\n}\r\n```\r\n\r\n## CSRF\r\n\r\n**描述**\r\n\r\nCSRF，全称Cross-site request forgery，即跨站请求伪造，是指利用受害者尚未失效的身份认证信息（cookie、会话等），诱骗其点击恶意链接或者访问包含攻击代码的页面，在受害人不知情的情况下以受害者的身份向（身份认证信息所对应的）服务器发送请求，从而完成非法操作（如转账、改密等）。\r\n\r\n**防护建议**\r\n\r\n1. 验证HTTP referer字段\r\n在后端程序接收到请求时，应检查请求的来源地址（HTTP Referer）是否合法（利用白名单），如果请求来源不在指定的名单中，即视为CSRF。\r\n```nginx\r\n# 定义合法的Referer\r\n# none:允许没有Referer头的请求。blocked:允许Referer头存在但值被防火墙或代理服务器修改、删除（值为空）的请求。server_names:允许Referer头与server_name中定义的其中一个域名匹配的请求。\r\n# 如果配置不管用,可以看下location里面的配置\r\nvalid_referers none blocked server_names yoursite.com *.trusted-site.com;\r\nif ($invalid_referer) {\r\n    # 返回403禁止访问\r\n    return 403;\r\n}\r\n\r\n# location块referer配置(后端代码没有referer配置的话 启用nginx referer配置)\r\nset $allow_referer 1;\r\n\r\nif($http_referer !~ \"^http://10\\.39\\.169\\.22(:[0-9]+)?\") {\r\n    set $allow_referer 0;\r\n}\r\n\r\nif($allow_referer = 0){\r\n    return 403\r\n}\r\n```\r\n2. 随机token\r\n对于敏感的网页，可在请求参数或者请求header中增加不可伪造的token等信息用户防护CSRF攻击(可利用防重放攻击中的sign当作token)。\r\n\r\n## SQL注入\r\n\r\n**代码实现**\r\n\r\n```java\r\nimport java.util.Enumeration;\r\nimport java.util.Locale;\r\nimport java.util.regex.Matcher;\r\nimport java.util.regex.Pattern;\r\nimport javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpServletResponse;\r\n\r\nimport org.apache.commons.lang3.StringUtils;\r\nimport org.springframework.web.servlet.HandlerInterceptor;\r\nimport org.springframework.web.servlet.ModelAndView;\r\n/**\r\n * sql注入拦截\r\n */\r\npublic class SQLInterceptor implements HandlerInterceptor {\r\n\r\n\t@Override\r\n\tpublic void afterCompletion(HttpServletRequest arg0,\r\n\t\t\tHttpServletResponse arg1, Object arg2, Exception arg3)\r\n    {\r\n\t\r\n\t}\r\n\r\n\t@Override\r\n\tpublic void postHandle(HttpServletRequest arg0, HttpServletResponse arg1,\r\n\t\t\tObject arg2, ModelAndView arg3)  {\r\n\t\t\r\n\t}\r\n\r\n\tpublic boolean preHandle(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2)  {\r\n\t\tEnumeration<String> names = arg0.getParameterNames();  \r\n        while(names.hasMoreElements()){  \r\n            String name = names.nextElement();  \r\n            String[] values = arg0.getParameterValues(name);\r\n            if(values!=null){\r\n                for(String value: values){\r\n                    //sql注入直接拦截\r\n                    Locale.setDefault(Locale.ENGLISH);\r\n                    if(judgeSQLInject(value.toLowerCase())){\r\n                        return false;\r\n                    }\r\n                    //跨站xss清理\r\n                    clearXss(value);\r\n                }\r\n            }\r\n        }  \r\n        return true;  \r\n\t}\r\n\t\r\n\t/**\r\n\t * 校验sql注入字符串\r\n\t */\r\n    public boolean judgeSQLInject(String value){  \r\n        if(value == null || StringUtils.isBlank(value)){\r\n            return false;\r\n        } \r\n        //insert|and|or|select|update|delete|drop|truncate|%20|=|--|;|'|%|#|+|,|//|/|\\\\|!=|(|)\r\n//        String sqlStr = \">|<|script| insert | and | or | select | update | delete | drop | truncate |%20|-|--|'|%|+|//|/|\\\\|!=|(|)\";\r\n        String sqlStr = \">|<|script| insert | and | or | select | update | delete | drop | truncate |%20|--|%|+|//|\\\\|!=|(|)\";  \r\n        String[] sqlArr = sqlStr.split(\"\\\\|\");  \r\n        for(int i=0;i<sqlArr.length;i++){  \r\n            if(value.indexOf(sqlArr[i])>-1){\r\n            \tif(!isSpecialParam(value)){\r\n\r\n            \t\treturn true;\t\r\n            \t}\r\n            }  \r\n        }  \r\n        return false;  \r\n    }\r\n    \r\n    /**\r\n     * 针对用到的必要特殊参数字符在此判断\r\n     */\r\n    public boolean isSpecialParam(String value){\r\n    \tboolean isSpecial = false;//是否为特殊字符串\r\n//    \tPattern pattern = Pattern.compile(\"[0-9]-[0-9]|.*image/octet-stream;base64.*|[0-9] [0-9]\");\r\n    \tPattern pattern = Pattern.compile(\".*image/octet-stream;base64.*\");\r\n\t\tMatcher matcher = pattern.matcher(value);\r\n\t\tif(matcher.find()){\r\n\t\t\tisSpecial = true;\r\n\t\t}\r\n\t\treturn isSpecial;\r\n    }\r\n    \r\n    /**\r\n     * 处理跨站xss字符转义\r\n     */\r\n    private String clearXss(String value) {\r\n        if (value == null || StringUtils.isBlank(value)) {\r\n            return value;\r\n        }\r\n        value = value.replaceAll(\"<\", \"\").replaceAll(\">\", \"\").replace(\"'\",\"\");\r\n        value = value.replaceAll(\"eval\\\\((.*)\\\\)\", \"\");\r\n        value = value.replaceAll(\"[\\\\\\\"\\\\\\'][\\\\s]*javascript:(.*)[\\\\\\\"\\\\\\']\",\r\n                \"\\\"\\\"\");\r\n        value = value.replace(\"script\", \"\");\r\n        return value;\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n","categories":[],"tags":[{"name":"代码实战","path":"api/tags/代码实战.json"}]}